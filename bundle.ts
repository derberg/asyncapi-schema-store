function concat(...buf) {
    let length = 0;
    for (const b of buf){
        length += b.length;
    }
    const output = new Uint8Array(length);
    let index = 0;
    for (const b1 of buf){
        output.set(b1, index);
        index += b1.length;
    }
    return output;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
class DenoStdInternalError extends Error {
    constructor(message8){
        super(message8);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
    #tryGrowByReslice = (n)=>{
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    };
    #reslice = (len)=>{
        assert(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    };
    readSync(p) {
        if (this.empty()) {
            this.reset();
            if (p.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy(this.#buf.subarray(this.#off), p);
        this.#off += nread;
        return nread;
    }
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = this.#grow(p.byteLength);
        return copy(p, this.#buf, m);
    }
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
    #grow = (n)=>{
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n <= Math.floor(c / 2) - m) {
            copy(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
            copy(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n, MAX_SIZE));
        return m;
    };
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {
}));
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
class NodeInvalidArgTypeError extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName, type2, received){
        super(`The "${argumentName}" argument must be of type ${type2}. Received ${typeof received}`);
    }
}
function promisify(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError("original", "Function", original);
    }
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
            throw new NodeInvalidArgTypeError("util.promisify.custom", "Function", fn);
        }
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve, reject)=>{
            original.call(this, ...args, (err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {
                    };
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
class NodeFalsyValueRejectionError extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason2){
        super("Promise was rejected with falsy value");
        this.reason = reason2;
    }
}
class NodeInvalidArgTypeError1 extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName1){
        super(`The ${argumentName1} argument must be of type function.`);
    }
}
class AssertionError extends Error {
    constructor(message1){
        super(message1);
        this.name = "AssertionError";
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
const DEFAULT_BUFFER_SIZE = 32 * 1024;
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
async function* iter(r, options) {
    const bufSize = options?.bufSize ?? DEFAULT_BUFFER_SIZE;
    const b = new Uint8Array(bufSize);
    while(true){
        const result = await r.read(b);
        if (result === null) {
            break;
        }
        yield b.subarray(0, result);
    }
}
const CHAR_SPACE = " ".charCodeAt(0);
const CHAR_TAB = "\t".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const WHITESPACES = [
    CHAR_SPACE,
    CHAR_TAB
];
const decoder = new TextDecoder();
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
function str(buf) {
    return !buf ? "" : decoder.decode(buf);
}
class TextProtoReader {
    r;
    constructor(r1){
        this.r = r1;
    }
    async readLine() {
        const s = await this.readLineSlice();
        return s === null ? null : str(s);
    }
    async readMIMEHeader() {
        const m = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (WHITESPACES.includes(buf[0])) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (WHITESPACES.includes(buf[0])) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            let i = kv.indexOf(CHAR_COLON);
            if (i < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
            }
            const key = str(kv.subarray(0, i));
            if (key == "") {
                continue;
            }
            i++;
            while(i < kv.byteLength && WHITESPACES.includes(kv[i])){
                i++;
            }
            const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
            try {
                m.append(key, value);
            } catch  {
            }
        }
    }
    async readLineSlice() {
        let line = new Uint8Array(0);
        let r1 = null;
        do {
            r1 = await this.r.readLine();
            if (r1 !== null && this.skipSpace(r1.line) !== 0) {
                line = concat(line, r1.line);
            }
        }while (r1 !== null && r1.more)
        return r1 === null ? null : line;
    }
    skipSpace(l) {
        let n = 0;
        for (const val of l){
            if (!WHITESPACES.includes(val)) {
                n++;
            }
        }
        return n;
    }
}
var Status;
(function(Status1) {
    Status1[Status1["Continue"] = 100] = "Continue";
    Status1[Status1["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status1[Status1["Processing"] = 102] = "Processing";
    Status1[Status1["EarlyHints"] = 103] = "EarlyHints";
    Status1[Status1["OK"] = 200] = "OK";
    Status1[Status1["Created"] = 201] = "Created";
    Status1[Status1["Accepted"] = 202] = "Accepted";
    Status1[Status1["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status1[Status1["NoContent"] = 204] = "NoContent";
    Status1[Status1["ResetContent"] = 205] = "ResetContent";
    Status1[Status1["PartialContent"] = 206] = "PartialContent";
    Status1[Status1["MultiStatus"] = 207] = "MultiStatus";
    Status1[Status1["AlreadyReported"] = 208] = "AlreadyReported";
    Status1[Status1["IMUsed"] = 226] = "IMUsed";
    Status1[Status1["MultipleChoices"] = 300] = "MultipleChoices";
    Status1[Status1["MovedPermanently"] = 301] = "MovedPermanently";
    Status1[Status1["Found"] = 302] = "Found";
    Status1[Status1["SeeOther"] = 303] = "SeeOther";
    Status1[Status1["NotModified"] = 304] = "NotModified";
    Status1[Status1["UseProxy"] = 305] = "UseProxy";
    Status1[Status1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status1[Status1["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status1[Status1["BadRequest"] = 400] = "BadRequest";
    Status1[Status1["Unauthorized"] = 401] = "Unauthorized";
    Status1[Status1["PaymentRequired"] = 402] = "PaymentRequired";
    Status1[Status1["Forbidden"] = 403] = "Forbidden";
    Status1[Status1["NotFound"] = 404] = "NotFound";
    Status1[Status1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status1[Status1["NotAcceptable"] = 406] = "NotAcceptable";
    Status1[Status1["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status1[Status1["RequestTimeout"] = 408] = "RequestTimeout";
    Status1[Status1["Conflict"] = 409] = "Conflict";
    Status1[Status1["Gone"] = 410] = "Gone";
    Status1[Status1["LengthRequired"] = 411] = "LengthRequired";
    Status1[Status1["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status1[Status1["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status1[Status1["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status1[Status1["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status1[Status1["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status1[Status1["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status1[Status1["Teapot"] = 418] = "Teapot";
    Status1[Status1["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status1[Status1["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status1[Status1["Locked"] = 423] = "Locked";
    Status1[Status1["FailedDependency"] = 424] = "FailedDependency";
    Status1[Status1["TooEarly"] = 425] = "TooEarly";
    Status1[Status1["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status1[Status1["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status1[Status1["TooManyRequests"] = 429] = "TooManyRequests";
    Status1[Status1["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status1[Status1["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status1[Status1["InternalServerError"] = 500] = "InternalServerError";
    Status1[Status1["NotImplemented"] = 501] = "NotImplemented";
    Status1[Status1["BadGateway"] = 502] = "BadGateway";
    Status1[Status1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status1[Status1["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status1[Status1["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status1[Status1["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status1[Status1["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status1[Status1["LoopDetected"] = 508] = "LoopDetected";
    Status1[Status1["NotExtended"] = 510] = "NotExtended";
    Status1[Status1["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status || (Status = {
}));
const STATUS_TEXT = new Map([
    [
        Status.Continue,
        "Continue"
    ],
    [
        Status.SwitchingProtocols,
        "Switching Protocols"
    ],
    [
        Status.Processing,
        "Processing"
    ],
    [
        Status.EarlyHints,
        "Early Hints"
    ],
    [
        Status.OK,
        "OK"
    ],
    [
        Status.Created,
        "Created"
    ],
    [
        Status.Accepted,
        "Accepted"
    ],
    [
        Status.NonAuthoritativeInfo,
        "Non-Authoritative Information"
    ],
    [
        Status.NoContent,
        "No Content"
    ],
    [
        Status.ResetContent,
        "Reset Content"
    ],
    [
        Status.PartialContent,
        "Partial Content"
    ],
    [
        Status.MultiStatus,
        "Multi-Status"
    ],
    [
        Status.AlreadyReported,
        "Already Reported"
    ],
    [
        Status.IMUsed,
        "IM Used"
    ],
    [
        Status.MultipleChoices,
        "Multiple Choices"
    ],
    [
        Status.MovedPermanently,
        "Moved Permanently"
    ],
    [
        Status.Found,
        "Found"
    ],
    [
        Status.SeeOther,
        "See Other"
    ],
    [
        Status.NotModified,
        "Not Modified"
    ],
    [
        Status.UseProxy,
        "Use Proxy"
    ],
    [
        Status.TemporaryRedirect,
        "Temporary Redirect"
    ],
    [
        Status.PermanentRedirect,
        "Permanent Redirect"
    ],
    [
        Status.BadRequest,
        "Bad Request"
    ],
    [
        Status.Unauthorized,
        "Unauthorized"
    ],
    [
        Status.PaymentRequired,
        "Payment Required"
    ],
    [
        Status.Forbidden,
        "Forbidden"
    ],
    [
        Status.NotFound,
        "Not Found"
    ],
    [
        Status.MethodNotAllowed,
        "Method Not Allowed"
    ],
    [
        Status.NotAcceptable,
        "Not Acceptable"
    ],
    [
        Status.ProxyAuthRequired,
        "Proxy Authentication Required"
    ],
    [
        Status.RequestTimeout,
        "Request Timeout"
    ],
    [
        Status.Conflict,
        "Conflict"
    ],
    [
        Status.Gone,
        "Gone"
    ],
    [
        Status.LengthRequired,
        "Length Required"
    ],
    [
        Status.PreconditionFailed,
        "Precondition Failed"
    ],
    [
        Status.RequestEntityTooLarge,
        "Request Entity Too Large"
    ],
    [
        Status.RequestURITooLong,
        "Request URI Too Long"
    ],
    [
        Status.UnsupportedMediaType,
        "Unsupported Media Type"
    ],
    [
        Status.RequestedRangeNotSatisfiable,
        "Requested Range Not Satisfiable"
    ],
    [
        Status.ExpectationFailed,
        "Expectation Failed"
    ],
    [
        Status.Teapot,
        "I'm a teapot"
    ],
    [
        Status.MisdirectedRequest,
        "Misdirected Request"
    ],
    [
        Status.UnprocessableEntity,
        "Unprocessable Entity"
    ],
    [
        Status.Locked,
        "Locked"
    ],
    [
        Status.FailedDependency,
        "Failed Dependency"
    ],
    [
        Status.TooEarly,
        "Too Early"
    ],
    [
        Status.UpgradeRequired,
        "Upgrade Required"
    ],
    [
        Status.PreconditionRequired,
        "Precondition Required"
    ],
    [
        Status.TooManyRequests,
        "Too Many Requests"
    ],
    [
        Status.RequestHeaderFieldsTooLarge,
        "Request Header Fields Too Large"
    ],
    [
        Status.UnavailableForLegalReasons,
        "Unavailable For Legal Reasons"
    ],
    [
        Status.InternalServerError,
        "Internal Server Error"
    ],
    [
        Status.NotImplemented,
        "Not Implemented"
    ],
    [
        Status.BadGateway,
        "Bad Gateway"
    ],
    [
        Status.ServiceUnavailable,
        "Service Unavailable"
    ],
    [
        Status.GatewayTimeout,
        "Gateway Timeout"
    ],
    [
        Status.HTTPVersionNotSupported,
        "HTTP Version Not Supported"
    ],
    [
        Status.VariantAlsoNegotiates,
        "Variant Also Negotiates"
    ],
    [
        Status.InsufficientStorage,
        "Insufficient Storage"
    ],
    [
        Status.LoopDetected,
        "Loop Detected"
    ],
    [
        Status.NotExtended,
        "Not Extended"
    ],
    [
        Status.NetworkAuthenticationRequired,
        "Network Authentication Required"
    ], 
]);
function deferred() {
    let methods;
    const promise = new Promise((resolve, reject)=>{
        methods = {
            resolve,
            reject
        };
    });
    return Object.assign(promise, methods);
}
const encoder3 = new TextEncoder();
function emptyReader() {
    return {
        read (_) {
            return Promise.resolve(null);
        }
    };
}
function bodyReader(contentLength, r1) {
    let totalRead = 0;
    let finished = false;
    async function read(buf) {
        if (finished) return null;
        let result;
        const remaining = contentLength - totalRead;
        if (remaining >= buf.byteLength) {
            result = await r1.read(buf);
        } else {
            const readBuf = buf.subarray(0, remaining);
            result = await r1.read(readBuf);
        }
        if (result !== null) {
            totalRead += result;
        }
        finished = totalRead === contentLength;
        return result;
    }
    return {
        read
    };
}
function chunkedBodyReader(h, r1) {
    const tp = new TextProtoReader(r1);
    let finished = false;
    const chunks = [];
    async function read(buf) {
        if (finished) return null;
        const [chunk] = chunks;
        if (chunk) {
            const chunkRemaining = chunk.data.byteLength - chunk.offset;
            const readLength = Math.min(chunkRemaining, buf.byteLength);
            for(let i = 0; i < readLength; i++){
                buf[i] = chunk.data[chunk.offset + i];
            }
            chunk.offset += readLength;
            if (chunk.offset === chunk.data.byteLength) {
                chunks.shift();
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
            }
            return readLength;
        }
        const line = await tp.readLine();
        if (line === null) throw new Deno.errors.UnexpectedEof();
        const [chunkSizeString] = line.split(";");
        const chunkSize = parseInt(chunkSizeString, 16);
        if (Number.isNaN(chunkSize) || chunkSize < 0) {
            throw new Deno.errors.InvalidData("Invalid chunk size");
        }
        if (chunkSize > 0) {
            if (chunkSize > buf.byteLength) {
                let eof = await r1.readFull(buf);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                eof = await r1.readFull(restChunk);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                } else {
                    chunks.push({
                        offset: 0,
                        data: restChunk
                    });
                }
                return buf.byteLength;
            } else {
                const bufToFill = buf.subarray(0, chunkSize);
                const eof = await r1.readFull(bufToFill);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                return chunkSize;
            }
        } else {
            assert(chunkSize === 0);
            if (await r1.readLine() === null) {
                throw new Deno.errors.UnexpectedEof();
            }
            await readTrailers1(h, r1);
            finished = true;
            return null;
        }
    }
    return {
        read
    };
}
const DEFAULT_BUF_SIZE = 4096;
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial1){
        super("Buffer full");
        this.partial = partial1;
    }
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    buf;
    rd;
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd1, size1 = 4096){
        if (size1 < 16) {
            size1 = MIN_BUF_SIZE;
        }
        this._reset(new Uint8Array(size1), rd1);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr1 = await this.rd.read(p);
                const nread = rr1 ?? 0;
                assert(nread >= 0, "negative read");
                return rr1;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copy(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                err.partial = p.subarray(0, bytesRead);
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            let { partial: partial2  } = err;
            assert(partial2 instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            if (!this.eof && partial2.byteLength > 0 && partial2[partial2.byteLength - 1] === CR) {
                assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial2 = partial2.subarray(0, partial2.byteLength - 1);
            }
            return {
                line: partial2,
                more: !this.eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.buf.subarray(this.r, this.r + i + 1);
                this.r += i + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                err.partial = slice;
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                err.partial = this.buf.subarray(this.r, this.w);
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer1, size2 = 4096){
        super();
        this.writer = writer1;
        if (size2 <= 0) {
            size2 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size2);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
function isProhibidedForTrailer(key) {
    const s = new Set([
        "transfer-encoding",
        "content-length",
        "trailer"
    ]);
    return s.has(key.toLowerCase());
}
async function readTrailers1(headers, r2) {
    const trailers = parseTrailer1(headers.get("trailer"));
    if (trailers == null) return;
    const trailerNames = [
        ...trailers.keys()
    ];
    const tp = new TextProtoReader(r2);
    const result = await tp.readMIMEHeader();
    if (result == null) {
        throw new Deno.errors.InvalidData("Missing trailer header.");
    }
    const undeclared = [
        ...result.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [k, v] of result){
        headers.append(k, v);
    }
    const missingTrailers = trailerNames.filter((k1)=>!result.has(k1)
    );
    if (missingTrailers.length > 0) {
        throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
    }
    headers.delete("trailer");
}
function parseTrailer1(field) {
    if (field == null) {
        return undefined;
    }
    const trailerNames = field.split(",").map((v)=>v.trim().toLowerCase()
    );
    if (trailerNames.length === 0) {
        throw new Deno.errors.InvalidData("Empty trailer header.");
    }
    const prohibited = trailerNames.filter((k)=>isProhibidedForTrailer(k)
    );
    if (prohibited.length > 0) {
        throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
    }
    return new Headers(trailerNames.map((key)=>[
            key,
            ""
        ]
    ));
}
async function writeChunkedBody(w, r2) {
    for await (const chunk of iter(r2)){
        if (chunk.byteLength <= 0) continue;
        const start = encoder3.encode(`${chunk.byteLength.toString(16)}\r\n`);
        const end = encoder3.encode("\r\n");
        await w.write(start);
        await w.write(chunk);
        await w.write(end);
        await w.flush();
    }
    const endChunk = encoder3.encode("0\r\n\r\n");
    await w.write(endChunk);
}
async function writeTrailers(w, headers, trailers) {
    const trailer = headers.get("trailer");
    if (trailer === null) {
        throw new TypeError("Missing trailer header.");
    }
    const transferEncoding = headers.get("transfer-encoding");
    if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
        throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
    }
    const writer1 = BufWriter.create(w);
    const trailerNames = trailer.split(",").map((s)=>s.trim().toLowerCase()
    );
    const prohibitedTrailers = trailerNames.filter((k)=>isProhibidedForTrailer(k)
    );
    if (prohibitedTrailers.length > 0) {
        throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
    }
    const undeclared = [
        ...trailers.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [key, value] of trailers){
        await writer1.write(encoder3.encode(`${key}: ${value}\r\n`));
    }
    await writer1.write(encoder3.encode("\r\n"));
    await writer1.flush();
}
async function writeResponse(w, r2) {
    const protoMajor = 1;
    const protoMinor = 1;
    const statusCode = r2.status || 200;
    const statusText = (r2.statusText ?? STATUS_TEXT.get(statusCode)) ?? null;
    const writer1 = BufWriter.create(w);
    if (statusText === null) {
        throw new Deno.errors.InvalidData("Empty statusText (explicitely pass an empty string if this was intentional)");
    }
    if (!r2.body) {
        r2.body = new Uint8Array();
    }
    if (typeof r2.body === "string") {
        r2.body = encoder3.encode(r2.body);
    }
    let out = `HTTP/${1}.${1} ${statusCode} ${statusText}\r\n`;
    const headers = r2.headers ?? new Headers();
    if (r2.body && !headers.get("content-length")) {
        if (r2.body instanceof Uint8Array) {
            out += `content-length: ${r2.body.byteLength}\r\n`;
        } else if (!headers.get("transfer-encoding")) {
            out += "transfer-encoding: chunked\r\n";
        }
    }
    for (const [key, value] of headers){
        out += `${key}: ${value}\r\n`;
    }
    out += `\r\n`;
    const header = encoder3.encode(out);
    const n = await writer1.write(header);
    assert(n === header.byteLength);
    if (r2.body instanceof Uint8Array) {
        const n1 = await writer1.write(r2.body);
        assert(n1 === r2.body.byteLength);
    } else if (headers.has("content-length")) {
        const contentLength = headers.get("content-length");
        assert(contentLength != null);
        const bodyLength = parseInt(contentLength);
        const n1 = await Deno.copy(r2.body, writer1);
        assert(n1 === bodyLength);
    } else {
        await writeChunkedBody(writer1, r2.body);
    }
    if (r2.trailers) {
        const t = await r2.trailers();
        await writeTrailers(writer1, headers, t);
    }
    await writer1.flush();
}
class ServerRequest {
    url;
    method;
    proto;
    protoMinor;
    protoMajor;
    headers;
    conn;
    r;
    w;
    #done = deferred();
    #contentLength = undefined;
    #body = undefined;
    #finalized = false;
    get done() {
        return this.#done.then((e)=>e
        );
    }
    get contentLength() {
        if (this.#contentLength === undefined) {
            const cl = this.headers.get("content-length");
            if (cl) {
                this.#contentLength = parseInt(cl);
                if (Number.isNaN(this.#contentLength)) {
                    this.#contentLength = null;
                }
            } else {
                this.#contentLength = null;
            }
        }
        return this.#contentLength;
    }
    get body() {
        if (!this.#body) {
            if (this.contentLength != null) {
                this.#body = bodyReader(this.contentLength, this.r);
            } else {
                const transferEncoding = this.headers.get("transfer-encoding");
                if (transferEncoding != null) {
                    const parts = transferEncoding.split(",").map((e)=>e.trim().toLowerCase()
                    );
                    assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                    this.#body = chunkedBodyReader(this.headers, this.r);
                } else {
                    this.#body = emptyReader();
                }
            }
        }
        return this.#body;
    }
    async respond(r) {
        let err;
        try {
            await writeResponse(this.w, r);
        } catch (e) {
            try {
                this.conn.close();
            } catch  {
            }
            err = e;
        }
        this.#done.resolve(err);
        if (err) {
            throw err;
        }
    }
    async finalize() {
        if (this.#finalized) return;
        const body = this.body;
        const buf = new Uint8Array(1024);
        while(await body.read(buf) !== null){
        }
        this.#finalized = true;
    }
}
class MuxAsyncIterator {
    iteratorCount = 0;
    yields = [];
    throws = [];
    signal = deferred();
    add(iterator) {
        ++this.iteratorCount;
        this.callIteratorNext(iterator);
    }
    async callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.iteratorCount;
            } else {
                this.yields.push({
                    iterator,
                    value
                });
            }
        } catch (e) {
            this.throws.push(e);
        }
        this.signal.resolve();
    }
    async *iterate() {
        while(this.iteratorCount > 0){
            await this.signal;
            for(let i = 0; i < this.yields.length; i++){
                const { iterator , value  } = this.yields[i];
                yield value;
                this.callIteratorNext(iterator);
            }
            if (this.throws.length) {
                for (const e of this.throws){
                    throw e;
                }
                this.throws.length = 0;
            }
            this.yields.length = 0;
            this.signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function parseHTTPVersion(vers) {
    switch(vers){
        case "HTTP/1.1":
            return [
                1,
                1
            ];
        case "HTTP/1.0":
            return [
                1,
                0
            ];
        default:
            {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > 1000000) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > 1000000) {
                    break;
                }
                return [
                    major,
                    minor
                ];
            }
    }
    throw new Error(`malformed HTTP version ${vers}`);
}
async function readRequest(conn, bufr) {
    const tp = new TextProtoReader(bufr);
    const firstLine = await tp.readLine();
    if (firstLine === null) return null;
    const headers = await tp.readMIMEHeader();
    if (headers === null) throw new Deno.errors.UnexpectedEof();
    const req = new ServerRequest();
    req.conn = conn;
    req.r = bufr;
    [req.method, req.url, req.proto] = firstLine.split(" ", 3);
    [req.protoMajor, req.protoMinor] = parseHTTPVersion(req.proto);
    req.headers = headers;
    fixLength1(req);
    return req;
}
class Server {
    listener;
    #closing = false;
    #connections = [];
    constructor(listener1){
        this.listener = listener1;
    }
    close() {
        this.#closing = true;
        this.listener.close();
        for (const conn of this.#connections){
            try {
                conn.close();
            } catch (e) {
                if (!(e instanceof Deno.errors.BadResource)) {
                    throw e;
                }
            }
        }
    }
    async *iterateHttpRequests(conn) {
        const reader = new BufReader(conn);
        const writer1 = new BufWriter(conn);
        while(!this.#closing){
            let request;
            try {
                request = await readRequest(conn, reader);
            } catch (error) {
                if (error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {
                    try {
                        await writeResponse(writer1, {
                            status: 400,
                            body: new TextEncoder().encode(`${error.message}\r\n\r\n`)
                        });
                    } catch  {
                    }
                }
                break;
            }
            if (request === null) {
                break;
            }
            request.w = writer1;
            yield request;
            const responseError = await request.done;
            if (responseError) {
                this.untrackConnection(request.conn);
                return;
            }
            try {
                await request.finalize();
            } catch  {
                break;
            }
        }
        this.untrackConnection(conn);
        try {
            conn.close();
        } catch  {
        }
    }
    trackConnection(conn) {
        this.#connections.push(conn);
    }
    untrackConnection(conn) {
        const index = this.#connections.indexOf(conn);
        if (index !== -1) {
            this.#connections.splice(index, 1);
        }
    }
    async *acceptConnAndIterateHttpRequests(mux) {
        if (this.#closing) return;
        let conn;
        try {
            conn = await this.listener.accept();
        } catch (error) {
            if (error instanceof Deno.errors.BadResource || error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof || error instanceof Deno.errors.ConnectionReset) {
                return mux.add(this.acceptConnAndIterateHttpRequests(mux));
            }
            throw error;
        }
        this.trackConnection(conn);
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        yield* this.iterateHttpRequests(conn);
    }
    [Symbol.asyncIterator]() {
        const mux = new MuxAsyncIterator();
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        return mux.iterate();
    }
}
function _parseAddrFromStr(addr) {
    let url;
    try {
        const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
        url = new URL(`http://${host}`);
    } catch  {
        throw new TypeError("Invalid address.");
    }
    if (url.username || url.password || url.pathname != "/" || url.search || url.hash) {
        throw new TypeError("Invalid address.");
    }
    return {
        hostname: url.hostname,
        port: url.port === "" ? 80 : Number(url.port)
    };
}
function serve(addr) {
    if (typeof addr === "string") {
        addr = _parseAddrFromStr(addr);
    }
    const listener1 = Deno.listen(addr);
    return new Server(listener1);
}
function serveTLS(options) {
    const tlsOptions = {
        ...options,
        transport: "tcp"
    };
    const listener1 = Deno.listenTls(tlsOptions);
    return new Server(listener1);
}
function fixLength1(req) {
    const contentLength = req.headers.get("Content-Length");
    if (contentLength) {
        const arrClen = contentLength.split(",");
        if (arrClen.length > 1) {
            const distinct = [
                ...new Set(arrClen.map((e)=>e.trim()
                ))
            ];
            if (distinct.length > 1) {
                throw Error("cannot contain multiple Content-Length headers");
            } else {
                req.headers.set("Content-Length", distinct[0]);
            }
        }
        const c = req.headers.get("Content-Length");
        if (req.method === "HEAD" && c && c !== "0") {
            throw Error("http: method cannot contain a Content-Length");
        }
        if (c && req.headers.has("transfer-encoding")) {
            throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
        }
    }
}
class BufWriterSync extends AbstractBufBase {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer2, size3 = 4096){
        super();
        this.writer = writer2;
        if (size3 <= 0) {
            size3 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size3);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
function validateIntegerRange(value, name, min = -2147483648, max = 2147483647) {
    if (!Number.isInteger(value)) {
        throw new Error(`${name} must be 'an integer' but was ${value}`);
    }
    if (value < min || value > max) {
        throw new Error(`${name} must be >= ${min} && <= ${max}. Value was ${value}`);
    }
}
class Tokenizer {
    rules;
    constructor(rules2 = []){
        this.rules = rules2;
    }
    addRule(test, fn) {
        this.rules.push({
            test,
            fn
        });
        return this;
    }
    tokenize(string, receiver = (token)=>token
    ) {
        function* generator(rules1) {
            let index = 0;
            for (const rule of rules1){
                const result = rule.test(string);
                if (result) {
                    const { value , length  } = result;
                    index += length;
                    string = string.slice(length);
                    const token = {
                        ...rule.fn(value),
                        index
                    };
                    yield receiver(token);
                    yield* generator(rules1);
                }
            }
        }
        const tokenGenerator = generator(this.rules);
        const tokens = [];
        for (const token of tokenGenerator){
            tokens.push(token);
        }
        if (string.length) {
            throw new Error(`parser error: string not fully parsed! ${string.slice(0, 25)}`);
        }
        return tokens;
    }
}
function digits(value, count = 2) {
    return String(value).padStart(count, "0");
}
function createLiteralTestFunction(value) {
    return (string)=>{
        return string.startsWith(value) ? {
            value,
            length: value.length
        } : undefined;
    };
}
function createMatchTestFunction(match) {
    return (string)=>{
        const result = match.exec(string);
        if (result) return {
            value: result,
            length: result[0].length
        };
    };
}
const defaultRules = [
    {
        test: createLiteralTestFunction("yyyy"),
        fn: ()=>({
                type: "year",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("yy"),
        fn: ()=>({
                type: "year",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("MM"),
        fn: ()=>({
                type: "month",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("M"),
        fn: ()=>({
                type: "month",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("dd"),
        fn: ()=>({
                type: "day",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("d"),
        fn: ()=>({
                type: "day",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("HH"),
        fn: ()=>({
                type: "hour",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("H"),
        fn: ()=>({
                type: "hour",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("hh"),
        fn: ()=>({
                type: "hour",
                value: "2-digit",
                hour12: true
            })
    },
    {
        test: createLiteralTestFunction("h"),
        fn: ()=>({
                type: "hour",
                value: "numeric",
                hour12: true
            })
    },
    {
        test: createLiteralTestFunction("mm"),
        fn: ()=>({
                type: "minute",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("m"),
        fn: ()=>({
                type: "minute",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("ss"),
        fn: ()=>({
                type: "second",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("s"),
        fn: ()=>({
                type: "second",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("SSS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 3
            })
    },
    {
        test: createLiteralTestFunction("SS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 2
            })
    },
    {
        test: createLiteralTestFunction("S"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 1
            })
    },
    {
        test: createLiteralTestFunction("a"),
        fn: (value)=>({
                type: "dayPeriod",
                value: value
            })
    },
    {
        test: createMatchTestFunction(/^(')(?<value>\\.|[^\']*)\1/),
        fn: (match)=>({
                type: "literal",
                value: match.groups.value
            })
    },
    {
        test: createMatchTestFunction(/^.+?\s*/),
        fn: (match)=>({
                type: "literal",
                value: match[0]
            })
    }, 
];
class DateTimeFormatter {
    #format;
    constructor(formatString, rules1 = defaultRules){
        const tokenizer = new Tokenizer(rules1);
        this.#format = tokenizer.tokenize(formatString, ({ type: type1 , value , hour12  })=>{
            const result = {
                type: type1,
                value
            };
            if (hour12) result.hour12 = hour12;
            return result;
        });
    }
    format(date, options = {
    }) {
        let string = "";
        const utc = options.timeZone === "UTC";
        for (const token of this.#format){
            const type1 = token.type;
            switch(type1){
                case "year":
                    {
                        const value = utc ? date.getUTCFullYear() : date.getFullYear();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2).slice(-2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "month":
                    {
                        const value = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        const value = utc ? date.getUTCDate() : date.getDate();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        let value = utc ? date.getUTCHours() : date.getHours();
                        value -= token.hour12 && date.getHours() > 12 ? 12 : 0;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        const value = utc ? date.getUTCMinutes() : date.getMinutes();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        const value = utc ? date.getUTCSeconds() : date.getSeconds();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
                        string += digits(value, Number(token.value));
                        break;
                    }
                case "timeZoneName":
                    {
                        break;
                    }
                case "dayPeriod":
                    {
                        string += token.value ? date.getHours() >= 12 ? "PM" : "AM" : "";
                        break;
                    }
                case "literal":
                    {
                        string += token.value;
                        break;
                    }
                default:
                    throw Error(`FormatterError: { ${token.type} ${token.value} }`);
            }
        }
        return string;
    }
    parseToParts(string) {
        const parts = [];
        for (const token of this.#format){
            const type1 = token.type;
            let value = "";
            switch(token.type){
                case "year":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,4}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                        }
                        break;
                    }
                case "month":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            case "narrow":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "short":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "long":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    if (token.hour12 && parseInt(value) > 12) {
                                        console.error(`Trying to parse hour greater than 12. Use 'H' instead of 'h'.`);
                                    }
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    if (token.hour12 && parseInt(value) > 12) {
                                        console.error(`Trying to parse hour greater than 12. Use 'HH' instead of 'hh'.`);
                                    }
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        value = new RegExp(`^\\d{${token.value}}`).exec(string)?.[0];
                        break;
                    }
                case "timeZoneName":
                    {
                        value = token.value;
                        break;
                    }
                case "dayPeriod":
                    {
                        value = /^(A|P)M/.exec(string)?.[0];
                        break;
                    }
                case "literal":
                    {
                        if (!string.startsWith(token.value)) {
                            throw Error(`Literal "${token.value}" not found "${string.slice(0, 25)}"`);
                        }
                        value = token.value;
                        break;
                    }
                default:
                    throw Error(`${token.type} ${token.value}`);
            }
            if (!value) {
                throw Error(`value not valid for token { ${type1} ${value} } ${string.slice(0, 25)}`);
            }
            parts.push({
                type: type1,
                value
            });
            string = string.slice(value.length);
        }
        if (string.length) {
            throw Error(`datetime string was not fully parsed! ${string.slice(0, 25)}`);
        }
        return parts;
    }
    sortDateTimeFormatPart(parts) {
        let result = [];
        const typeArray = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "fractionalSecond", 
        ];
        for (const type1 of typeArray){
            const current = parts.findIndex((el)=>el.type === type1
            );
            if (current !== -1) {
                result = result.concat(parts.splice(current, 1));
            }
        }
        result = result.concat(parts);
        return result;
    }
    partsToDate(parts) {
        const date = new Date();
        const utc = parts.find((part)=>part.type === "timeZoneName" && part.value === "UTC"
        );
        utc ? date.setUTCHours(0, 0, 0, 0) : date.setHours(0, 0, 0, 0);
        for (const part of parts){
            switch(part.type){
                case "year":
                    {
                        const value = Number(part.value.padStart(4, "20"));
                        utc ? date.setUTCFullYear(value) : date.setFullYear(value);
                        break;
                    }
                case "month":
                    {
                        const value = Number(part.value) - 1;
                        utc ? date.setUTCMonth(value) : date.setMonth(value);
                        break;
                    }
                case "day":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCDate(value) : date.setDate(value);
                        break;
                    }
                case "hour":
                    {
                        let value = Number(part.value);
                        const dayPeriod = parts.find((part1)=>part1.type === "dayPeriod"
                        );
                        if (dayPeriod?.value === "PM") value += 12;
                        utc ? date.setUTCHours(value) : date.setHours(value);
                        break;
                    }
                case "minute":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCMinutes(value) : date.setMinutes(value);
                        break;
                    }
                case "second":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCSeconds(value) : date.setSeconds(value);
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCMilliseconds(value) : date.setMilliseconds(value);
                        break;
                    }
            }
        }
        return date;
    }
    parse(string) {
        const parts = this.parseToParts(string);
        const sortParts = this.sortDateTimeFormatPart(parts);
        return this.partsToDate(sortParts);
    }
}
var Day;
(function(Day1) {
    Day1[Day1["Sun"] = 0] = "Sun";
    Day1[Day1["Mon"] = 1] = "Mon";
    Day1[Day1["Tue"] = 2] = "Tue";
    Day1[Day1["Wed"] = 3] = "Wed";
    Day1[Day1["Thu"] = 4] = "Thu";
    Day1[Day1["Fri"] = 5] = "Fri";
    Day1[Day1["Sat"] = 6] = "Sat";
})(Day || (Day = {
}));
function toIMF(date) {
    function dtPad(v, lPad = 2) {
        return v.padStart(lPad, "0");
    }
    const d = dtPad(date.getUTCDate().toString());
    const h = dtPad(date.getUTCHours().toString());
    const min = dtPad(date.getUTCMinutes().toString());
    const s = dtPad(date.getUTCSeconds().toString());
    const y = date.getUTCFullYear();
    const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ];
    const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec", 
    ];
    return `${days[date.getUTCDay()]}, ${d} ${months[date.getUTCMonth()]} ${y} ${h}:${min}:${s} GMT`;
}
const FIELD_CONTENT_REGEXP = /^(?=[\x20-\x7E]*$)[^()@<>,;:\\"\[\]?={}\s]+$/;
function toString(cookie) {
    if (!cookie.name) {
        return "";
    }
    const out = [];
    validateName(cookie.name);
    validateValue(cookie.name, cookie.value);
    out.push(`${cookie.name}=${cookie.value}`);
    if (cookie.name.startsWith("__Secure")) {
        cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host")) {
        cookie.path = "/";
        cookie.secure = true;
        delete cookie.domain;
    }
    if (cookie.secure) {
        out.push("Secure");
    }
    if (cookie.httpOnly) {
        out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number" && Number.isInteger(cookie.maxAge)) {
        assert(cookie.maxAge > 0, "Max-Age must be an integer superior to 0");
        out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
        out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
    }
    if (cookie.path) {
        validatePath(cookie.path);
        out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires) {
        const dateString = toIMF(cookie.expires);
        out.push(`Expires=${dateString}`);
    }
    if (cookie.unparsed) {
        out.push(cookie.unparsed.join("; "));
    }
    return out.join("; ");
}
function validateName(name) {
    if (name && !FIELD_CONTENT_REGEXP.test(name)) {
        throw new TypeError(`Invalid cookie name: "${name}".`);
    }
}
function validatePath(path) {
    if (path == null) {
        return;
    }
    for(let i = 0; i < path.length; i++){
        const c = path.charAt(i);
        if (c < String.fromCharCode(32) || c > String.fromCharCode(126) || c == ";") {
            throw new Error(path + ": Invalid cookie path char '" + c + "'");
        }
    }
}
function validateValue(name, value) {
    if (value == null || name == null) return;
    for(let i = 0; i < value.length; i++){
        const c = value.charAt(i);
        if (c < String.fromCharCode(33) || c == String.fromCharCode(34) || c == String.fromCharCode(44) || c == String.fromCharCode(59) || c == String.fromCharCode(92) || c == String.fromCharCode(127)) {
            throw new Error("RFC2616 cookie '" + name + "' cannot have '" + c + "' as value");
        }
        if (c > String.fromCharCode(128)) {
            throw new Error("RFC2616 cookie '" + name + "' can only have US-ASCII chars as value" + c.charCodeAt(0).toString(16));
        }
    }
}
function setCookie(res, cookie) {
    if (!res.headers) {
        res.headers = new Headers();
    }
    const v = toString(cookie);
    if (v) {
        res.headers.append("Set-Cookie", v);
    }
}
const osType = (()=>{
    if (globalThis.Deno != null) {
        return Deno.build.os;
    }
    const navigator = globalThis.navigator;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator1(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code)) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize12(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize12(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse14(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = function() {
    return {
        sep: sep,
        delimiter: delimiter,
        resolve: resolve,
        normalize: normalize12,
        isAbsolute: isAbsolute,
        join: join,
        relative: relative,
        toNamespacedPath: toNamespacedPath,
        dirname: dirname,
        basename: basename,
        extname: extname,
        format: format,
        parse: parse14,
        fromFileUrl: fromFileUrl,
        toFileUrl: toFileUrl
    };
}();
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute1 = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute1, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute1) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute1) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute2 = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = function() {
    return {
        sep: sep1,
        delimiter: delimiter1,
        resolve: resolve1,
        normalize: normalize1,
        isAbsolute: isAbsolute1,
        join: join1,
        relative: relative1,
        toNamespacedPath: toNamespacedPath1,
        dirname: dirname1,
        basename: basename1,
        extname: extname1,
        format: format1,
        parse: parse1,
        fromFileUrl: fromFileUrl1,
        toFileUrl: toFileUrl1
    };
}();
const path4 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join2 , normalize: normalize2 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path4;
const setImmediate = (cb, ...args)=>globalThis.setTimeout(cb, 0, ...args)
;
const hexTable = new Array(256);
for(let i7 = 0; i7 < 256; ++i7){
    hexTable[i7] = "%" + ((i7 < 16 ? "0" : "") + i7.toString(16)).toUpperCase();
}
function parse3(str1, sep3 = "&", eq = "=", { decodeURIComponent =unescape1 , maxKeys =1000  } = {
}) {
    const entries = str1.split(sep3).map((entry)=>entry.split(eq).map(decodeURIComponent)
    );
    const __final = {
    };
    let i1 = 0;
    while(true){
        if (Object.keys(__final).length === maxKeys && !!maxKeys || !entries[i1]) {
            break;
        }
        const [key, val] = entries[i1];
        if (__final[key]) {
            if (Array.isArray(__final[key])) {
                __final[key].push(val);
            } else {
                __final[key] = [
                    __final[key],
                    val
                ];
            }
        } else {
            __final[key] = val;
        }
        i1++;
    }
    return __final;
}
const unescape1 = decodeURIComponent;
const classRegExp = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class NodeErrorAbstraction extends Error {
    code;
    constructor(name12, code6, message2){
        super(message2);
        this.code = code6;
        this.name = name12;
        this.stack = this.stack && `${name12} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code1, message3){
        super(Error.prototype.name, code1, message3);
    }
}
class NodeSyntaxError extends NodeErrorAbstraction {
    constructor(code2, message4){
        super(SyntaxError.prototype.name, code2, message4);
        Object.setPrototypeOf(this, SyntaxError.prototype);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code3, message5){
        super(RangeError.prototype.name, code3, message5);
        Object.setPrototypeOf(this, RangeError.prototype);
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code4, message6){
        super(TypeError.prototype.name, code4, message6);
        Object.setPrototypeOf(this, TypeError.prototype);
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code5, message7){
        super(URIError.prototype.name, code5, message7);
        Object.setPrototypeOf(this, URIError.prototype);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name1, expected, actual1){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        let msg3 = "The ";
        if (name1.endsWith(" argument")) {
            msg3 += `${name1} `;
        } else {
            const type1 = name1.includes(".") ? "property" : "argument";
            msg3 += `"${name1}" ${type1} `;
        }
        msg3 += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value6 of expected){
            if (kTypes.includes(value6)) {
                types3.push(value6.toLocaleLowerCase());
            } else if (classRegExp.test(value6)) {
                instances.push(value6);
            } else {
                other.push(value6);
            }
        }
        if (instances.length > 0) {
            const pos = types3.indexOf("object");
            if (pos !== -1) {
                types3.splice(pos, 1);
                instances.push("Object");
            }
        }
        if (types3.length > 0) {
            if (types3.length > 2) {
                const last = types3.pop();
                msg3 += `one of type ${types3.join(", ")}, or ${last}`;
            } else if (types3.length === 2) {
                msg3 += `one of type ${types3[0]} or ${types3[1]}`;
            } else {
                msg3 += `of type ${types3[0]}`;
            }
            if (instances.length > 0 || other.length > 0) {
                msg3 += " or ";
            }
        }
        if (instances.length > 0) {
            if (instances.length > 2) {
                const last = instances.pop();
                msg3 += `an instance of ${instances.join(", ")}, or ${last}`;
            } else {
                msg3 += `an instance of ${instances[0]}`;
                if (instances.length === 2) {
                    msg3 += ` or ${instances[1]}`;
                }
            }
            if (other.length > 0) {
                msg3 += " or ";
            }
        }
        if (other.length > 0) {
            if (other.length > 2) {
                const last = other.pop();
                msg3 += `one of ${other.join(", ")}, or ${last}`;
            } else if (other.length === 2) {
                msg3 += `one of ${other[0]} or ${other[1]}`;
            } else {
                if (other[0].toLowerCase() !== other[0]) {
                    msg3 += "an ";
                }
                msg3 += `${other[0]}`;
            }
        }
        super("ERR_INVALID_ARG_TYPE", `${msg3}.${invalidArgTypeHelper(actual1)}`);
    }
}
const DEFAULT_INSPECT_OPTIONS = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: Infinity,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
inspect.defaultOptions = DEFAULT_INSPECT_OPTIONS;
inspect.custom = Deno.customInspect;
function inspect(object, ...opts) {
    if (typeof object === "string" && !object.includes("'")) {
        return `'${object}'`;
    }
    opts = {
        ...DEFAULT_INSPECT_OPTIONS,
        ...opts
    };
    return Deno.inspect(object, {
        depth: opts.depth,
        iterableLimit: opts.maxArrayLength,
        compact: !!opts.compact,
        sorted: !!opts.sorted,
        showProxy: !!opts.showProxy
    });
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name2, value1, reason1){
        super("ERR_INVALID_ARG_VALUE", `The argument '${name2}' ${reason1}. Received ${inspect(value1)}`);
    }
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str1, range, received1){
        super(`The value of "${str1}" is out of range. It must be ${range}. Received ${received1}`);
        const { name: name3  } = this;
        this.name = `${name3} [${this.code}]`;
        this.stack;
        this.name = name3;
    }
}
class ERR_AMBIGUOUS_ARGUMENT extends NodeTypeError {
    constructor(x, y){
        super("ERR_AMBIGUOUS_ARGUMENT", `The "${x}" argument is ambiguous. ${y}`);
    }
}
class ERR_ARG_NOT_ITERABLE extends NodeTypeError {
    constructor(x1){
        super("ERR_ARG_NOT_ITERABLE", `${x1} must be iterable`);
    }
}
class ERR_ASSERTION extends NodeError {
    constructor(x2){
        super("ERR_ASSERTION", `${x2}`);
    }
}
class ERR_ASYNC_CALLBACK extends NodeTypeError {
    constructor(x3){
        super("ERR_ASYNC_CALLBACK", `${x3} must be a function`);
    }
}
class ERR_ASYNC_TYPE extends NodeTypeError {
    constructor(x4){
        super("ERR_ASYNC_TYPE", `Invalid name for async "type": ${x4}`);
    }
}
class ERR_BROTLI_INVALID_PARAM extends NodeRangeError {
    constructor(x5){
        super("ERR_BROTLI_INVALID_PARAM", `${x5} is not a valid Brotli parameter`);
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name4){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name4 ? `"${name4}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_BUFFER_TOO_LARGE extends NodeRangeError {
    constructor(x6){
        super("ERR_BUFFER_TOO_LARGE", `Cannot create a Buffer larger than ${x6} bytes`);
    }
}
class ERR_CANNOT_WATCH_SIGINT extends NodeError {
    constructor(){
        super("ERR_CANNOT_WATCH_SIGINT", "Cannot watch for SIGINT signals");
    }
}
class ERR_CHILD_CLOSED_BEFORE_REPLY extends NodeError {
    constructor(){
        super("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    }
}
class ERR_CHILD_PROCESS_IPC_REQUIRED extends NodeError {
    constructor(x7){
        super("ERR_CHILD_PROCESS_IPC_REQUIRED", `Forked processes must have an IPC channel, missing value 'ipc' in ${x7}`);
    }
}
class ERR_CHILD_PROCESS_STDIO_MAXBUFFER extends NodeRangeError {
    constructor(x8){
        super("ERR_CHILD_PROCESS_STDIO_MAXBUFFER", `${x8} maxBuffer length exceeded`);
    }
}
class ERR_CONSOLE_WRITABLE_STREAM extends NodeTypeError {
    constructor(x9){
        super("ERR_CONSOLE_WRITABLE_STREAM", `Console expects a writable stream instance for ${x9}`);
    }
}
class ERR_CONTEXT_NOT_INITIALIZED extends NodeError {
    constructor(){
        super("ERR_CONTEXT_NOT_INITIALIZED", "context used is not initialized");
    }
}
class ERR_CPU_USAGE extends NodeError {
    constructor(x10){
        super("ERR_CPU_USAGE", `Unable to obtain cpu usage ${x10}`);
    }
}
class ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED", "Custom engines not supported by this OpenSSL");
    }
}
class ERR_CRYPTO_ECDH_INVALID_FORMAT extends NodeTypeError {
    constructor(x11){
        super("ERR_CRYPTO_ECDH_INVALID_FORMAT", `Invalid ECDH format: ${x11}`);
    }
}
class ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY extends NodeError {
    constructor(){
        super("ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY", "Public key is not valid for specified curve");
    }
}
class ERR_CRYPTO_ENGINE_UNKNOWN extends NodeError {
    constructor(x12){
        super("ERR_CRYPTO_ENGINE_UNKNOWN", `Engine "${x12}" was not found`);
    }
}
class ERR_CRYPTO_FIPS_FORCED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
    }
}
class ERR_CRYPTO_FIPS_UNAVAILABLE extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_UNAVAILABLE", "Cannot set FIPS mode in a non-FIPS build.");
    }
}
class ERR_CRYPTO_HASH_FINALIZED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_HASH_FINALIZED", "Digest already called");
    }
}
class ERR_CRYPTO_HASH_UPDATE_FAILED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_HASH_UPDATE_FAILED", "Hash update failed");
    }
}
class ERR_CRYPTO_INCOMPATIBLE_KEY extends NodeError {
    constructor(x13, y1){
        super("ERR_CRYPTO_INCOMPATIBLE_KEY", `Incompatible ${x13}: ${y1}`);
    }
}
class ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS extends NodeError {
    constructor(x14, y2){
        super("ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS", `The selected key encoding ${x14} ${y2}.`);
    }
}
class ERR_CRYPTO_INVALID_DIGEST extends NodeTypeError {
    constructor(x15){
        super("ERR_CRYPTO_INVALID_DIGEST", `Invalid digest: ${x15}`);
    }
}
class ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE extends NodeTypeError {
    constructor(x16, y3){
        super("ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE", `Invalid key object type ${x16}, expected ${y3}.`);
    }
}
class ERR_CRYPTO_INVALID_STATE extends NodeError {
    constructor(x17){
        super("ERR_CRYPTO_INVALID_STATE", `Invalid state for operation ${x17}`);
    }
}
class ERR_CRYPTO_PBKDF2_ERROR extends NodeError {
    constructor(){
        super("ERR_CRYPTO_PBKDF2_ERROR", "PBKDF2 error");
    }
}
class ERR_CRYPTO_SCRYPT_INVALID_PARAMETER extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SCRYPT_INVALID_PARAMETER", "Invalid scrypt parameter");
    }
}
class ERR_CRYPTO_SCRYPT_NOT_SUPPORTED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SCRYPT_NOT_SUPPORTED", "Scrypt algorithm not supported");
    }
}
class ERR_CRYPTO_SIGN_KEY_REQUIRED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SIGN_KEY_REQUIRED", "No key provided to sign");
    }
}
class ERR_DIR_CLOSED extends NodeError {
    constructor(){
        super("ERR_DIR_CLOSED", "Directory handle was closed");
    }
}
class ERR_DIR_CONCURRENT_OPERATION extends NodeError {
    constructor(){
        super("ERR_DIR_CONCURRENT_OPERATION", "Cannot do synchronous work on directory handle with concurrent asynchronous operations");
    }
}
class ERR_DNS_SET_SERVERS_FAILED extends NodeError {
    constructor(x18, y4){
        super("ERR_DNS_SET_SERVERS_FAILED", `c-ares failed to set servers: "${x18}" [${y4}]`);
    }
}
class ERR_DOMAIN_CALLBACK_NOT_AVAILABLE extends NodeError {
    constructor(){
        super("ERR_DOMAIN_CALLBACK_NOT_AVAILABLE", "A callback was registered through " + "process.setUncaughtExceptionCaptureCallback(), which is mutually " + "exclusive with using the `domain` module");
    }
}
class ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE extends NodeError {
    constructor(){
        super("ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE", "The `domain` module is in use, which is mutually exclusive with calling " + "process.setUncaughtExceptionCaptureCallback()");
    }
}
class ERR_ENCODING_INVALID_ENCODED_DATA extends NodeErrorAbstraction {
    errno;
    constructor(encoding, ret){
        super(TypeError.prototype.name, "ERR_ENCODING_INVALID_ENCODED_DATA", `The encoded data was not valid for encoding ${encoding}`);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.errno = ret;
    }
}
const windows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const darwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const linux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const { os: os1  } = Deno.build;
const errorMap = new Map(os1 === "windows" ? windows : os1 === "darwin" ? darwin : os1 === "linux" ? linux : unreachable());
class ERR_ENCODING_NOT_SUPPORTED extends NodeRangeError {
    constructor(x19){
        super("ERR_ENCODING_NOT_SUPPORTED", `The "${x19}" encoding is not supported`);
    }
}
class ERR_EVAL_ESM_CANNOT_PRINT extends NodeError {
    constructor(){
        super("ERR_EVAL_ESM_CANNOT_PRINT", `--print cannot be used with ESM input`);
    }
}
class ERR_EVENT_RECURSION extends NodeError {
    constructor(x20){
        super("ERR_EVENT_RECURSION", `The event "${x20}" is already being dispatched`);
    }
}
class ERR_FEATURE_UNAVAILABLE_ON_PLATFORM extends NodeTypeError {
    constructor(x21){
        super("ERR_FEATURE_UNAVAILABLE_ON_PLATFORM", `The feature ${x21} is unavailable on the current platform, which is being used to run Node.js`);
    }
}
class ERR_FS_FILE_TOO_LARGE extends NodeRangeError {
    constructor(x22){
        super("ERR_FS_FILE_TOO_LARGE", `File size (${x22}) is greater than 2 GB`);
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x23){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x23}"`);
    }
}
class ERR_HTTP2_ALTSVC_INVALID_ORIGIN extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ALTSVC_INVALID_ORIGIN", `HTTP/2 ALTSVC frames require a valid origin`);
    }
}
class ERR_HTTP2_ALTSVC_LENGTH extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ALTSVC_LENGTH", `HTTP/2 ALTSVC frames are limited to 16382 bytes`);
    }
}
class ERR_HTTP2_CONNECT_AUTHORITY extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_AUTHORITY", `:authority header is required for CONNECT requests`);
    }
}
class ERR_HTTP2_CONNECT_PATH extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_PATH", `The :path header is forbidden for CONNECT requests`);
    }
}
class ERR_HTTP2_CONNECT_SCHEME extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_SCHEME", `The :scheme header is forbidden for CONNECT requests`);
    }
}
class ERR_HTTP2_GOAWAY_SESSION extends NodeError {
    constructor(){
        super("ERR_HTTP2_GOAWAY_SESSION", `New streams cannot be created after receiving a GOAWAY`);
    }
}
class ERR_HTTP2_HEADERS_AFTER_RESPOND extends NodeError {
    constructor(){
        super("ERR_HTTP2_HEADERS_AFTER_RESPOND", `Cannot specify additional headers after response initiated`);
    }
}
class ERR_HTTP2_HEADERS_SENT extends NodeError {
    constructor(){
        super("ERR_HTTP2_HEADERS_SENT", `Response has already been initiated.`);
    }
}
class ERR_HTTP2_HEADER_SINGLE_VALUE extends NodeTypeError {
    constructor(x24){
        super("ERR_HTTP2_HEADER_SINGLE_VALUE", `Header field "${x24}" must only have a single value`);
    }
}
class ERR_HTTP2_INFO_STATUS_NOT_ALLOWED extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_INFO_STATUS_NOT_ALLOWED", `Informational status codes cannot be used`);
    }
}
class ERR_HTTP2_INVALID_CONNECTION_HEADERS extends NodeTypeError {
    constructor(x25){
        super("ERR_HTTP2_INVALID_CONNECTION_HEADERS", `HTTP/1 Connection specific headers are forbidden: "${x25}"`);
    }
}
class ERR_HTTP2_INVALID_HEADER_VALUE extends NodeTypeError {
    constructor(x26, y5){
        super("ERR_HTTP2_INVALID_HEADER_VALUE", `Invalid value "${x26}" for header "${y5}"`);
    }
}
class ERR_HTTP2_INVALID_INFO_STATUS extends NodeRangeError {
    constructor(x27){
        super("ERR_HTTP2_INVALID_INFO_STATUS", `Invalid informational status code: ${x27}`);
    }
}
class ERR_HTTP2_INVALID_ORIGIN extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_INVALID_ORIGIN", `HTTP/2 ORIGIN frames require a valid origin`);
    }
}
class ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH", `Packed settings length must be a multiple of six`);
    }
}
class ERR_HTTP2_INVALID_PSEUDOHEADER extends NodeTypeError {
    constructor(x28){
        super("ERR_HTTP2_INVALID_PSEUDOHEADER", `"${x28}" is an invalid pseudoheader or is used incorrectly`);
    }
}
class ERR_HTTP2_INVALID_SESSION extends NodeError {
    constructor(){
        super("ERR_HTTP2_INVALID_SESSION", `The session has been destroyed`);
    }
}
class ERR_HTTP2_INVALID_STREAM extends NodeError {
    constructor(){
        super("ERR_HTTP2_INVALID_STREAM", `The stream has been destroyed`);
    }
}
class ERR_HTTP2_MAX_PENDING_SETTINGS_ACK extends NodeError {
    constructor(){
        super("ERR_HTTP2_MAX_PENDING_SETTINGS_ACK", `Maximum number of pending settings acknowledgements`);
    }
}
class ERR_HTTP2_NESTED_PUSH extends NodeError {
    constructor(){
        super("ERR_HTTP2_NESTED_PUSH", `A push stream cannot initiate another push stream.`);
    }
}
class ERR_HTTP2_NO_SOCKET_MANIPULATION extends NodeError {
    constructor(){
        super("ERR_HTTP2_NO_SOCKET_MANIPULATION", `HTTP/2 sockets should not be directly manipulated (e.g. read and written)`);
    }
}
class ERR_HTTP2_ORIGIN_LENGTH extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ORIGIN_LENGTH", `HTTP/2 ORIGIN frames are limited to 16382 bytes`);
    }
}
class ERR_HTTP2_OUT_OF_STREAMS extends NodeError {
    constructor(){
        super("ERR_HTTP2_OUT_OF_STREAMS", `No stream ID is available because maximum stream ID has been reached`);
    }
}
class ERR_HTTP2_PAYLOAD_FORBIDDEN extends NodeError {
    constructor(x29){
        super("ERR_HTTP2_PAYLOAD_FORBIDDEN", `Responses with ${x29} status must not have a payload`);
    }
}
class ERR_HTTP2_PING_CANCEL extends NodeError {
    constructor(){
        super("ERR_HTTP2_PING_CANCEL", `HTTP2 ping cancelled`);
    }
}
class ERR_HTTP2_PING_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_PING_LENGTH", `HTTP2 ping payload must be 8 bytes`);
    }
}
class ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED", `Cannot set HTTP/2 pseudo-headers`);
    }
}
class ERR_HTTP2_PUSH_DISABLED extends NodeError {
    constructor(){
        super("ERR_HTTP2_PUSH_DISABLED", `HTTP/2 client has disabled push streams`);
    }
}
class ERR_HTTP2_SEND_FILE extends NodeError {
    constructor(){
        super("ERR_HTTP2_SEND_FILE", `Directories cannot be sent`);
    }
}
class ERR_HTTP2_SEND_FILE_NOSEEK extends NodeError {
    constructor(){
        super("ERR_HTTP2_SEND_FILE_NOSEEK", `Offset or length can only be specified for regular files`);
    }
}
class ERR_HTTP2_SESSION_ERROR extends NodeError {
    constructor(x30){
        super("ERR_HTTP2_SESSION_ERROR", `Session closed with error code ${x30}`);
    }
}
class ERR_HTTP2_SETTINGS_CANCEL extends NodeError {
    constructor(){
        super("ERR_HTTP2_SETTINGS_CANCEL", `HTTP2 session settings canceled`);
    }
}
class ERR_HTTP2_SOCKET_BOUND extends NodeError {
    constructor(){
        super("ERR_HTTP2_SOCKET_BOUND", `The socket is already bound to an Http2Session`);
    }
}
class ERR_HTTP2_SOCKET_UNBOUND extends NodeError {
    constructor(){
        super("ERR_HTTP2_SOCKET_UNBOUND", `The socket has been disconnected from the Http2Session`);
    }
}
class ERR_HTTP2_STATUS_101 extends NodeError {
    constructor(){
        super("ERR_HTTP2_STATUS_101", `HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2`);
    }
}
class ERR_HTTP2_STATUS_INVALID extends NodeRangeError {
    constructor(x31){
        super("ERR_HTTP2_STATUS_INVALID", `Invalid status code: ${x31}`);
    }
}
class ERR_HTTP2_STREAM_ERROR extends NodeError {
    constructor(x32){
        super("ERR_HTTP2_STREAM_ERROR", `Stream closed with error code ${x32}`);
    }
}
class ERR_HTTP2_STREAM_SELF_DEPENDENCY extends NodeError {
    constructor(){
        super("ERR_HTTP2_STREAM_SELF_DEPENDENCY", `A stream cannot depend on itself`);
    }
}
class ERR_HTTP2_TRAILERS_ALREADY_SENT extends NodeError {
    constructor(){
        super("ERR_HTTP2_TRAILERS_ALREADY_SENT", `Trailing headers have already been sent`);
    }
}
class ERR_HTTP2_TRAILERS_NOT_READY extends NodeError {
    constructor(){
        super("ERR_HTTP2_TRAILERS_NOT_READY", `Trailing headers cannot be sent until after the wantTrailers event is emitted`);
    }
}
class ERR_HTTP2_UNSUPPORTED_PROTOCOL extends NodeError {
    constructor(x33){
        super("ERR_HTTP2_UNSUPPORTED_PROTOCOL", `protocol "${x33}" is unsupported.`);
    }
}
class ERR_HTTP_HEADERS_SENT extends NodeError {
    constructor(x34){
        super("ERR_HTTP_HEADERS_SENT", `Cannot ${x34} headers after they are sent to the client`);
    }
}
class ERR_HTTP_INVALID_HEADER_VALUE extends NodeTypeError {
    constructor(x35, y6){
        super("ERR_HTTP_INVALID_HEADER_VALUE", `Invalid value "${x35}" for header "${y6}"`);
    }
}
class ERR_HTTP_INVALID_STATUS_CODE extends NodeRangeError {
    constructor(x36){
        super("ERR_HTTP_INVALID_STATUS_CODE", `Invalid status code: ${x36}`);
    }
}
class ERR_HTTP_SOCKET_ENCODING extends NodeError {
    constructor(){
        super("ERR_HTTP_SOCKET_ENCODING", `Changing the socket encoding is not allowed per RFC7230 Section 3.`);
    }
}
class ERR_HTTP_TRAILER_INVALID extends NodeError {
    constructor(){
        super("ERR_HTTP_TRAILER_INVALID", `Trailers are invalid with this transfer encoding`);
    }
}
class ERR_INCOMPATIBLE_OPTION_PAIR extends NodeTypeError {
    constructor(x37, y7){
        super("ERR_INCOMPATIBLE_OPTION_PAIR", `Option "${x37}" cannot be used in combination with option "${y7}"`);
    }
}
class ERR_INPUT_TYPE_NOT_ALLOWED extends NodeError {
    constructor(){
        super("ERR_INPUT_TYPE_NOT_ALLOWED", `--input-type can only be used with string input via --eval, --print, or STDIN`);
    }
}
class ERR_INSPECTOR_ALREADY_ACTIVATED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_ALREADY_ACTIVATED", `Inspector is already activated. Close it with inspector.close() before activating it again.`);
    }
}
class ERR_INSPECTOR_ALREADY_CONNECTED extends NodeError {
    constructor(x38){
        super("ERR_INSPECTOR_ALREADY_CONNECTED", `${x38} is already connected`);
    }
}
class ERR_INSPECTOR_CLOSED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_CLOSED", `Session was closed`);
    }
}
class ERR_INSPECTOR_COMMAND extends NodeError {
    constructor(x39, y8){
        super("ERR_INSPECTOR_COMMAND", `Inspector error ${x39}: ${y8}`);
    }
}
class ERR_INSPECTOR_NOT_ACTIVE extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_ACTIVE", `Inspector is not active`);
    }
}
class ERR_INSPECTOR_NOT_AVAILABLE extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_AVAILABLE", `Inspector is not available`);
    }
}
class ERR_INSPECTOR_NOT_CONNECTED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_CONNECTED", `Session is not connected`);
    }
}
class ERR_INSPECTOR_NOT_WORKER extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_WORKER", `Current thread is not a worker`);
    }
}
class ERR_INVALID_ASYNC_ID extends NodeRangeError {
    constructor(x40, y9){
        super("ERR_INVALID_ASYNC_ID", `Invalid ${x40} value: ${y9}`);
    }
}
class ERR_INVALID_BUFFER_SIZE extends NodeRangeError {
    constructor(x41){
        super("ERR_INVALID_BUFFER_SIZE", `Buffer size must be a multiple of ${x41}`);
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${JSON.stringify(object)}`);
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_INVALID_FD extends NodeRangeError {
    constructor(x42){
        super("ERR_INVALID_FD", `"fd" must be a positive integer: ${x42}`);
    }
}
class ERR_INVALID_FD_TYPE extends NodeTypeError {
    constructor(x43){
        super("ERR_INVALID_FD_TYPE", `Unsupported fd type: ${x43}`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x44){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x44}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x45){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x45}`);
    }
}
class ERR_INVALID_HANDLE_TYPE extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_HANDLE_TYPE", `This handle type cannot be sent`);
    }
}
class ERR_INVALID_HTTP_TOKEN extends NodeTypeError {
    constructor(x46, y10){
        super("ERR_INVALID_HTTP_TOKEN", `${x46} must be a valid HTTP token ["${y10}"]`);
    }
}
class ERR_INVALID_IP_ADDRESS extends NodeTypeError {
    constructor(x47){
        super("ERR_INVALID_IP_ADDRESS", `Invalid IP address: ${x47}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x48){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x48}" is invalid for option "encoding"`);
    }
}
class ERR_INVALID_PERFORMANCE_MARK extends NodeError {
    constructor(x49){
        super("ERR_INVALID_PERFORMANCE_MARK", `The "${x49}" performance mark has not been set`);
    }
}
class ERR_INVALID_PROTOCOL extends NodeTypeError {
    constructor(x50, y11){
        super("ERR_INVALID_PROTOCOL", `Protocol "${x50}" not supported. Expected "${y11}"`);
    }
}
class ERR_INVALID_REPL_EVAL_CONFIG extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_REPL_EVAL_CONFIG", `Cannot specify both "breakEvalOnSigint" and "eval" for REPL`);
    }
}
class ERR_INVALID_REPL_INPUT extends NodeTypeError {
    constructor(x51){
        super("ERR_INVALID_REPL_INPUT", `${x51}`);
    }
}
class ERR_INVALID_SYNC_FORK_INPUT extends NodeTypeError {
    constructor(x52){
        super("ERR_INVALID_SYNC_FORK_INPUT", `Asynchronous forks do not support Buffer, TypedArray, DataView or string input: ${x52}`);
    }
}
class ERR_INVALID_THIS extends NodeTypeError {
    constructor(x53){
        super("ERR_INVALID_THIS", `Value of "this" must be of type ${x53}`);
    }
}
class ERR_INVALID_TUPLE extends NodeTypeError {
    constructor(x54, y12){
        super("ERR_INVALID_TUPLE", `${x54} must be an iterable ${y12} tuple`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_IPC_DISCONNECTED extends NodeError {
    constructor(){
        super("ERR_IPC_DISCONNECTED", `IPC channel is already disconnected`);
    }
}
class ERR_IPC_ONE_PIPE extends NodeError {
    constructor(){
        super("ERR_IPC_ONE_PIPE", `Child process can have only one IPC pipe`);
    }
}
class ERR_IPC_SYNC_FORK extends NodeError {
    constructor(){
        super("ERR_IPC_SYNC_FORK", `IPC cannot be used with synchronous forks`);
    }
}
class ERR_MANIFEST_DEPENDENCY_MISSING extends NodeError {
    constructor(x55, y13){
        super("ERR_MANIFEST_DEPENDENCY_MISSING", `Manifest resource ${x55} does not list ${y13} as a dependency specifier`);
    }
}
class ERR_MANIFEST_INTEGRITY_MISMATCH extends NodeSyntaxError {
    constructor(x56){
        super("ERR_MANIFEST_INTEGRITY_MISMATCH", `Manifest resource ${x56} has multiple entries but integrity lists do not match`);
    }
}
class ERR_MANIFEST_INVALID_RESOURCE_FIELD extends NodeTypeError {
    constructor(x57, y14){
        super("ERR_MANIFEST_INVALID_RESOURCE_FIELD", `Manifest resource ${x57} has invalid property value for ${y14}`);
    }
}
class ERR_MANIFEST_TDZ extends NodeError {
    constructor(){
        super("ERR_MANIFEST_TDZ", `Manifest initialization has not yet run`);
    }
}
class ERR_MANIFEST_UNKNOWN_ONERROR extends NodeSyntaxError {
    constructor(x58){
        super("ERR_MANIFEST_UNKNOWN_ONERROR", `Manifest specified unknown error behavior "${x58}".`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x59){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x59} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args1){
        args1 = args1.map((a)=>`"${a}"`
        );
        let msg1 = "The ";
        switch(args1.length){
            case 1:
                msg1 += `${args1[0]} argument`;
                break;
            case 2:
                msg1 += `${args1[0]} and ${args1[1]} arguments`;
                break;
            default:
                msg1 += args1.slice(0, args1.length - 1).join(", ");
                msg1 += `, and ${args1[args1.length - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg1} must be specified`);
    }
}
class ERR_MISSING_OPTION extends NodeTypeError {
    constructor(x60){
        super("ERR_MISSING_OPTION", `${x60} is required`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_NAPI_CONS_FUNCTION extends NodeTypeError {
    constructor(){
        super("ERR_NAPI_CONS_FUNCTION", `Constructor must be a function`);
    }
}
class ERR_NAPI_INVALID_DATAVIEW_ARGS extends NodeRangeError {
    constructor(){
        super("ERR_NAPI_INVALID_DATAVIEW_ARGS", `byte_offset + byte_length should be less than or equal to the size in bytes of the array passed in`);
    }
}
class ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT extends NodeRangeError {
    constructor(x61, y15){
        super("ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT", `start offset of ${x61} should be a multiple of ${y15}`);
    }
}
class ERR_NAPI_INVALID_TYPEDARRAY_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_NAPI_INVALID_TYPEDARRAY_LENGTH", `Invalid typed array length`);
    }
}
class ERR_NO_CRYPTO extends NodeError {
    constructor(){
        super("ERR_NO_CRYPTO", `Node.js is not compiled with OpenSSL crypto support`);
    }
}
class ERR_NO_ICU extends NodeTypeError {
    constructor(x62){
        super("ERR_NO_ICU", `${x62} is not supported on Node.js compiled without ICU`);
    }
}
class ERR_QUICCLIENTSESSION_FAILED extends NodeError {
    constructor(x63){
        super("ERR_QUICCLIENTSESSION_FAILED", `Failed to create a new QuicClientSession: ${x63}`);
    }
}
class ERR_QUICCLIENTSESSION_FAILED_SETSOCKET extends NodeError {
    constructor(){
        super("ERR_QUICCLIENTSESSION_FAILED_SETSOCKET", `Failed to set the QuicSocket`);
    }
}
class ERR_QUICSESSION_DESTROYED extends NodeError {
    constructor(x64){
        super("ERR_QUICSESSION_DESTROYED", `Cannot call ${x64} after a QuicSession has been destroyed`);
    }
}
class ERR_QUICSESSION_INVALID_DCID extends NodeError {
    constructor(x65){
        super("ERR_QUICSESSION_INVALID_DCID", `Invalid DCID value: ${x65}`);
    }
}
class ERR_QUICSESSION_UPDATEKEY extends NodeError {
    constructor(){
        super("ERR_QUICSESSION_UPDATEKEY", `Unable to update QuicSession keys`);
    }
}
class ERR_QUICSOCKET_DESTROYED extends NodeError {
    constructor(x66){
        super("ERR_QUICSOCKET_DESTROYED", `Cannot call ${x66} after a QuicSocket has been destroyed`);
    }
}
class ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH extends NodeError {
    constructor(){
        super("ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH", `The stateResetToken must be exactly 16-bytes in length`);
    }
}
class ERR_QUICSOCKET_LISTENING extends NodeError {
    constructor(){
        super("ERR_QUICSOCKET_LISTENING", `This QuicSocket is already listening`);
    }
}
class ERR_QUICSOCKET_UNBOUND extends NodeError {
    constructor(x67){
        super("ERR_QUICSOCKET_UNBOUND", `Cannot call ${x67} before a QuicSocket has been bound`);
    }
}
class ERR_QUICSTREAM_DESTROYED extends NodeError {
    constructor(x68){
        super("ERR_QUICSTREAM_DESTROYED", `Cannot call ${x68} after a QuicStream has been destroyed`);
    }
}
class ERR_QUICSTREAM_INVALID_PUSH extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_INVALID_PUSH", `Push streams are only supported on client-initiated, bidirectional streams`);
    }
}
class ERR_QUICSTREAM_OPEN_FAILED extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_OPEN_FAILED", `Opening a new QuicStream failed`);
    }
}
class ERR_QUICSTREAM_UNSUPPORTED_PUSH extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_UNSUPPORTED_PUSH", `Push streams are not supported on this QuicSession`);
    }
}
class ERR_QUIC_TLS13_REQUIRED extends NodeError {
    constructor(){
        super("ERR_QUIC_TLS13_REQUIRED", `QUIC requires TLS version 1.3`);
    }
}
class ERR_SCRIPT_EXECUTION_INTERRUPTED extends NodeError {
    constructor(){
        super("ERR_SCRIPT_EXECUTION_INTERRUPTED", "Script execution was interrupted by `SIGINT`");
    }
}
class ERR_SERVER_ALREADY_LISTEN extends NodeError {
    constructor(){
        super("ERR_SERVER_ALREADY_LISTEN", `Listen method has been called more than once without closing.`);
    }
}
class ERR_SERVER_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_SERVER_NOT_RUNNING", `Server is not running.`);
    }
}
class ERR_SOCKET_ALREADY_BOUND extends NodeError {
    constructor(){
        super("ERR_SOCKET_ALREADY_BOUND", `Socket is already bound`);
    }
}
class ERR_SOCKET_BAD_BUFFER_SIZE extends NodeTypeError {
    constructor(){
        super("ERR_SOCKET_BAD_BUFFER_SIZE", `Buffer size must be a positive integer`);
    }
}
class ERR_SOCKET_BAD_TYPE extends NodeTypeError {
    constructor(){
        super("ERR_SOCKET_BAD_TYPE", `Bad socket type specified. Valid types are: udp4, udp6`);
    }
}
class ERR_SOCKET_CLOSED extends NodeError {
    constructor(){
        super("ERR_SOCKET_CLOSED", `Socket is closed`);
    }
}
class ERR_SOCKET_DGRAM_IS_CONNECTED extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_IS_CONNECTED", `Already connected`);
    }
}
class ERR_SOCKET_DGRAM_NOT_CONNECTED extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_NOT_CONNECTED", `Not connected`);
    }
}
class ERR_SOCKET_DGRAM_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_NOT_RUNNING", `Not running`);
    }
}
class ERR_SRI_PARSE extends NodeSyntaxError {
    constructor(name5, __char, position){
        super("ERR_SRI_PARSE", `Subresource Integrity string ${name5} had an unexpected ${__char} at position ${position}`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x69){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x69} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x70){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x70} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRAP extends NodeError {
    constructor(){
        super("ERR_STREAM_WRAP", `Stream has StringDecoder set or is in objectMode`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_SYNTHETIC extends NodeError {
    constructor(){
        super("ERR_SYNTHETIC", `JavaScript Callstack`);
    }
}
class ERR_TLS_DH_PARAM_SIZE extends NodeError {
    constructor(x71){
        super("ERR_TLS_DH_PARAM_SIZE", `DH parameter size ${x71} is less than 2048`);
    }
}
class ERR_TLS_HANDSHAKE_TIMEOUT extends NodeError {
    constructor(){
        super("ERR_TLS_HANDSHAKE_TIMEOUT", `TLS handshake timeout`);
    }
}
class ERR_TLS_INVALID_CONTEXT extends NodeTypeError {
    constructor(x72){
        super("ERR_TLS_INVALID_CONTEXT", `${x72} must be a SecureContext`);
    }
}
class ERR_TLS_INVALID_STATE extends NodeError {
    constructor(){
        super("ERR_TLS_INVALID_STATE", `TLS socket connection must be securely established`);
    }
}
class ERR_TLS_INVALID_PROTOCOL_VERSION extends NodeTypeError {
    constructor(protocol, x73){
        super("ERR_TLS_INVALID_PROTOCOL_VERSION", `${protocol} is not a valid ${x73} TLS protocol version`);
    }
}
class ERR_TLS_PROTOCOL_VERSION_CONFLICT extends NodeTypeError {
    constructor(prevProtocol, protocol1){
        super("ERR_TLS_PROTOCOL_VERSION_CONFLICT", `TLS protocol version ${prevProtocol} conflicts with secureProtocol ${protocol1}`);
    }
}
class ERR_TLS_RENEGOTIATION_DISABLED extends NodeError {
    constructor(){
        super("ERR_TLS_RENEGOTIATION_DISABLED", `TLS session renegotiation disabled for this socket`);
    }
}
class ERR_TLS_REQUIRED_SERVER_NAME extends NodeError {
    constructor(){
        super("ERR_TLS_REQUIRED_SERVER_NAME", `"servername" is required parameter for Server.addContext`);
    }
}
class ERR_TLS_SESSION_ATTACK extends NodeError {
    constructor(){
        super("ERR_TLS_SESSION_ATTACK", `TLS session renegotiation attack detected`);
    }
}
class ERR_TLS_SNI_FROM_SERVER extends NodeError {
    constructor(){
        super("ERR_TLS_SNI_FROM_SERVER", `Cannot issue SNI from a TLS server-side socket`);
    }
}
class ERR_TRACE_EVENTS_CATEGORY_REQUIRED extends NodeTypeError {
    constructor(){
        super("ERR_TRACE_EVENTS_CATEGORY_REQUIRED", `At least one category is required`);
    }
}
class ERR_TRACE_EVENTS_UNAVAILABLE extends NodeError {
    constructor(){
        super("ERR_TRACE_EVENTS_UNAVAILABLE", `Trace events are unavailable`);
    }
}
class ERR_UNAVAILABLE_DURING_EXIT extends NodeError {
    constructor(){
        super("ERR_UNAVAILABLE_DURING_EXIT", `Cannot call function in process exit handler`);
    }
}
class ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET extends NodeError {
    constructor(){
        super("ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET", "`process.setupUncaughtExceptionCapture()` was called while a capture callback was already active");
    }
}
class ERR_UNESCAPED_CHARACTERS extends NodeTypeError {
    constructor(x74){
        super("ERR_UNESCAPED_CHARACTERS", `${x74} contains unescaped characters`);
    }
}
class ERR_UNKNOWN_BUILTIN_MODULE extends NodeError {
    constructor(x75){
        super("ERR_UNKNOWN_BUILTIN_MODULE", `No such built-in module: ${x75}`);
    }
}
class ERR_UNKNOWN_CREDENTIAL extends NodeError {
    constructor(x76, y16){
        super("ERR_UNKNOWN_CREDENTIAL", `${x76} identifier does not exist: ${y16}`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x77){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x77}`);
    }
}
class ERR_UNKNOWN_FILE_EXTENSION extends NodeTypeError {
    constructor(x78, y17){
        super("ERR_UNKNOWN_FILE_EXTENSION", `Unknown file extension "${x78}" for ${y17}`);
    }
}
class ERR_UNKNOWN_MODULE_FORMAT extends NodeRangeError {
    constructor(x79){
        super("ERR_UNKNOWN_MODULE_FORMAT", `Unknown module format: ${x79}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x80){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x80}`);
    }
}
class ERR_UNSUPPORTED_DIR_IMPORT extends NodeError {
    constructor(x81, y18){
        super("ERR_UNSUPPORTED_DIR_IMPORT", `Directory import '${x81}' is not supported resolving ES modules, imported from ${y18}`);
    }
}
class ERR_UNSUPPORTED_ESM_URL_SCHEME extends NodeError {
    constructor(){
        super("ERR_UNSUPPORTED_ESM_URL_SCHEME", `Only file and data URLs are supported by the default ESM loader`);
    }
}
class ERR_V8BREAKITERATOR extends NodeError {
    constructor(){
        super("ERR_V8BREAKITERATOR", `Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl`);
    }
}
class ERR_VALID_PERFORMANCE_ENTRY_TYPE extends NodeError {
    constructor(){
        super("ERR_VALID_PERFORMANCE_ENTRY_TYPE", `At least one valid performance entry type is required`);
    }
}
class ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING extends NodeTypeError {
    constructor(){
        super("ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING", `A dynamic import callback was not specified.`);
    }
}
class ERR_VM_MODULE_ALREADY_LINKED extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_ALREADY_LINKED", `Module has already been linked`);
    }
}
class ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA", `Cached data cannot be created for a module which has been evaluated`);
    }
}
class ERR_VM_MODULE_DIFFERENT_CONTEXT extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_DIFFERENT_CONTEXT", `Linked modules must use the same context`);
    }
}
class ERR_VM_MODULE_LINKING_ERRORED extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_LINKING_ERRORED", `Linking has already failed for the provided module`);
    }
}
class ERR_VM_MODULE_NOT_MODULE extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_NOT_MODULE", `Provided module is not an instance of Module`);
    }
}
class ERR_VM_MODULE_STATUS extends NodeError {
    constructor(x82){
        super("ERR_VM_MODULE_STATUS", `Module status ${x82}`);
    }
}
class ERR_WASI_ALREADY_STARTED extends NodeError {
    constructor(){
        super("ERR_WASI_ALREADY_STARTED", `WASI instance has already started`);
    }
}
class ERR_WORKER_INIT_FAILED extends NodeError {
    constructor(x83){
        super("ERR_WORKER_INIT_FAILED", `Worker initialization failure: ${x83}`);
    }
}
class ERR_WORKER_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_WORKER_NOT_RUNNING", `Worker instance not running`);
    }
}
class ERR_WORKER_OUT_OF_MEMORY extends NodeError {
    constructor(x84){
        super("ERR_WORKER_OUT_OF_MEMORY", `Worker terminated due to reaching memory limit: ${x84}`);
    }
}
class ERR_WORKER_UNSERIALIZABLE_ERROR extends NodeError {
    constructor(){
        super("ERR_WORKER_UNSERIALIZABLE_ERROR", `Serializing an uncaught exception failed`);
    }
}
class ERR_WORKER_UNSUPPORTED_EXTENSION extends NodeTypeError {
    constructor(x85){
        super("ERR_WORKER_UNSUPPORTED_EXTENSION", `The worker script extension must be ".js", ".mjs", or ".cjs". Received "${x85}"`);
    }
}
class ERR_WORKER_UNSUPPORTED_OPERATION extends NodeTypeError {
    constructor(x86){
        super("ERR_WORKER_UNSUPPORTED_OPERATION", `${x86} is not supported in workers`);
    }
}
class ERR_ZLIB_INITIALIZATION_FAILED extends NodeError {
    constructor(){
        super("ERR_ZLIB_INITIALIZATION_FAILED", `Initialization failed`);
    }
}
class ERR_FALSY_VALUE_REJECTION extends NodeError {
    reason;
    constructor(reason3){
        super("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
        this.reason = reason3;
    }
}
class ERR_HTTP2_INVALID_SETTING_VALUE extends NodeRangeError {
    actual;
    min;
    max;
    constructor(name6, actual2, min, max){
        super("ERR_HTTP2_INVALID_SETTING_VALUE", `Invalid value for setting "${name6}": ${actual2}`);
        this.actual = actual2;
        if (min !== undefined) {
            this.min = min;
            this.max = max;
        }
    }
}
class ERR_HTTP2_STREAM_CANCEL extends NodeError {
    cause;
    constructor(error){
        super("ERR_HTTP2_STREAM_CANCEL", typeof error.message === "string" ? `The pending stream has been canceled (caused by: ${error.message})` : "The pending stream has been canceled");
        if (error) {
            this.cause = error;
        }
    }
}
class ERR_INVALID_ADDRESS_FAMILY extends NodeRangeError {
    host;
    port;
    constructor(addressType, host, port){
        super("ERR_INVALID_ADDRESS_FAMILY", `Invalid address family: ${addressType} ${host}:${port}`);
        this.host = host;
        this.port = port;
    }
}
class ERR_INVALID_CHAR extends NodeTypeError {
    constructor(name7, field1){
        super("ERR_INVALID_CHAR", field1 ? `Invalid character in ${name7}` : `Invalid character in ${name7} ["${field1}"]`);
    }
}
class ERR_INVALID_OPT_VALUE extends NodeTypeError {
    constructor(name8, value2){
        super("ERR_INVALID_OPT_VALUE", `The value "${value2}" is invalid for option "${name8}"`);
    }
}
class ERR_INVALID_RETURN_PROPERTY extends NodeTypeError {
    constructor(input3, name9, prop, value3){
        super("ERR_INVALID_RETURN_PROPERTY", `Expected a valid ${input3} to be returned for the "${prop}" from the "${name9}" function but got ${value3}.`);
    }
}
function buildReturnPropertyType(value4) {
    if (value4 && value4.constructor && value4.constructor.name) {
        return `instance of ${value4.constructor.name}`;
    } else {
        return `type ${typeof value4}`;
    }
}
class ERR_INVALID_RETURN_PROPERTY_VALUE extends NodeTypeError {
    constructor(input1, name10, prop1, value4){
        super("ERR_INVALID_RETURN_PROPERTY_VALUE", `Expected ${input1} to be returned for the "${prop1}" from the "${name10}" function but got ${buildReturnPropertyType(value4)}.`);
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input2, name11, value5){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input2} to be returned from the "${name11}" function but got ${buildReturnPropertyType(value5)}.`);
    }
}
class ERR_INVALID_URL extends NodeTypeError {
    input;
    constructor(input4){
        super("ERR_INVALID_URL", `Invalid URL: ${input4}`);
        this.input = input4;
    }
}
function createIterResult(value6, done) {
    return {
        value: value6,
        done
    };
}
let defaultMaxListeners1 = 10;
class EventEmitter {
    static captureRejectionSymbol = Symbol.for("nodejs.rejection");
    static errorMonitor = Symbol("events.errorMonitor");
    static get defaultMaxListeners() {
        return defaultMaxListeners1;
    }
    static set defaultMaxListeners(value) {
        defaultMaxListeners1 = value;
    }
    maxListeners;
    _events;
    constructor(){
        this._events = new Map();
    }
    _addListener(eventName, listener, prepend) {
        this.checkListenerArgument(listener);
        this.emit("newListener", eventName, listener);
        if (this._events.has(eventName)) {
            const listeners = this._events.get(eventName);
            if (prepend) {
                listeners.unshift(listener);
            } else {
                listeners.push(listener);
            }
        } else {
            this._events.set(eventName, [
                listener
            ]);
        }
        const max1 = this.getMaxListeners();
        if (max1 > 0 && this.listenerCount(eventName) > max1) {
            const warning = new Error(`Possible EventEmitter memory leak detected.\n         ${this.listenerCount(eventName)} ${eventName.toString()} listeners.\n         Use emitter.setMaxListeners() to increase limit`);
            warning.name = "MaxListenersExceededWarning";
            console.warn(warning);
        }
        return this;
    }
    addListener(eventName, listener) {
        return this._addListener(eventName, listener, false);
    }
    emit(eventName, ...args) {
        if (this._events.has(eventName)) {
            if (eventName === "error" && this._events.get(EventEmitter.errorMonitor)) {
                this.emit(EventEmitter.errorMonitor, ...args);
            }
            const listeners = this._events.get(eventName).slice();
            for (const listener2 of listeners){
                try {
                    listener2.apply(this, args);
                } catch (err) {
                    this.emit("error", err);
                }
            }
            return true;
        } else if (eventName === "error") {
            if (this._events.get(EventEmitter.errorMonitor)) {
                this.emit(EventEmitter.errorMonitor, ...args);
            }
            const errMsg = args.length > 0 ? args[0] : Error("Unhandled error.");
            throw errMsg;
        }
        return false;
    }
    eventNames() {
        return Array.from(this._events.keys());
    }
    getMaxListeners() {
        return this.maxListeners || EventEmitter.defaultMaxListeners;
    }
    listenerCount(eventName) {
        if (this._events.has(eventName)) {
            return this._events.get(eventName).length;
        } else {
            return 0;
        }
    }
    static listenerCount(emitter, eventName) {
        return emitter.listenerCount(eventName);
    }
    _listeners(target, eventName, unwrap) {
        if (!target._events.has(eventName)) {
            return [];
        }
        const eventListeners = target._events.get(eventName);
        return unwrap ? this.unwrapListeners(eventListeners) : eventListeners.slice(0);
    }
    unwrapListeners(arr) {
        const unwrappedListeners = new Array(arr.length);
        for(let i1 = 0; i1 < arr.length; i1++){
            unwrappedListeners[i1] = arr[i1]["listener"] || arr[i1];
        }
        return unwrappedListeners;
    }
    listeners(eventName) {
        return this._listeners(this, eventName, true);
    }
    rawListeners(eventName) {
        return this._listeners(this, eventName, false);
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        return this._addListener(eventName, listener, false);
    }
    once(eventName, listener) {
        const wrapped = this.onceWrap(eventName, listener);
        this.on(eventName, wrapped);
        return this;
    }
    onceWrap(eventName, listener) {
        this.checkListenerArgument(listener);
        const wrapper = function(...args2) {
            this.context.removeListener(this.eventName, this.rawListener);
            this.listener.apply(this.context, args2);
        };
        const wrapperContext = {
            eventName: eventName,
            listener: listener,
            rawListener: wrapper,
            context: this
        };
        const wrapped = wrapper.bind(wrapperContext);
        wrapperContext.rawListener = wrapped;
        wrapped.listener = listener;
        return wrapped;
    }
    prependListener(eventName, listener) {
        return this._addListener(eventName, listener, true);
    }
    prependOnceListener(eventName, listener) {
        const wrapped = this.onceWrap(eventName, listener);
        this.prependListener(eventName, wrapped);
        return this;
    }
    removeAllListeners(eventName) {
        if (this._events === undefined) {
            return this;
        }
        if (eventName) {
            if (this._events.has(eventName)) {
                const listeners = this._events.get(eventName).slice();
                this._events.delete(eventName);
                for (const listener2 of listeners){
                    this.emit("removeListener", eventName, listener2);
                }
            }
        } else {
            const eventList = this.eventNames();
            eventList.map((value7)=>{
                this.removeAllListeners(value7);
            });
        }
        return this;
    }
    removeListener(eventName, listener) {
        this.checkListenerArgument(listener);
        if (this._events.has(eventName)) {
            const arr = this._events.get(eventName);
            assert(arr);
            let listenerIndex = -1;
            for(let i1 = arr.length - 1; i1 >= 0; i1--){
                if (arr[i1] == listener || arr[i1] && arr[i1]["listener"] == listener) {
                    listenerIndex = i1;
                    break;
                }
            }
            if (listenerIndex >= 0) {
                arr.splice(listenerIndex, 1);
                this.emit("removeListener", eventName, listener);
                if (arr.length === 0) {
                    this._events.delete(eventName);
                }
            }
        }
        return this;
    }
    setMaxListeners(n) {
        if (n !== Infinity) {
            if (n === 0) {
                n = Infinity;
            } else {
                validateIntegerRange(n, "maxListeners", 0);
            }
        }
        this.maxListeners = n;
        return this;
    }
    static once(emitter, name) {
        return new Promise((resolve3, reject)=>{
            if (emitter instanceof EventTarget) {
                emitter.addEventListener(name, (...args2)=>{
                    resolve3(args2);
                }, {
                    once: true,
                    passive: false,
                    capture: false
                });
                return;
            } else if (emitter instanceof EventEmitter) {
                const eventListener = (...args2)=>{
                    if (errorListener !== undefined) {
                        emitter.removeListener("error", errorListener);
                    }
                    resolve3(args2);
                };
                let errorListener;
                if (name !== "error") {
                    errorListener = (err)=>{
                        emitter.removeListener(name, eventListener);
                        reject(err);
                    };
                    emitter.once("error", errorListener);
                }
                emitter.once(name, eventListener);
                return;
            }
        });
    }
    static on(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error1 = null;
        let finished = false;
        const iterator = {
            next () {
                const value7 = unconsumedEventValues.shift();
                if (value7) {
                    return Promise.resolve(createIterResult(value7, false));
                }
                if (error1) {
                    const p = Promise.reject(error1);
                    error1 = null;
                    return p;
                }
                if (finished) {
                    return Promise.resolve(createIterResult(undefined, true));
                }
                return new Promise(function(resolve3, reject) {
                    unconsumedPromises.push({
                        resolve: resolve3,
                        reject
                    });
                });
            },
            return () {
                emitter.removeListener(event, eventHandler);
                emitter.removeListener("error", errorHandler);
                finished = true;
                for (const promise of unconsumedPromises){
                    promise.resolve(createIterResult(undefined, true));
                }
                return Promise.resolve(createIterResult(undefined, true));
            },
            throw (err) {
                error1 = err;
                emitter.removeListener(event, eventHandler);
                emitter.removeListener("error", errorHandler);
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args2) {
            const promise = unconsumedPromises.shift();
            if (promise) {
                promise.resolve(createIterResult(args2, false));
            } else {
                unconsumedEventValues.push(args2);
            }
        }
        function errorHandler(err) {
            finished = true;
            const toError = unconsumedPromises.shift();
            if (toError) {
                toError.reject(err);
            } else {
                error1 = err;
            }
            iterator.return();
        }
    }
    checkListenerArgument(listener) {
        if (typeof listener !== "function") {
            throw new ERR_INVALID_ARG_TYPE("listener", "function", listener);
        }
    }
}
const __default = Object.assign(EventEmitter, {
    EventEmitter
});
const HEX_CHARS = "0123456789abcdef".split("");
const EXTRA = [
    -2147483648,
    8388608,
    32768,
    128
];
const SHIFT = [
    24,
    16,
    8,
    0
];
const blocks = [];
class Sha1 {
    #blocks;
    #block;
    #start;
    #bytes;
    #hBytes;
    #finalized;
    #hashed;
    #h0 = 1732584193;
    #h1 = 4023233417;
    #h2 = 2562383102;
    #h3 = 271733878;
    #h4 = 3285377520;
    #lastByteIndex = 0;
    constructor(sharedMemory1 = false){
        this.init(sharedMemory1);
    }
    init(sharedMemory) {
        if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.#blocks = blocks;
        } else {
            this.#blocks = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
        }
        this.#h0 = 1732584193;
        this.#h1 = 4023233417;
        this.#h2 = 2562383102;
        this.#h3 = 271733878;
        this.#h4 = 3285377520;
        this.#block = this.#start = this.#bytes = this.#hBytes = 0;
        this.#finalized = this.#hashed = false;
    }
    update(message) {
        if (this.#finalized) {
            return this;
        }
        let msg2;
        if (message instanceof ArrayBuffer) {
            msg2 = new Uint8Array(message);
        } else {
            msg2 = message;
        }
        let index = 0;
        const length = msg2.length;
        const blocks1 = this.#blocks;
        while(index < length){
            let i1;
            if (this.#hashed) {
                this.#hashed = false;
                blocks1[0] = this.#block;
                blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
            }
            if (typeof msg2 !== "string") {
                for(i1 = this.#start; index < length && i1 < 64; ++index){
                    blocks1[i1 >> 2] |= msg2[index] << SHIFT[(i1++) & 3];
                }
            } else {
                for(i1 = this.#start; index < length && i1 < 64; ++index){
                    let code7 = msg2.charCodeAt(index);
                    if (code7 < 128) {
                        blocks1[i1 >> 2] |= code7 << SHIFT[(i1++) & 3];
                    } else if (code7 < 2048) {
                        blocks1[i1 >> 2] |= (192 | code7 >> 6) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 & 63) << SHIFT[(i1++) & 3];
                    } else if (code7 < 55296 || code7 >= 57344) {
                        blocks1[i1 >> 2] |= (224 | code7 >> 12) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 >> 6 & 63) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 & 63) << SHIFT[(i1++) & 3];
                    } else {
                        code7 = 65536 + ((code7 & 1023) << 10 | msg2.charCodeAt(++index) & 1023);
                        blocks1[i1 >> 2] |= (240 | code7 >> 18) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 >> 12 & 63) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 >> 6 & 63) << SHIFT[(i1++) & 3];
                        blocks1[i1 >> 2] |= (128 | code7 & 63) << SHIFT[(i1++) & 3];
                    }
                }
            }
            this.#lastByteIndex = i1;
            this.#bytes += i1 - this.#start;
            if (i1 >= 64) {
                this.#block = blocks1[16];
                this.#start = i1 - 64;
                this.hash();
                this.#hashed = true;
            } else {
                this.#start = i1;
            }
        }
        if (this.#bytes > 4294967295) {
            this.#hBytes += this.#bytes / 4294967296 >>> 0;
            this.#bytes = this.#bytes >>> 0;
        }
        return this;
    }
    finalize() {
        if (this.#finalized) {
            return;
        }
        this.#finalized = true;
        const blocks1 = this.#blocks;
        const i1 = this.#lastByteIndex;
        blocks1[16] = this.#block;
        blocks1[i1 >> 2] |= EXTRA[i1 & 3];
        this.#block = blocks1[16];
        if (i1 >= 56) {
            if (!this.#hashed) {
                this.hash();
            }
            blocks1[0] = this.#block;
            blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
        }
        blocks1[14] = this.#hBytes << 3 | this.#bytes >>> 29;
        blocks1[15] = this.#bytes << 3;
        this.hash();
    }
    hash() {
        let a = this.#h0;
        let b = this.#h1;
        let c = this.#h2;
        let d = this.#h3;
        let e = this.#h4;
        let f;
        let j;
        let t;
        const blocks1 = this.#blocks;
        for(j = 16; j < 80; ++j){
            t = blocks1[j - 3] ^ blocks1[j - 8] ^ blocks1[j - 14] ^ blocks1[j - 16];
            blocks1[j] = t << 1 | t >>> 31;
        }
        for(j = 0; j < 20; j += 5){
            f = b & c | ~b & d;
            t = a << 5 | a >>> 27;
            e = t + f + e + 1518500249 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a & b | ~a & c;
            t = e << 5 | e >>> 27;
            d = t + f + d + 1518500249 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e & a | ~e & b;
            t = d << 5 | d >>> 27;
            c = t + f + c + 1518500249 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d & e | ~d & a;
            t = c << 5 | c >>> 27;
            b = t + f + b + 1518500249 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c & d | ~c & e;
            t = b << 5 | b >>> 27;
            a = t + f + a + 1518500249 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 40; j += 5){
            f = b ^ c ^ d;
            t = a << 5 | a >>> 27;
            e = t + f + e + 1859775393 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a ^ b ^ c;
            t = e << 5 | e >>> 27;
            d = t + f + d + 1859775393 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e ^ a ^ b;
            t = d << 5 | d >>> 27;
            c = t + f + c + 1859775393 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d ^ e ^ a;
            t = c << 5 | c >>> 27;
            b = t + f + b + 1859775393 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c ^ d ^ e;
            t = b << 5 | b >>> 27;
            a = t + f + a + 1859775393 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 60; j += 5){
            f = b & c | b & d | c & d;
            t = a << 5 | a >>> 27;
            e = t + f + e - 1894007588 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a & b | a & c | b & c;
            t = e << 5 | e >>> 27;
            d = t + f + d - 1894007588 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e & a | e & b | a & b;
            t = d << 5 | d >>> 27;
            c = t + f + c - 1894007588 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d & e | d & a | e & a;
            t = c << 5 | c >>> 27;
            b = t + f + b - 1894007588 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c & d | c & e | d & e;
            t = b << 5 | b >>> 27;
            a = t + f + a - 1894007588 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 80; j += 5){
            f = b ^ c ^ d;
            t = a << 5 | a >>> 27;
            e = t + f + e - 899497514 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a ^ b ^ c;
            t = e << 5 | e >>> 27;
            d = t + f + d - 899497514 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e ^ a ^ b;
            t = d << 5 | d >>> 27;
            c = t + f + c - 899497514 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d ^ e ^ a;
            t = c << 5 | c >>> 27;
            b = t + f + b - 899497514 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c ^ d ^ e;
            t = b << 5 | b >>> 27;
            a = t + f + a - 899497514 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        this.#h0 = this.#h0 + a >>> 0;
        this.#h1 = this.#h1 + b >>> 0;
        this.#h2 = this.#h2 + c >>> 0;
        this.#h3 = this.#h3 + d >>> 0;
        this.#h4 = this.#h4 + e >>> 0;
    }
    hex() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
    }
    toString() {
        return this.hex();
    }
    digest() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        return [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255, 
        ];
    }
    array() {
        return this.digest();
    }
    arrayBuffer() {
        this.finalize();
        const buffer = new ArrayBuffer(20);
        const dataView = new DataView(buffer);
        dataView.setUint32(0, this.#h0);
        dataView.setUint32(4, this.#h1);
        dataView.setUint32(8, this.#h2);
        dataView.setUint32(12, this.#h3);
        dataView.setUint32(16, this.#h4);
        return buffer;
    }
}
class HmacSha1 extends Sha1 {
    #sharedMemory;
    #inner;
    #oKeyPad;
    constructor(secretKey, sharedMemory2 = false){
        super(sharedMemory2);
        let key;
        if (typeof secretKey === "string") {
            const bytes = [];
            const length = secretKey.length;
            let index = 0;
            for(let i1 = 0; i1 < length; i1++){
                let code7 = secretKey.charCodeAt(i1);
                if (code7 < 128) {
                    bytes[index++] = code7;
                } else if (code7 < 2048) {
                    bytes[index++] = 192 | code7 >> 6;
                    bytes[index++] = 128 | code7 & 63;
                } else if (code7 < 55296 || code7 >= 57344) {
                    bytes[index++] = 224 | code7 >> 12;
                    bytes[index++] = 128 | code7 >> 6 & 63;
                    bytes[index++] = 128 | code7 & 63;
                } else {
                    code7 = 65536 + ((code7 & 1023) << 10 | secretKey.charCodeAt(++i1) & 1023);
                    bytes[index++] = 240 | code7 >> 18;
                    bytes[index++] = 128 | code7 >> 12 & 63;
                    bytes[index++] = 128 | code7 >> 6 & 63;
                    bytes[index++] = 128 | code7 & 63;
                }
            }
            key = bytes;
        } else {
            if (secretKey instanceof ArrayBuffer) {
                key = new Uint8Array(secretKey);
            } else {
                key = secretKey;
            }
        }
        if (key.length > 64) {
            key = new Sha1(true).update(key).array();
        }
        const oKeyPad = [];
        const iKeyPad = [];
        for(let i1 = 0; i1 < 64; i1++){
            const b = key[i1] || 0;
            oKeyPad[i1] = 92 ^ b;
            iKeyPad[i1] = 54 ^ b;
        }
        this.update(iKeyPad);
        this.#oKeyPad = oKeyPad;
        this.#inner = true;
        this.#sharedMemory = sharedMemory2;
    }
    finalize() {
        super.finalize();
        if (this.#inner) {
            this.#inner = false;
            const innerHash = this.array();
            super.init(this.#sharedMemory);
            this.update(this.#oKeyPad);
            this.update(innerHash);
            super.finalize();
        }
    }
}
const db = JSON.parse(`{\n  "application/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "application/3gpdash-qoe-report+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/3gpp-ims+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/a2l": {\n    "source": "iana"\n  },\n  "application/activemessage": {\n    "source": "iana"\n  },\n  "application/activity+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-directory+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcost+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcostparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointprop+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointpropparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-error+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamcontrol+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/aml": {\n    "source": "iana"\n  },\n  "application/andrew-inset": {\n    "source": "iana",\n    "extensions": ["ez"]\n  },\n  "application/applefile": {\n    "source": "iana"\n  },\n  "application/applixware": {\n    "source": "apache",\n    "extensions": ["aw"]\n  },\n  "application/atf": {\n    "source": "iana"\n  },\n  "application/atfx": {\n    "source": "iana"\n  },\n  "application/atom+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atom"]\n  },\n  "application/atomcat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomcat"]\n  },\n  "application/atomdeleted+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomdeleted"]\n  },\n  "application/atomicmail": {\n    "source": "iana"\n  },\n  "application/atomsvc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomsvc"]\n  },\n  "application/atsc-dwd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dwd"]\n  },\n  "application/atsc-dynamic-event-message": {\n    "source": "iana"\n  },\n  "application/atsc-held+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["held"]\n  },\n  "application/atsc-rdt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/atsc-rsat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsat"]\n  },\n  "application/atxml": {\n    "source": "iana"\n  },\n  "application/auth-policy+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/bacnet-xdd+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/batch-smtp": {\n    "source": "iana"\n  },\n  "application/bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/beep+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/calendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/calendar+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xcs"]\n  },\n  "application/call-completion": {\n    "source": "iana"\n  },\n  "application/cals-1840": {\n    "source": "iana"\n  },\n  "application/captive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cbor": {\n    "source": "iana"\n  },\n  "application/cbor-seq": {\n    "source": "iana"\n  },\n  "application/cccex": {\n    "source": "iana"\n  },\n  "application/ccmp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ccxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ccxml"]\n  },\n  "application/cdfx+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdfx"]\n  },\n  "application/cdmi-capability": {\n    "source": "iana",\n    "extensions": ["cdmia"]\n  },\n  "application/cdmi-container": {\n    "source": "iana",\n    "extensions": ["cdmic"]\n  },\n  "application/cdmi-domain": {\n    "source": "iana",\n    "extensions": ["cdmid"]\n  },\n  "application/cdmi-object": {\n    "source": "iana",\n    "extensions": ["cdmio"]\n  },\n  "application/cdmi-queue": {\n    "source": "iana",\n    "extensions": ["cdmiq"]\n  },\n  "application/cdni": {\n    "source": "iana"\n  },\n  "application/cea": {\n    "source": "iana"\n  },\n  "application/cea-2018+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cellml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cfw": {\n    "source": "iana"\n  },\n  "application/clr": {\n    "source": "iana"\n  },\n  "application/clue+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/clue_info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cms": {\n    "source": "iana"\n  },\n  "application/cnrp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-group+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-payload": {\n    "source": "iana"\n  },\n  "application/commonground": {\n    "source": "iana"\n  },\n  "application/conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cose": {\n    "source": "iana"\n  },\n  "application/cose-key": {\n    "source": "iana"\n  },\n  "application/cose-key-set": {\n    "source": "iana"\n  },\n  "application/cpl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csrattrs": {\n    "source": "iana"\n  },\n  "application/csta+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cstadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csvm+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cu-seeme": {\n    "source": "apache",\n    "extensions": ["cu"]\n  },\n  "application/cwt": {\n    "source": "iana"\n  },\n  "application/cybercash": {\n    "source": "iana"\n  },\n  "application/dart": {\n    "compressible": true\n  },\n  "application/dash+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpd"]\n  },\n  "application/dashdelta": {\n    "source": "iana"\n  },\n  "application/davmount+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["davmount"]\n  },\n  "application/dca-rft": {\n    "source": "iana"\n  },\n  "application/dcd": {\n    "source": "iana"\n  },\n  "application/dec-dx": {\n    "source": "iana"\n  },\n  "application/dialog-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom": {\n    "source": "iana"\n  },\n  "application/dicom+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dii": {\n    "source": "iana"\n  },\n  "application/dit": {\n    "source": "iana"\n  },\n  "application/dns": {\n    "source": "iana"\n  },\n  "application/dns+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dns-message": {\n    "source": "iana"\n  },\n  "application/docbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dbk"]\n  },\n  "application/dots+cbor": {\n    "source": "iana"\n  },\n  "application/dskpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dssc+der": {\n    "source": "iana",\n    "extensions": ["dssc"]\n  },\n  "application/dssc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdssc"]\n  },\n  "application/dvcs": {\n    "source": "iana"\n  },\n  "application/ecmascript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es","ecma"]\n  },\n  "application/edi-consent": {\n    "source": "iana"\n  },\n  "application/edi-x12": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/edifact": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/efi": {\n    "source": "iana"\n  },\n  "application/elm+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/elm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.cap+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/emergencycalldata.comment+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.deviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.ecall.msd": {\n    "source": "iana"\n  },\n  "application/emergencycalldata.providerinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.serviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.subscriberinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.veds+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emma+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emma"]\n  },\n  "application/emotionml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emotionml"]\n  },\n  "application/encaprtp": {\n    "source": "iana"\n  },\n  "application/epp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/epub+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["epub"]\n  },\n  "application/eshop": {\n    "source": "iana"\n  },\n  "application/exi": {\n    "source": "iana",\n    "extensions": ["exi"]\n  },\n  "application/expect-ct-report+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/fastinfoset": {\n    "source": "iana"\n  },\n  "application/fastsoap": {\n    "source": "iana"\n  },\n  "application/fdt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fdt"]\n  },\n  "application/fhir+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fhir+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fido.trusted-apps+json": {\n    "compressible": true\n  },\n  "application/fits": {\n    "source": "iana"\n  },\n  "application/flexfec": {\n    "source": "iana"\n  },\n  "application/font-sfnt": {\n    "source": "iana"\n  },\n  "application/font-tdpfr": {\n    "source": "iana",\n    "extensions": ["pfr"]\n  },\n  "application/font-woff": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/framework-attributes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/geo+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["geojson"]\n  },\n  "application/geo+json-seq": {\n    "source": "iana"\n  },\n  "application/geopackage+sqlite3": {\n    "source": "iana"\n  },\n  "application/geoxacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/gltf-buffer": {\n    "source": "iana"\n  },\n  "application/gml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gml"]\n  },\n  "application/gpx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["gpx"]\n  },\n  "application/gxf": {\n    "source": "apache",\n    "extensions": ["gxf"]\n  },\n  "application/gzip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gz"]\n  },\n  "application/h224": {\n    "source": "iana"\n  },\n  "application/held+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/hjson": {\n    "extensions": ["hjson"]\n  },\n  "application/http": {\n    "source": "iana"\n  },\n  "application/hyperstudio": {\n    "source": "iana",\n    "extensions": ["stk"]\n  },\n  "application/ibe-key-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pkg-reply+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pp-data": {\n    "source": "iana"\n  },\n  "application/iges": {\n    "source": "iana"\n  },\n  "application/im-iscomposing+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/index": {\n    "source": "iana"\n  },\n  "application/index.cmd": {\n    "source": "iana"\n  },\n  "application/index.obj": {\n    "source": "iana"\n  },\n  "application/index.response": {\n    "source": "iana"\n  },\n  "application/index.vnd": {\n    "source": "iana"\n  },\n  "application/inkml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ink","inkml"]\n  },\n  "application/iotp": {\n    "source": "iana"\n  },\n  "application/ipfix": {\n    "source": "iana",\n    "extensions": ["ipfix"]\n  },\n  "application/ipp": {\n    "source": "iana"\n  },\n  "application/isup": {\n    "source": "iana"\n  },\n  "application/its+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["its"]\n  },\n  "application/java-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jar","war","ear"]\n  },\n  "application/java-serialized-object": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["ser"]\n  },\n  "application/java-vm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["class"]\n  },\n  "application/javascript": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["js","mjs"]\n  },\n  "application/jf2feed+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jose": {\n    "source": "iana"\n  },\n  "application/jose+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jrd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jscalendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["json","map"]\n  },\n  "application/json-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json-seq": {\n    "source": "iana"\n  },\n  "application/json5": {\n    "extensions": ["json5"]\n  },\n  "application/jsonml+json": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["jsonml"]\n  },\n  "application/jwk+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwk-set+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwt": {\n    "source": "iana"\n  },\n  "application/kpml-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/kpml-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ld+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["jsonld"]\n  },\n  "application/lgr+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lgr"]\n  },\n  "application/link-format": {\n    "source": "iana"\n  },\n  "application/load-control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lost+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lostxml"]\n  },\n  "application/lostsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lpf+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/lxf": {\n    "source": "iana"\n  },\n  "application/mac-binhex40": {\n    "source": "iana",\n    "extensions": ["hqx"]\n  },\n  "application/mac-compactpro": {\n    "source": "apache",\n    "extensions": ["cpt"]\n  },\n  "application/macwriteii": {\n    "source": "iana"\n  },\n  "application/mads+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mads"]\n  },\n  "application/manifest+json": {\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["webmanifest"]\n  },\n  "application/marc": {\n    "source": "iana",\n    "extensions": ["mrc"]\n  },\n  "application/marcxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mrcx"]\n  },\n  "application/mathematica": {\n    "source": "iana",\n    "extensions": ["ma","nb","mb"]\n  },\n  "application/mathml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mathml"]\n  },\n  "application/mathml-content+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mathml-presentation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-associated-procedure-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-deregister+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-envelope+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-protection-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-reception-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-schedule+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-user-service-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbox": {\n    "source": "iana",\n    "extensions": ["mbox"]\n  },\n  "application/media-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/media_control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mediaservercontrol+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mscml"]\n  },\n  "application/merge-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/metalink+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["metalink"]\n  },\n  "application/metalink4+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["meta4"]\n  },\n  "application/mets+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mets"]\n  },\n  "application/mf4": {\n    "source": "iana"\n  },\n  "application/mikey": {\n    "source": "iana"\n  },\n  "application/mipc": {\n    "source": "iana"\n  },\n  "application/mmt-aei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["maei"]\n  },\n  "application/mmt-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musd"]\n  },\n  "application/mods+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mods"]\n  },\n  "application/moss-keys": {\n    "source": "iana"\n  },\n  "application/moss-signature": {\n    "source": "iana"\n  },\n  "application/mosskey-data": {\n    "source": "iana"\n  },\n  "application/mosskey-request": {\n    "source": "iana"\n  },\n  "application/mp21": {\n    "source": "iana",\n    "extensions": ["m21","mp21"]\n  },\n  "application/mp4": {\n    "source": "iana",\n    "extensions": ["mp4s","m4p"]\n  },\n  "application/mpeg4-generic": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod-xmt": {\n    "source": "iana"\n  },\n  "application/mrb-consumer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mrb-publish+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/msc-ivr+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msc-mixer+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msword": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["doc","dot"]\n  },\n  "application/mud+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/multipart-core": {\n    "source": "iana"\n  },\n  "application/mxf": {\n    "source": "iana",\n    "extensions": ["mxf"]\n  },\n  "application/n-quads": {\n    "source": "iana",\n    "extensions": ["nq"]\n  },\n  "application/n-triples": {\n    "source": "iana",\n    "extensions": ["nt"]\n  },\n  "application/nasdata": {\n    "source": "iana"\n  },\n  "application/news-checkgroups": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-groupinfo": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-transmission": {\n    "source": "iana"\n  },\n  "application/nlsml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/node": {\n    "source": "iana",\n    "extensions": ["cjs"]\n  },\n  "application/nss": {\n    "source": "iana"\n  },\n  "application/ocsp-request": {\n    "source": "iana"\n  },\n  "application/ocsp-response": {\n    "source": "iana"\n  },\n  "application/octet-stream": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]\n  },\n  "application/oda": {\n    "source": "iana",\n    "extensions": ["oda"]\n  },\n  "application/odm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/odx": {\n    "source": "iana"\n  },\n  "application/oebps-package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["opf"]\n  },\n  "application/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogx"]\n  },\n  "application/omdoc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["omdoc"]\n  },\n  "application/onenote": {\n    "source": "apache",\n    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]\n  },\n  "application/opc-nodeset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/oscore": {\n    "source": "iana"\n  },\n  "application/oxps": {\n    "source": "iana",\n    "extensions": ["oxps"]\n  },\n  "application/p2p-overlay+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["relo"]\n  },\n  "application/parityfec": {\n    "source": "iana"\n  },\n  "application/passport": {\n    "source": "iana"\n  },\n  "application/patch-ops-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/pdf": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pdf"]\n  },\n  "application/pdx": {\n    "source": "iana"\n  },\n  "application/pem-certificate-chain": {\n    "source": "iana"\n  },\n  "application/pgp-encrypted": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pgp"]\n  },\n  "application/pgp-keys": {\n    "source": "iana"\n  },\n  "application/pgp-signature": {\n    "source": "iana",\n    "extensions": ["asc","sig"]\n  },\n  "application/pics-rules": {\n    "source": "apache",\n    "extensions": ["prf"]\n  },\n  "application/pidf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pidf-diff+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pkcs10": {\n    "source": "iana",\n    "extensions": ["p10"]\n  },\n  "application/pkcs12": {\n    "source": "iana"\n  },\n  "application/pkcs7-mime": {\n    "source": "iana",\n    "extensions": ["p7m","p7c"]\n  },\n  "application/pkcs7-signature": {\n    "source": "iana",\n    "extensions": ["p7s"]\n  },\n  "application/pkcs8": {\n    "source": "iana",\n    "extensions": ["p8"]\n  },\n  "application/pkcs8-encrypted": {\n    "source": "iana"\n  },\n  "application/pkix-attr-cert": {\n    "source": "iana",\n    "extensions": ["ac"]\n  },\n  "application/pkix-cert": {\n    "source": "iana",\n    "extensions": ["cer"]\n  },\n  "application/pkix-crl": {\n    "source": "iana",\n    "extensions": ["crl"]\n  },\n  "application/pkix-pkipath": {\n    "source": "iana",\n    "extensions": ["pkipath"]\n  },\n  "application/pkixcmp": {\n    "source": "iana",\n    "extensions": ["pki"]\n  },\n  "application/pls+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pls"]\n  },\n  "application/poc-settings+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/postscript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ai","eps","ps"]\n  },\n  "application/ppsp-tracker+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/provenance+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["provx"]\n  },\n  "application/prs.alvestrand.titrax-sheet": {\n    "source": "iana"\n  },\n  "application/prs.cww": {\n    "source": "iana",\n    "extensions": ["cww"]\n  },\n  "application/prs.cyn": {\n    "source": "iana",\n    "charset": "7-BIT"\n  },\n  "application/prs.hpub+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/prs.nprend": {\n    "source": "iana"\n  },\n  "application/prs.plucker": {\n    "source": "iana"\n  },\n  "application/prs.rdf-xml-crypt": {\n    "source": "iana"\n  },\n  "application/prs.xsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/pskc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pskcxml"]\n  },\n  "application/pvd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/qsig": {\n    "source": "iana"\n  },\n  "application/raml+yaml": {\n    "compressible": true,\n    "extensions": ["raml"]\n  },\n  "application/raptorfec": {\n    "source": "iana"\n  },\n  "application/rdap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rdf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rdf","owl"]\n  },\n  "application/reginfo+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rif"]\n  },\n  "application/relax-ng-compact-syntax": {\n    "source": "iana",\n    "extensions": ["rnc"]\n  },\n  "application/remote-printing": {\n    "source": "iana"\n  },\n  "application/reputon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/resource-lists+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rl"]\n  },\n  "application/resource-lists-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rld"]\n  },\n  "application/rfc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/riscos": {\n    "source": "iana"\n  },\n  "application/rlmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rls-services+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rs"]\n  },\n  "application/route-apd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rapd"]\n  },\n  "application/route-s-tsid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sls"]\n  },\n  "application/route-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rusd"]\n  },\n  "application/rpki-ghostbusters": {\n    "source": "iana",\n    "extensions": ["gbr"]\n  },\n  "application/rpki-manifest": {\n    "source": "iana",\n    "extensions": ["mft"]\n  },\n  "application/rpki-publication": {\n    "source": "iana"\n  },\n  "application/rpki-roa": {\n    "source": "iana",\n    "extensions": ["roa"]\n  },\n  "application/rpki-updown": {\n    "source": "iana"\n  },\n  "application/rsd+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rsd"]\n  },\n  "application/rss+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rss"]\n  },\n  "application/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "application/rtploopback": {\n    "source": "iana"\n  },\n  "application/rtx": {\n    "source": "iana"\n  },\n  "application/samlassertion+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/samlmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sarif+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sbe": {\n    "source": "iana"\n  },\n  "application/sbml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sbml"]\n  },\n  "application/scaip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scim+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scvp-cv-request": {\n    "source": "iana",\n    "extensions": ["scq"]\n  },\n  "application/scvp-cv-response": {\n    "source": "iana",\n    "extensions": ["scs"]\n  },\n  "application/scvp-vp-request": {\n    "source": "iana",\n    "extensions": ["spq"]\n  },\n  "application/scvp-vp-response": {\n    "source": "iana",\n    "extensions": ["spp"]\n  },\n  "application/sdp": {\n    "source": "iana",\n    "extensions": ["sdp"]\n  },\n  "application/secevent+jwt": {\n    "source": "iana"\n  },\n  "application/senml+cbor": {\n    "source": "iana"\n  },\n  "application/senml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["senmlx"]\n  },\n  "application/senml-etch+cbor": {\n    "source": "iana"\n  },\n  "application/senml-etch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml-exi": {\n    "source": "iana"\n  },\n  "application/sensml+cbor": {\n    "source": "iana"\n  },\n  "application/sensml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sensml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sensmlx"]\n  },\n  "application/sensml-exi": {\n    "source": "iana"\n  },\n  "application/sep+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sep-exi": {\n    "source": "iana"\n  },\n  "application/session-info": {\n    "source": "iana"\n  },\n  "application/set-payment": {\n    "source": "iana"\n  },\n  "application/set-payment-initiation": {\n    "source": "iana",\n    "extensions": ["setpay"]\n  },\n  "application/set-registration": {\n    "source": "iana"\n  },\n  "application/set-registration-initiation": {\n    "source": "iana",\n    "extensions": ["setreg"]\n  },\n  "application/sgml": {\n    "source": "iana"\n  },\n  "application/sgml-open-catalog": {\n    "source": "iana"\n  },\n  "application/shf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["shf"]\n  },\n  "application/sieve": {\n    "source": "iana",\n    "extensions": ["siv","sieve"]\n  },\n  "application/simple-filter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/simple-message-summary": {\n    "source": "iana"\n  },\n  "application/simplesymbolcontainer": {\n    "source": "iana"\n  },\n  "application/sipc": {\n    "source": "iana"\n  },\n  "application/slate": {\n    "source": "iana"\n  },\n  "application/smil": {\n    "source": "iana"\n  },\n  "application/smil+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["smi","smil"]\n  },\n  "application/smpte336m": {\n    "source": "iana"\n  },\n  "application/soap+fastinfoset": {\n    "source": "iana"\n  },\n  "application/soap+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sparql-query": {\n    "source": "iana",\n    "extensions": ["rq"]\n  },\n  "application/sparql-results+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["srx"]\n  },\n  "application/spirits-event+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sql": {\n    "source": "iana"\n  },\n  "application/srgs": {\n    "source": "iana",\n    "extensions": ["gram"]\n  },\n  "application/srgs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["grxml"]\n  },\n  "application/sru+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sru"]\n  },\n  "application/ssdl+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ssdl"]\n  },\n  "application/ssml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ssml"]\n  },\n  "application/stix+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/swid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["swidtag"]\n  },\n  "application/tamp-apex-update": {\n    "source": "iana"\n  },\n  "application/tamp-apex-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-community-update": {\n    "source": "iana"\n  },\n  "application/tamp-community-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-error": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-status-query": {\n    "source": "iana"\n  },\n  "application/tamp-status-response": {\n    "source": "iana"\n  },\n  "application/tamp-update": {\n    "source": "iana"\n  },\n  "application/tamp-update-confirm": {\n    "source": "iana"\n  },\n  "application/tar": {\n    "compressible": true\n  },\n  "application/taxii+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/td+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tei","teicorpus"]\n  },\n  "application/tetra_isi": {\n    "source": "iana"\n  },\n  "application/thraud+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tfi"]\n  },\n  "application/timestamp-query": {\n    "source": "iana"\n  },\n  "application/timestamp-reply": {\n    "source": "iana"\n  },\n  "application/timestamped-data": {\n    "source": "iana",\n    "extensions": ["tsd"]\n  },\n  "application/tlsrpt+gzip": {\n    "source": "iana"\n  },\n  "application/tlsrpt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tnauthlist": {\n    "source": "iana"\n  },\n  "application/toml": {\n    "compressible": true,\n    "extensions": ["toml"]\n  },\n  "application/trickle-ice-sdpfrag": {\n    "source": "iana"\n  },\n  "application/trig": {\n    "source": "iana"\n  },\n  "application/ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttml"]\n  },\n  "application/tve-trigger": {\n    "source": "iana"\n  },\n  "application/tzif": {\n    "source": "iana"\n  },\n  "application/tzif-leap": {\n    "source": "iana"\n  },\n  "application/ubjson": {\n    "compressible": false,\n    "extensions": ["ubj"]\n  },\n  "application/ulpfec": {\n    "source": "iana"\n  },\n  "application/urc-grpsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/urc-ressheet+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsheet"]\n  },\n  "application/urc-targetdesc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["td"]\n  },\n  "application/urc-uisocketdesc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vemmi": {\n    "source": "iana"\n  },\n  "application/vividence.scriptfile": {\n    "source": "apache"\n  },\n  "application/vnd.1000minds.decision-model+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["1km"]\n  },\n  "application/vnd.3gpp-prose+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-prose-pc3ch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-v2x-local-service-information": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.access-transfer-events+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.bsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.gmop+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.interworking-data": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mc-signalling-ear": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-payload": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-signalling": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-floor-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-signed+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-init-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-transmission-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mid-call+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.pic-bw-large": {\n    "source": "iana",\n    "extensions": ["plb"]\n  },\n  "application/vnd.3gpp.pic-bw-small": {\n    "source": "iana",\n    "extensions": ["psb"]\n  },\n  "application/vnd.3gpp.pic-bw-var": {\n    "source": "iana",\n    "extensions": ["pvb"]\n  },\n  "application/vnd.3gpp.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.sms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-ext+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.state-and-event-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.ussd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.bcmcsinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp2.tcap": {\n    "source": "iana",\n    "extensions": ["tcap"]\n  },\n  "application/vnd.3lightssoftware.imagescal": {\n    "source": "iana"\n  },\n  "application/vnd.3m.post-it-notes": {\n    "source": "iana",\n    "extensions": ["pwn"]\n  },\n  "application/vnd.accpac.simply.aso": {\n    "source": "iana",\n    "extensions": ["aso"]\n  },\n  "application/vnd.accpac.simply.imp": {\n    "source": "iana",\n    "extensions": ["imp"]\n  },\n  "application/vnd.acucobol": {\n    "source": "iana",\n    "extensions": ["acu"]\n  },\n  "application/vnd.acucorp": {\n    "source": "iana",\n    "extensions": ["atc","acutc"]\n  },\n  "application/vnd.adobe.air-application-installer-package+zip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["air"]\n  },\n  "application/vnd.adobe.flash.movie": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.formscentral.fcdt": {\n    "source": "iana",\n    "extensions": ["fcdt"]\n  },\n  "application/vnd.adobe.fxp": {\n    "source": "iana",\n    "extensions": ["fxp","fxpl"]\n  },\n  "application/vnd.adobe.partial-upload": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.xdp+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdp"]\n  },\n  "application/vnd.adobe.xfdf": {\n    "source": "iana",\n    "extensions": ["xfdf"]\n  },\n  "application/vnd.aether.imp": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata-pagedef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.cmoca-cmresource": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-charset": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codedfont": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codepage": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-cmtable": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-formdef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-mediummap": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-objectcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-overlay": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-pagesegment": {\n    "source": "iana"\n  },\n  "application/vnd.ah-barcode": {\n    "source": "iana"\n  },\n  "application/vnd.ahead.space": {\n    "source": "iana",\n    "extensions": ["ahead"]\n  },\n  "application/vnd.airzip.filesecure.azf": {\n    "source": "iana",\n    "extensions": ["azf"]\n  },\n  "application/vnd.airzip.filesecure.azs": {\n    "source": "iana",\n    "extensions": ["azs"]\n  },\n  "application/vnd.amadeus+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.amazon.ebook": {\n    "source": "apache",\n    "extensions": ["azw"]\n  },\n  "application/vnd.amazon.mobi8-ebook": {\n    "source": "iana"\n  },\n  "application/vnd.americandynamics.acc": {\n    "source": "iana",\n    "extensions": ["acc"]\n  },\n  "application/vnd.amiga.ami": {\n    "source": "iana",\n    "extensions": ["ami"]\n  },\n  "application/vnd.amundsen.maze+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.android.ota": {\n    "source": "iana"\n  },\n  "application/vnd.android.package-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["apk"]\n  },\n  "application/vnd.anki": {\n    "source": "iana"\n  },\n  "application/vnd.anser-web-certificate-issue-initiation": {\n    "source": "iana",\n    "extensions": ["cii"]\n  },\n  "application/vnd.anser-web-funds-transfer-initiation": {\n    "source": "apache",\n    "extensions": ["fti"]\n  },\n  "application/vnd.antix.game-component": {\n    "source": "iana",\n    "extensions": ["atx"]\n  },\n  "application/vnd.apache.thrift.binary": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.compact": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.json": {\n    "source": "iana"\n  },\n  "application/vnd.api+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.aplextor.warrp+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apothekende.reservation+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apple.installer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpkg"]\n  },\n  "application/vnd.apple.keynote": {\n    "source": "iana",\n    "extensions": ["key"]\n  },\n  "application/vnd.apple.mpegurl": {\n    "source": "iana",\n    "extensions": ["m3u8"]\n  },\n  "application/vnd.apple.numbers": {\n    "source": "iana",\n    "extensions": ["numbers"]\n  },\n  "application/vnd.apple.pages": {\n    "source": "iana",\n    "extensions": ["pages"]\n  },\n  "application/vnd.apple.pkpass": {\n    "compressible": false,\n    "extensions": ["pkpass"]\n  },\n  "application/vnd.arastra.swi": {\n    "source": "iana"\n  },\n  "application/vnd.aristanetworks.swi": {\n    "source": "iana",\n    "extensions": ["swi"]\n  },\n  "application/vnd.artisan+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.artsquare": {\n    "source": "iana"\n  },\n  "application/vnd.astraea-software.iota": {\n    "source": "iana",\n    "extensions": ["iota"]\n  },\n  "application/vnd.audiograph": {\n    "source": "iana",\n    "extensions": ["aep"]\n  },\n  "application/vnd.autopackage": {\n    "source": "iana"\n  },\n  "application/vnd.avalon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.avistar+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.balsamiq.bmml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmml"]\n  },\n  "application/vnd.balsamiq.bmpr": {\n    "source": "iana"\n  },\n  "application/vnd.banana-accounting": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.error": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bekitzur-stech+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bint.med-content": {\n    "source": "iana"\n  },\n  "application/vnd.biopax.rdf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.blink-idb-value-wrapper": {\n    "source": "iana"\n  },\n  "application/vnd.blueice.multipass": {\n    "source": "iana",\n    "extensions": ["mpm"]\n  },\n  "application/vnd.bluetooth.ep.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bluetooth.le.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bmi": {\n    "source": "iana",\n    "extensions": ["bmi"]\n  },\n  "application/vnd.bpf": {\n    "source": "iana"\n  },\n  "application/vnd.bpf3": {\n    "source": "iana"\n  },\n  "application/vnd.businessobjects": {\n    "source": "iana",\n    "extensions": ["rep"]\n  },\n  "application/vnd.byu.uapi+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cab-jscript": {\n    "source": "iana"\n  },\n  "application/vnd.canon-cpdl": {\n    "source": "iana"\n  },\n  "application/vnd.canon-lips": {\n    "source": "iana"\n  },\n  "application/vnd.capasystems-pg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cendio.thinlinc.clientconf": {\n    "source": "iana"\n  },\n  "application/vnd.century-systems.tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.chemdraw+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdxml"]\n  },\n  "application/vnd.chess-pgn": {\n    "source": "iana"\n  },\n  "application/vnd.chipnuts.karaoke-mmd": {\n    "source": "iana",\n    "extensions": ["mmd"]\n  },\n  "application/vnd.ciedi": {\n    "source": "iana"\n  },\n  "application/vnd.cinderella": {\n    "source": "iana",\n    "extensions": ["cdy"]\n  },\n  "application/vnd.cirpack.isdn-ext": {\n    "source": "iana"\n  },\n  "application/vnd.citationstyles.style+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csl"]\n  },\n  "application/vnd.claymore": {\n    "source": "iana",\n    "extensions": ["cla"]\n  },\n  "application/vnd.cloanto.rp9": {\n    "source": "iana",\n    "extensions": ["rp9"]\n  },\n  "application/vnd.clonk.c4group": {\n    "source": "iana",\n    "extensions": ["c4g","c4d","c4f","c4p","c4u"]\n  },\n  "application/vnd.cluetrust.cartomobile-config": {\n    "source": "iana",\n    "extensions": ["c11amc"]\n  },\n  "application/vnd.cluetrust.cartomobile-config-pkg": {\n    "source": "iana",\n    "extensions": ["c11amz"]\n  },\n  "application/vnd.coffeescript": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet-template": {\n    "source": "iana"\n  },\n  "application/vnd.collection+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.doc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.next+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.comicbook+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.comicbook-rar": {\n    "source": "iana"\n  },\n  "application/vnd.commerce-battelle": {\n    "source": "iana"\n  },\n  "application/vnd.commonspace": {\n    "source": "iana",\n    "extensions": ["csp"]\n  },\n  "application/vnd.contact.cmsg": {\n    "source": "iana",\n    "extensions": ["cdbcmsg"]\n  },\n  "application/vnd.coreos.ignition+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cosmocaller": {\n    "source": "iana",\n    "extensions": ["cmc"]\n  },\n  "application/vnd.crick.clicker": {\n    "source": "iana",\n    "extensions": ["clkx"]\n  },\n  "application/vnd.crick.clicker.keyboard": {\n    "source": "iana",\n    "extensions": ["clkk"]\n  },\n  "application/vnd.crick.clicker.palette": {\n    "source": "iana",\n    "extensions": ["clkp"]\n  },\n  "application/vnd.crick.clicker.template": {\n    "source": "iana",\n    "extensions": ["clkt"]\n  },\n  "application/vnd.crick.clicker.wordbank": {\n    "source": "iana",\n    "extensions": ["clkw"]\n  },\n  "application/vnd.criticaltools.wbs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wbs"]\n  },\n  "application/vnd.cryptii.pipe+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.crypto-shade-file": {\n    "source": "iana"\n  },\n  "application/vnd.cryptomator.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.ctc-posml": {\n    "source": "iana",\n    "extensions": ["pml"]\n  },\n  "application/vnd.ctct.ws+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cups-pdf": {\n    "source": "iana"\n  },\n  "application/vnd.cups-postscript": {\n    "source": "iana"\n  },\n  "application/vnd.cups-ppd": {\n    "source": "iana",\n    "extensions": ["ppd"]\n  },\n  "application/vnd.cups-raster": {\n    "source": "iana"\n  },\n  "application/vnd.cups-raw": {\n    "source": "iana"\n  },\n  "application/vnd.curl": {\n    "source": "iana"\n  },\n  "application/vnd.curl.car": {\n    "source": "apache",\n    "extensions": ["car"]\n  },\n  "application/vnd.curl.pcurl": {\n    "source": "apache",\n    "extensions": ["pcurl"]\n  },\n  "application/vnd.cyan.dean.root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cybank": {\n    "source": "iana"\n  },\n  "application/vnd.cyclonedx+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cyclonedx+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.d2l.coursepackage1p0+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.d3m-dataset": {\n    "source": "iana"\n  },\n  "application/vnd.d3m-problem": {\n    "source": "iana"\n  },\n  "application/vnd.dart": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dart"]\n  },\n  "application/vnd.data-vision.rdz": {\n    "source": "iana",\n    "extensions": ["rdz"]\n  },\n  "application/vnd.datapackage+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dataresource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dbf": {\n    "source": "iana",\n    "extensions": ["dbf"]\n  },\n  "application/vnd.debian.binary-package": {\n    "source": "iana"\n  },\n  "application/vnd.dece.data": {\n    "source": "iana",\n    "extensions": ["uvf","uvvf","uvd","uvvd"]\n  },\n  "application/vnd.dece.ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uvt","uvvt"]\n  },\n  "application/vnd.dece.unspecified": {\n    "source": "iana",\n    "extensions": ["uvx","uvvx"]\n  },\n  "application/vnd.dece.zip": {\n    "source": "iana",\n    "extensions": ["uvz","uvvz"]\n  },\n  "application/vnd.denovo.fcselayout-link": {\n    "source": "iana",\n    "extensions": ["fe_launch"]\n  },\n  "application/vnd.desmume.movie": {\n    "source": "iana"\n  },\n  "application/vnd.dir-bi.plate-dl-nosuffix": {\n    "source": "iana"\n  },\n  "application/vnd.dm.delegation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dna": {\n    "source": "iana",\n    "extensions": ["dna"]\n  },\n  "application/vnd.document+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dolby.mlp": {\n    "source": "apache",\n    "extensions": ["mlp"]\n  },\n  "application/vnd.dolby.mobile.1": {\n    "source": "iana"\n  },\n  "application/vnd.dolby.mobile.2": {\n    "source": "iana"\n  },\n  "application/vnd.doremir.scorecloud-binary-document": {\n    "source": "iana"\n  },\n  "application/vnd.dpgraph": {\n    "source": "iana",\n    "extensions": ["dpg"]\n  },\n  "application/vnd.dreamfactory": {\n    "source": "iana",\n    "extensions": ["dfac"]\n  },\n  "application/vnd.drive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ds-keypoint": {\n    "source": "apache",\n    "extensions": ["kpxx"]\n  },\n  "application/vnd.dtg.local": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.flash": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.html": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ait": {\n    "source": "iana",\n    "extensions": ["ait"]\n  },\n  "application/vnd.dvb.dvbisl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.dvbj": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.esgcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcdftnotifaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess2": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgpdd": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcroaming": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-base": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-enhancement": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.notif-aggregate-root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-container+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-generic+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-msglist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-init+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.pfr": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.service": {\n    "source": "iana",\n    "extensions": ["svc"]\n  },\n  "application/vnd.dxr": {\n    "source": "iana"\n  },\n  "application/vnd.dynageo": {\n    "source": "iana",\n    "extensions": ["geo"]\n  },\n  "application/vnd.dzr": {\n    "source": "iana"\n  },\n  "application/vnd.easykaraoke.cdgdownload": {\n    "source": "iana"\n  },\n  "application/vnd.ecdis-update": {\n    "source": "iana"\n  },\n  "application/vnd.ecip.rlp": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.chart": {\n    "source": "iana",\n    "extensions": ["mag"]\n  },\n  "application/vnd.ecowin.filerequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.fileupdate": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.series": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesrequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesupdate": {\n    "source": "iana"\n  },\n  "application/vnd.efi.img": {\n    "source": "iana"\n  },\n  "application/vnd.efi.iso": {\n    "source": "iana"\n  },\n  "application/vnd.emclient.accessrequest+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.enliven": {\n    "source": "iana",\n    "extensions": ["nml"]\n  },\n  "application/vnd.enphase.envoy": {\n    "source": "iana"\n  },\n  "application/vnd.eprints.data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.epson.esf": {\n    "source": "iana",\n    "extensions": ["esf"]\n  },\n  "application/vnd.epson.msf": {\n    "source": "iana",\n    "extensions": ["msf"]\n  },\n  "application/vnd.epson.quickanime": {\n    "source": "iana",\n    "extensions": ["qam"]\n  },\n  "application/vnd.epson.salt": {\n    "source": "iana",\n    "extensions": ["slt"]\n  },\n  "application/vnd.epson.ssf": {\n    "source": "iana",\n    "extensions": ["ssf"]\n  },\n  "application/vnd.ericsson.quickcall": {\n    "source": "iana"\n  },\n  "application/vnd.espass-espass+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.eszigno3+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es3","et3"]\n  },\n  "application/vnd.etsi.aoc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.asic-e+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.asic-s+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.cug+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvcommand+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-bc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-cod+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-npvr+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvservice+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mcid+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mheg5": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.overload-control-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.pstn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.sci+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.simservs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.timestamp-token": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.tsl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.tsl.der": {\n    "source": "iana"\n  },\n  "application/vnd.eudora.data": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.profile": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.settings": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.theme": {\n    "source": "iana"\n  },\n  "application/vnd.exstream-empower+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.exstream-package": {\n    "source": "iana"\n  },\n  "application/vnd.ezpix-album": {\n    "source": "iana",\n    "extensions": ["ez2"]\n  },\n  "application/vnd.ezpix-package": {\n    "source": "iana",\n    "extensions": ["ez3"]\n  },\n  "application/vnd.f-secure.mobile": {\n    "source": "iana"\n  },\n  "application/vnd.fastcopy-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.fdf": {\n    "source": "iana",\n    "extensions": ["fdf"]\n  },\n  "application/vnd.fdsn.mseed": {\n    "source": "iana",\n    "extensions": ["mseed"]\n  },\n  "application/vnd.fdsn.seed": {\n    "source": "iana",\n    "extensions": ["seed","dataless"]\n  },\n  "application/vnd.ffsns": {\n    "source": "iana"\n  },\n  "application/vnd.ficlab.flb+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.filmit.zfc": {\n    "source": "iana"\n  },\n  "application/vnd.fints": {\n    "source": "iana"\n  },\n  "application/vnd.firemonkeys.cloudcell": {\n    "source": "iana"\n  },\n  "application/vnd.flographit": {\n    "source": "iana",\n    "extensions": ["gph"]\n  },\n  "application/vnd.fluxtime.clip": {\n    "source": "iana",\n    "extensions": ["ftc"]\n  },\n  "application/vnd.font-fontforge-sfd": {\n    "source": "iana"\n  },\n  "application/vnd.framemaker": {\n    "source": "iana",\n    "extensions": ["fm","frame","maker","book"]\n  },\n  "application/vnd.frogans.fnc": {\n    "source": "iana",\n    "extensions": ["fnc"]\n  },\n  "application/vnd.frogans.ltf": {\n    "source": "iana",\n    "extensions": ["ltf"]\n  },\n  "application/vnd.fsc.weblaunch": {\n    "source": "iana",\n    "extensions": ["fsc"]\n  },\n  "application/vnd.fujitsu.oasys": {\n    "source": "iana",\n    "extensions": ["oas"]\n  },\n  "application/vnd.fujitsu.oasys2": {\n    "source": "iana",\n    "extensions": ["oa2"]\n  },\n  "application/vnd.fujitsu.oasys3": {\n    "source": "iana",\n    "extensions": ["oa3"]\n  },\n  "application/vnd.fujitsu.oasysgp": {\n    "source": "iana",\n    "extensions": ["fg5"]\n  },\n  "application/vnd.fujitsu.oasysprs": {\n    "source": "iana",\n    "extensions": ["bh2"]\n  },\n  "application/vnd.fujixerox.art-ex": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.art4": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.ddd": {\n    "source": "iana",\n    "extensions": ["ddd"]\n  },\n  "application/vnd.fujixerox.docuworks": {\n    "source": "iana",\n    "extensions": ["xdw"]\n  },\n  "application/vnd.fujixerox.docuworks.binder": {\n    "source": "iana",\n    "extensions": ["xbd"]\n  },\n  "application/vnd.fujixerox.docuworks.container": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.hbpl": {\n    "source": "iana"\n  },\n  "application/vnd.fut-misnet": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.fuzzysheet": {\n    "source": "iana",\n    "extensions": ["fzs"]\n  },\n  "application/vnd.genomatix.tuxedo": {\n    "source": "iana",\n    "extensions": ["txd"]\n  },\n  "application/vnd.gentics.grd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geo+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geocube+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geogebra.file": {\n    "source": "iana",\n    "extensions": ["ggb"]\n  },\n  "application/vnd.geogebra.slides": {\n    "source": "iana"\n  },\n  "application/vnd.geogebra.tool": {\n    "source": "iana",\n    "extensions": ["ggt"]\n  },\n  "application/vnd.geometry-explorer": {\n    "source": "iana",\n    "extensions": ["gex","gre"]\n  },\n  "application/vnd.geonext": {\n    "source": "iana",\n    "extensions": ["gxt"]\n  },\n  "application/vnd.geoplan": {\n    "source": "iana",\n    "extensions": ["g2w"]\n  },\n  "application/vnd.geospace": {\n    "source": "iana",\n    "extensions": ["g3w"]\n  },\n  "application/vnd.gerber": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt-response": {\n    "source": "iana"\n  },\n  "application/vnd.gmx": {\n    "source": "iana",\n    "extensions": ["gmx"]\n  },\n  "application/vnd.google-apps.document": {\n    "compressible": false,\n    "extensions": ["gdoc"]\n  },\n  "application/vnd.google-apps.presentation": {\n    "compressible": false,\n    "extensions": ["gslides"]\n  },\n  "application/vnd.google-apps.spreadsheet": {\n    "compressible": false,\n    "extensions": ["gsheet"]\n  },\n  "application/vnd.google-earth.kml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["kml"]\n  },\n  "application/vnd.google-earth.kmz": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["kmz"]\n  },\n  "application/vnd.gov.sk.e-form+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.gov.sk.e-form+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.gov.sk.xmldatacontainer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.grafeq": {\n    "source": "iana",\n    "extensions": ["gqf","gqs"]\n  },\n  "application/vnd.gridmp": {\n    "source": "iana"\n  },\n  "application/vnd.groove-account": {\n    "source": "iana",\n    "extensions": ["gac"]\n  },\n  "application/vnd.groove-help": {\n    "source": "iana",\n    "extensions": ["ghf"]\n  },\n  "application/vnd.groove-identity-message": {\n    "source": "iana",\n    "extensions": ["gim"]\n  },\n  "application/vnd.groove-injector": {\n    "source": "iana",\n    "extensions": ["grv"]\n  },\n  "application/vnd.groove-tool-message": {\n    "source": "iana",\n    "extensions": ["gtm"]\n  },\n  "application/vnd.groove-tool-template": {\n    "source": "iana",\n    "extensions": ["tpl"]\n  },\n  "application/vnd.groove-vcard": {\n    "source": "iana",\n    "extensions": ["vcg"]\n  },\n  "application/vnd.hal+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hal+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["hal"]\n  },\n  "application/vnd.handheld-entertainment+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zmm"]\n  },\n  "application/vnd.hbci": {\n    "source": "iana",\n    "extensions": ["hbci"]\n  },\n  "application/vnd.hc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hcl-bireports": {\n    "source": "iana"\n  },\n  "application/vnd.hdt": {\n    "source": "iana"\n  },\n  "application/vnd.heroku+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hhe.lesson-player": {\n    "source": "iana",\n    "extensions": ["les"]\n  },\n  "application/vnd.hp-hpgl": {\n    "source": "iana",\n    "extensions": ["hpgl"]\n  },\n  "application/vnd.hp-hpid": {\n    "source": "iana",\n    "extensions": ["hpid"]\n  },\n  "application/vnd.hp-hps": {\n    "source": "iana",\n    "extensions": ["hps"]\n  },\n  "application/vnd.hp-jlyt": {\n    "source": "iana",\n    "extensions": ["jlt"]\n  },\n  "application/vnd.hp-pcl": {\n    "source": "iana",\n    "extensions": ["pcl"]\n  },\n  "application/vnd.hp-pclxl": {\n    "source": "iana",\n    "extensions": ["pclxl"]\n  },\n  "application/vnd.httphone": {\n    "source": "iana"\n  },\n  "application/vnd.hydrostatix.sof-data": {\n    "source": "iana",\n    "extensions": ["sfd-hdstx"]\n  },\n  "application/vnd.hyper+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyper-item+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyperdrive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hzn-3d-crossword": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.electronic-media": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.minipay": {\n    "source": "iana",\n    "extensions": ["mpy"]\n  },\n  "application/vnd.ibm.modcap": {\n    "source": "iana",\n    "extensions": ["afp","listafp","list3820"]\n  },\n  "application/vnd.ibm.rights-management": {\n    "source": "iana",\n    "extensions": ["irm"]\n  },\n  "application/vnd.ibm.secure-container": {\n    "source": "iana",\n    "extensions": ["sc"]\n  },\n  "application/vnd.iccprofile": {\n    "source": "iana",\n    "extensions": ["icc","icm"]\n  },\n  "application/vnd.ieee.1905": {\n    "source": "iana"\n  },\n  "application/vnd.igloader": {\n    "source": "iana",\n    "extensions": ["igl"]\n  },\n  "application/vnd.imagemeter.folder+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.imagemeter.image+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.immervision-ivp": {\n    "source": "iana",\n    "extensions": ["ivp"]\n  },\n  "application/vnd.immervision-ivu": {\n    "source": "iana",\n    "extensions": ["ivu"]\n  },\n  "application/vnd.ims.imsccv1p1": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p2": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p3": {\n    "source": "iana"\n  },\n  "application/vnd.ims.lis.v2.result+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy.id+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings.simple+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informedcontrol.rms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informix-visionary": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.innopath.wamp.notification": {\n    "source": "iana"\n  },\n  "application/vnd.insors.igm": {\n    "source": "iana",\n    "extensions": ["igm"]\n  },\n  "application/vnd.intercon.formnet": {\n    "source": "iana",\n    "extensions": ["xpw","xpx"]\n  },\n  "application/vnd.intergeo": {\n    "source": "iana",\n    "extensions": ["i2g"]\n  },\n  "application/vnd.intertrust.digibox": {\n    "source": "iana"\n  },\n  "application/vnd.intertrust.nncp": {\n    "source": "iana"\n  },\n  "application/vnd.intu.qbo": {\n    "source": "iana",\n    "extensions": ["qbo"]\n  },\n  "application/vnd.intu.qfx": {\n    "source": "iana",\n    "extensions": ["qfx"]\n  },\n  "application/vnd.iptc.g2.catalogitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.conceptitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.knowledgeitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.packageitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.planningitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ipunplugged.rcprofile": {\n    "source": "iana",\n    "extensions": ["rcprofile"]\n  },\n  "application/vnd.irepository.package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["irp"]\n  },\n  "application/vnd.is-xpr": {\n    "source": "iana",\n    "extensions": ["xpr"]\n  },\n  "application/vnd.isac.fcs": {\n    "source": "iana",\n    "extensions": ["fcs"]\n  },\n  "application/vnd.iso11783-10+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.jam": {\n    "source": "iana",\n    "extensions": ["jam"]\n  },\n  "application/vnd.japannet-directory-service": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-jpnstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-payment-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-setstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.jcp.javame.midlet-rms": {\n    "source": "iana",\n    "extensions": ["rms"]\n  },\n  "application/vnd.jisp": {\n    "source": "iana",\n    "extensions": ["jisp"]\n  },\n  "application/vnd.joost.joda-archive": {\n    "source": "iana",\n    "extensions": ["joda"]\n  },\n  "application/vnd.jsk.isdn-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.kahootz": {\n    "source": "iana",\n    "extensions": ["ktz","ktr"]\n  },\n  "application/vnd.kde.karbon": {\n    "source": "iana",\n    "extensions": ["karbon"]\n  },\n  "application/vnd.kde.kchart": {\n    "source": "iana",\n    "extensions": ["chrt"]\n  },\n  "application/vnd.kde.kformula": {\n    "source": "iana",\n    "extensions": ["kfo"]\n  },\n  "application/vnd.kde.kivio": {\n    "source": "iana",\n    "extensions": ["flw"]\n  },\n  "application/vnd.kde.kontour": {\n    "source": "iana",\n    "extensions": ["kon"]\n  },\n  "application/vnd.kde.kpresenter": {\n    "source": "iana",\n    "extensions": ["kpr","kpt"]\n  },\n  "application/vnd.kde.kspread": {\n    "source": "iana",\n    "extensions": ["ksp"]\n  },\n  "application/vnd.kde.kword": {\n    "source": "iana",\n    "extensions": ["kwd","kwt"]\n  },\n  "application/vnd.kenameaapp": {\n    "source": "iana",\n    "extensions": ["htke"]\n  },\n  "application/vnd.kidspiration": {\n    "source": "iana",\n    "extensions": ["kia"]\n  },\n  "application/vnd.kinar": {\n    "source": "iana",\n    "extensions": ["kne","knp"]\n  },\n  "application/vnd.koan": {\n    "source": "iana",\n    "extensions": ["skp","skd","skt","skm"]\n  },\n  "application/vnd.kodak-descriptor": {\n    "source": "iana",\n    "extensions": ["sse"]\n  },\n  "application/vnd.las": {\n    "source": "iana"\n  },\n  "application/vnd.las.las+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.las.las+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lasxml"]\n  },\n  "application/vnd.laszip": {\n    "source": "iana"\n  },\n  "application/vnd.leap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.liberty-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.llamagraphics.life-balance.desktop": {\n    "source": "iana",\n    "extensions": ["lbd"]\n  },\n  "application/vnd.llamagraphics.life-balance.exchange+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lbe"]\n  },\n  "application/vnd.logipipe.circuit+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.loom": {\n    "source": "iana"\n  },\n  "application/vnd.lotus-1-2-3": {\n    "source": "iana",\n    "extensions": ["123"]\n  },\n  "application/vnd.lotus-approach": {\n    "source": "iana",\n    "extensions": ["apr"]\n  },\n  "application/vnd.lotus-freelance": {\n    "source": "iana",\n    "extensions": ["pre"]\n  },\n  "application/vnd.lotus-notes": {\n    "source": "iana",\n    "extensions": ["nsf"]\n  },\n  "application/vnd.lotus-organizer": {\n    "source": "iana",\n    "extensions": ["org"]\n  },\n  "application/vnd.lotus-screencam": {\n    "source": "iana",\n    "extensions": ["scm"]\n  },\n  "application/vnd.lotus-wordpro": {\n    "source": "iana",\n    "extensions": ["lwp"]\n  },\n  "application/vnd.macports.portpkg": {\n    "source": "iana",\n    "extensions": ["portpkg"]\n  },\n  "application/vnd.mapbox-vector-tile": {\n    "source": "iana"\n  },\n  "application/vnd.marlin.drm.actiontoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.conftoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.license+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.mdcf": {\n    "source": "iana"\n  },\n  "application/vnd.mason+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.maxmind.maxmind-db": {\n    "source": "iana"\n  },\n  "application/vnd.mcd": {\n    "source": "iana",\n    "extensions": ["mcd"]\n  },\n  "application/vnd.medcalcdata": {\n    "source": "iana",\n    "extensions": ["mc1"]\n  },\n  "application/vnd.mediastation.cdkey": {\n    "source": "iana",\n    "extensions": ["cdkey"]\n  },\n  "application/vnd.meridian-slingshot": {\n    "source": "iana"\n  },\n  "application/vnd.mfer": {\n    "source": "iana",\n    "extensions": ["mwf"]\n  },\n  "application/vnd.mfmp": {\n    "source": "iana",\n    "extensions": ["mfm"]\n  },\n  "application/vnd.micro+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.micrografx.flo": {\n    "source": "iana",\n    "extensions": ["flo"]\n  },\n  "application/vnd.micrografx.igx": {\n    "source": "iana",\n    "extensions": ["igx"]\n  },\n  "application/vnd.microsoft.portable-executable": {\n    "source": "iana"\n  },\n  "application/vnd.microsoft.windows.thumbnail-cache": {\n    "source": "iana"\n  },\n  "application/vnd.miele+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.mif": {\n    "source": "iana",\n    "extensions": ["mif"]\n  },\n  "application/vnd.minisoft-hp3000-save": {\n    "source": "iana"\n  },\n  "application/vnd.mitsubishi.misty-guard.trustweb": {\n    "source": "iana"\n  },\n  "application/vnd.mobius.daf": {\n    "source": "iana",\n    "extensions": ["daf"]\n  },\n  "application/vnd.mobius.dis": {\n    "source": "iana",\n    "extensions": ["dis"]\n  },\n  "application/vnd.mobius.mbk": {\n    "source": "iana",\n    "extensions": ["mbk"]\n  },\n  "application/vnd.mobius.mqy": {\n    "source": "iana",\n    "extensions": ["mqy"]\n  },\n  "application/vnd.mobius.msl": {\n    "source": "iana",\n    "extensions": ["msl"]\n  },\n  "application/vnd.mobius.plc": {\n    "source": "iana",\n    "extensions": ["plc"]\n  },\n  "application/vnd.mobius.txf": {\n    "source": "iana",\n    "extensions": ["txf"]\n  },\n  "application/vnd.mophun.application": {\n    "source": "iana",\n    "extensions": ["mpn"]\n  },\n  "application/vnd.mophun.certificate": {\n    "source": "iana",\n    "extensions": ["mpc"]\n  },\n  "application/vnd.motorola.flexsuite": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.adsi": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.fis": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.gotap": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.kmr": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.ttc": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.wem": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.iprm": {\n    "source": "iana"\n  },\n  "application/vnd.mozilla.xul+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xul"]\n  },\n  "application/vnd.ms-3mfdocument": {\n    "source": "iana"\n  },\n  "application/vnd.ms-artgalry": {\n    "source": "iana",\n    "extensions": ["cil"]\n  },\n  "application/vnd.ms-asf": {\n    "source": "iana"\n  },\n  "application/vnd.ms-cab-compressed": {\n    "source": "iana",\n    "extensions": ["cab"]\n  },\n  "application/vnd.ms-color.iccprofile": {\n    "source": "apache"\n  },\n  "application/vnd.ms-excel": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]\n  },\n  "application/vnd.ms-excel.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlam"]\n  },\n  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsb"]\n  },\n  "application/vnd.ms-excel.sheet.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsm"]\n  },\n  "application/vnd.ms-excel.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xltm"]\n  },\n  "application/vnd.ms-fontobject": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eot"]\n  },\n  "application/vnd.ms-htmlhelp": {\n    "source": "iana",\n    "extensions": ["chm"]\n  },\n  "application/vnd.ms-ims": {\n    "source": "iana",\n    "extensions": ["ims"]\n  },\n  "application/vnd.ms-lrm": {\n    "source": "iana",\n    "extensions": ["lrm"]\n  },\n  "application/vnd.ms-office.activex+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-officetheme": {\n    "source": "iana",\n    "extensions": ["thmx"]\n  },\n  "application/vnd.ms-opentype": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-outlook": {\n    "compressible": false,\n    "extensions": ["msg"]\n  },\n  "application/vnd.ms-package.obfuscated-opentype": {\n    "source": "apache"\n  },\n  "application/vnd.ms-pki.seccat": {\n    "source": "apache",\n    "extensions": ["cat"]\n  },\n  "application/vnd.ms-pki.stl": {\n    "source": "apache",\n    "extensions": ["stl"]\n  },\n  "application/vnd.ms-playready.initiator+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-powerpoint": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ppt","pps","pot"]\n  },\n  "application/vnd.ms-powerpoint.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppam"]\n  },\n  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["pptm"]\n  },\n  "application/vnd.ms-powerpoint.slide.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["sldm"]\n  },\n  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppsm"]\n  },\n  "application/vnd.ms-powerpoint.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["potm"]\n  },\n  "application/vnd.ms-printdevicecapabilities+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-printing.printticket+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-printschematicket+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-project": {\n    "source": "iana",\n    "extensions": ["mpp","mpt"]\n  },\n  "application/vnd.ms-tnef": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.nwprinting.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.printerpairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.wsd.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-word.document.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["docm"]\n  },\n  "application/vnd.ms-word.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["dotm"]\n  },\n  "application/vnd.ms-works": {\n    "source": "iana",\n    "extensions": ["wps","wks","wcm","wdb"]\n  },\n  "application/vnd.ms-wpl": {\n    "source": "iana",\n    "extensions": ["wpl"]\n  },\n  "application/vnd.ms-xpsdocument": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xps"]\n  },\n  "application/vnd.msa-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.mseq": {\n    "source": "iana",\n    "extensions": ["mseq"]\n  },\n  "application/vnd.msign": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator.cif": {\n    "source": "iana"\n  },\n  "application/vnd.music-niff": {\n    "source": "iana"\n  },\n  "application/vnd.musician": {\n    "source": "iana",\n    "extensions": ["mus"]\n  },\n  "application/vnd.muvee.style": {\n    "source": "iana",\n    "extensions": ["msty"]\n  },\n  "application/vnd.mynfc": {\n    "source": "iana",\n    "extensions": ["taglet"]\n  },\n  "application/vnd.ncd.control": {\n    "source": "iana"\n  },\n  "application/vnd.ncd.reference": {\n    "source": "iana"\n  },\n  "application/vnd.nearst.inv+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nebumind.line": {\n    "source": "iana"\n  },\n  "application/vnd.nervana": {\n    "source": "iana"\n  },\n  "application/vnd.netfpx": {\n    "source": "iana"\n  },\n  "application/vnd.neurolanguage.nlu": {\n    "source": "iana",\n    "extensions": ["nlu"]\n  },\n  "application/vnd.nimn": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.nitro.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.snes.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nitf": {\n    "source": "iana",\n    "extensions": ["ntf","nitf"]\n  },\n  "application/vnd.noblenet-directory": {\n    "source": "iana",\n    "extensions": ["nnd"]\n  },\n  "application/vnd.noblenet-sealer": {\n    "source": "iana",\n    "extensions": ["nns"]\n  },\n  "application/vnd.noblenet-web": {\n    "source": "iana",\n    "extensions": ["nnw"]\n  },\n  "application/vnd.nokia.catalogs": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.iptv.config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.isds-radio-presets": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.landmarkcollection+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.n-gage.ac+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ac"]\n  },\n  "application/vnd.nokia.n-gage.data": {\n    "source": "iana",\n    "extensions": ["ngdat"]\n  },\n  "application/vnd.nokia.n-gage.symbian.install": {\n    "source": "iana",\n    "extensions": ["n-gage"]\n  },\n  "application/vnd.nokia.ncd": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.radio-preset": {\n    "source": "iana",\n    "extensions": ["rpst"]\n  },\n  "application/vnd.nokia.radio-presets": {\n    "source": "iana",\n    "extensions": ["rpss"]\n  },\n  "application/vnd.novadigm.edm": {\n    "source": "iana",\n    "extensions": ["edm"]\n  },\n  "application/vnd.novadigm.edx": {\n    "source": "iana",\n    "extensions": ["edx"]\n  },\n  "application/vnd.novadigm.ext": {\n    "source": "iana",\n    "extensions": ["ext"]\n  },\n  "application/vnd.ntt-local.content-share": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.file-transfer": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.ogw_remote-access": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_remote": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.oasis.opendocument.chart": {\n    "source": "iana",\n    "extensions": ["odc"]\n  },\n  "application/vnd.oasis.opendocument.chart-template": {\n    "source": "iana",\n    "extensions": ["otc"]\n  },\n  "application/vnd.oasis.opendocument.database": {\n    "source": "iana",\n    "extensions": ["odb"]\n  },\n  "application/vnd.oasis.opendocument.formula": {\n    "source": "iana",\n    "extensions": ["odf"]\n  },\n  "application/vnd.oasis.opendocument.formula-template": {\n    "source": "iana",\n    "extensions": ["odft"]\n  },\n  "application/vnd.oasis.opendocument.graphics": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odg"]\n  },\n  "application/vnd.oasis.opendocument.graphics-template": {\n    "source": "iana",\n    "extensions": ["otg"]\n  },\n  "application/vnd.oasis.opendocument.image": {\n    "source": "iana",\n    "extensions": ["odi"]\n  },\n  "application/vnd.oasis.opendocument.image-template": {\n    "source": "iana",\n    "extensions": ["oti"]\n  },\n  "application/vnd.oasis.opendocument.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odp"]\n  },\n  "application/vnd.oasis.opendocument.presentation-template": {\n    "source": "iana",\n    "extensions": ["otp"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ods"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet-template": {\n    "source": "iana",\n    "extensions": ["ots"]\n  },\n  "application/vnd.oasis.opendocument.text": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odt"]\n  },\n  "application/vnd.oasis.opendocument.text-master": {\n    "source": "iana",\n    "extensions": ["odm"]\n  },\n  "application/vnd.oasis.opendocument.text-template": {\n    "source": "iana",\n    "extensions": ["ott"]\n  },\n  "application/vnd.oasis.opendocument.text-web": {\n    "source": "iana",\n    "extensions": ["oth"]\n  },\n  "application/vnd.obn": {\n    "source": "iana"\n  },\n  "application/vnd.ocf+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oci.image.manifest.v1+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oftn.l10n+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessdownload+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessstreaming+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.cspg-hexbinary": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.dae.svg+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.dae.xhtml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.mippvcontrolmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.pae.gem": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.spdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.spdlist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.ueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.userprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.olpc-sugar": {\n    "source": "iana",\n    "extensions": ["xo"]\n  },\n  "application/vnd.oma-scws-config": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-request": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-response": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.drm-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.imd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.ltkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.notification+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.provisioningtrigger": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgboot": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgdd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sgdu": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.simple-symbol-container": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.smartcard-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sprov+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.stkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.cab-address-book+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-feature-handler+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-pcc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-subs-invite+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-user-prefs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.dcd": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dcdc": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dd2+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dd2"]\n  },\n  "application/vnd.oma.drm.risd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.group-usage-list+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oma.lwm2m+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+tlv": {\n    "source": "iana"\n  },\n  "application/vnd.oma.pal+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.detailed-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.final-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.groups+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.invocation-descriptor+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.optimized-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.push": {\n    "source": "iana"\n  },\n  "application/vnd.oma.scidm.messages+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.xcap-directory+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.omads-email+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-file+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-folder+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omaloc-supl-init": {\n    "source": "iana"\n  },\n  "application/vnd.onepager": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamx": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertat": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatx": {\n    "source": "iana"\n  },\n  "application/vnd.openblox.game+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["obgx"]\n  },\n  "application/vnd.openblox.game-binary": {\n    "source": "iana"\n  },\n  "application/vnd.openeye.oeb": {\n    "source": "iana"\n  },\n  "application/vnd.openofficeorg.extension": {\n    "source": "apache",\n    "extensions": ["oxt"]\n  },\n  "application/vnd.openstreetmap.data+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osm"]\n  },\n  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawing+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pptx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide": {\n    "source": "iana",\n    "extensions": ["sldx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {\n    "source": "iana",\n    "extensions": ["ppsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template": {\n    "source": "iana",\n    "extensions": ["potx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xlsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {\n    "source": "iana",\n    "extensions": ["xltx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.theme+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.vmldrawing": {\n    "source": "iana"\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["docx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {\n    "source": "iana",\n    "extensions": ["dotx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.core-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.relationships+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oracle.resource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.orange.indata": {\n    "source": "iana"\n  },\n  "application/vnd.osa.netdeploy": {\n    "source": "iana"\n  },\n  "application/vnd.osgeo.mapguide.package": {\n    "source": "iana",\n    "extensions": ["mgp"]\n  },\n  "application/vnd.osgi.bundle": {\n    "source": "iana"\n  },\n  "application/vnd.osgi.dp": {\n    "source": "iana",\n    "extensions": ["dp"]\n  },\n  "application/vnd.osgi.subsystem": {\n    "source": "iana",\n    "extensions": ["esa"]\n  },\n  "application/vnd.otps.ct-kip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oxli.countgraph": {\n    "source": "iana"\n  },\n  "application/vnd.pagerduty+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.palm": {\n    "source": "iana",\n    "extensions": ["pdb","pqa","oprc"]\n  },\n  "application/vnd.panoply": {\n    "source": "iana"\n  },\n  "application/vnd.paos.xml": {\n    "source": "iana"\n  },\n  "application/vnd.patentdive": {\n    "source": "iana"\n  },\n  "application/vnd.patientecommsdoc": {\n    "source": "iana"\n  },\n  "application/vnd.pawaafile": {\n    "source": "iana",\n    "extensions": ["paw"]\n  },\n  "application/vnd.pcos": {\n    "source": "iana"\n  },\n  "application/vnd.pg.format": {\n    "source": "iana",\n    "extensions": ["str"]\n  },\n  "application/vnd.pg.osasli": {\n    "source": "iana",\n    "extensions": ["ei6"]\n  },\n  "application/vnd.piaccess.application-licence": {\n    "source": "iana"\n  },\n  "application/vnd.picsel": {\n    "source": "iana",\n    "extensions": ["efif"]\n  },\n  "application/vnd.pmi.widget": {\n    "source": "iana",\n    "extensions": ["wg"]\n  },\n  "application/vnd.poc.group-advertisement+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.pocketlearn": {\n    "source": "iana",\n    "extensions": ["plf"]\n  },\n  "application/vnd.powerbuilder6": {\n    "source": "iana",\n    "extensions": ["pbd"]\n  },\n  "application/vnd.powerbuilder6-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75-s": {\n    "source": "iana"\n  },\n  "application/vnd.preminet": {\n    "source": "iana"\n  },\n  "application/vnd.previewsystems.box": {\n    "source": "iana",\n    "extensions": ["box"]\n  },\n  "application/vnd.proteus.magazine": {\n    "source": "iana",\n    "extensions": ["mgz"]\n  },\n  "application/vnd.psfs": {\n    "source": "iana"\n  },\n  "application/vnd.publishare-delta-tree": {\n    "source": "iana",\n    "extensions": ["qps"]\n  },\n  "application/vnd.pvi.ptid1": {\n    "source": "iana",\n    "extensions": ["ptid"]\n  },\n  "application/vnd.pwg-multiplexed": {\n    "source": "iana"\n  },\n  "application/vnd.pwg-xhtml-print+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.qualcomm.brew-app-res": {\n    "source": "iana"\n  },\n  "application/vnd.quarantainenet": {\n    "source": "iana"\n  },\n  "application/vnd.quark.quarkxpress": {\n    "source": "iana",\n    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]\n  },\n  "application/vnd.quobject-quoxdocument": {\n    "source": "iana"\n  },\n  "application/vnd.radisys.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-stream+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-base+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-detect+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-group+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-speech+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-transform+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rainstor.data": {\n    "source": "iana"\n  },\n  "application/vnd.rapid": {\n    "source": "iana"\n  },\n  "application/vnd.rar": {\n    "source": "iana",\n    "extensions": ["rar"]\n  },\n  "application/vnd.realvnc.bed": {\n    "source": "iana",\n    "extensions": ["bed"]\n  },\n  "application/vnd.recordare.musicxml": {\n    "source": "iana",\n    "extensions": ["mxl"]\n  },\n  "application/vnd.recordare.musicxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musicxml"]\n  },\n  "application/vnd.renlearn.rlprint": {\n    "source": "iana"\n  },\n  "application/vnd.restful+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rig.cryptonote": {\n    "source": "iana",\n    "extensions": ["cryptonote"]\n  },\n  "application/vnd.rim.cod": {\n    "source": "apache",\n    "extensions": ["cod"]\n  },\n  "application/vnd.rn-realmedia": {\n    "source": "apache",\n    "extensions": ["rm"]\n  },\n  "application/vnd.rn-realmedia-vbr": {\n    "source": "apache",\n    "extensions": ["rmvb"]\n  },\n  "application/vnd.route66.link66+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["link66"]\n  },\n  "application/vnd.rs-274x": {\n    "source": "iana"\n  },\n  "application/vnd.ruckus.download": {\n    "source": "iana"\n  },\n  "application/vnd.s3sms": {\n    "source": "iana"\n  },\n  "application/vnd.sailingtracker.track": {\n    "source": "iana",\n    "extensions": ["st"]\n  },\n  "application/vnd.sar": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.cid": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.mid2": {\n    "source": "iana"\n  },\n  "application/vnd.scribus": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.3df": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.csf": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.doc": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.eml": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.mht": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.net": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.ppt": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.tiff": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.xls": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.html": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.pdf": {\n    "source": "iana"\n  },\n  "application/vnd.seemail": {\n    "source": "iana",\n    "extensions": ["see"]\n  },\n  "application/vnd.seis+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.sema": {\n    "source": "iana",\n    "extensions": ["sema"]\n  },\n  "application/vnd.semd": {\n    "source": "iana",\n    "extensions": ["semd"]\n  },\n  "application/vnd.semf": {\n    "source": "iana",\n    "extensions": ["semf"]\n  },\n  "application/vnd.shade-save-file": {\n    "source": "iana"\n  },\n  "application/vnd.shana.informed.formdata": {\n    "source": "iana",\n    "extensions": ["ifm"]\n  },\n  "application/vnd.shana.informed.formtemplate": {\n    "source": "iana",\n    "extensions": ["itp"]\n  },\n  "application/vnd.shana.informed.interchange": {\n    "source": "iana",\n    "extensions": ["iif"]\n  },\n  "application/vnd.shana.informed.package": {\n    "source": "iana",\n    "extensions": ["ipk"]\n  },\n  "application/vnd.shootproof+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shopkick+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shp": {\n    "source": "iana"\n  },\n  "application/vnd.shx": {\n    "source": "iana"\n  },\n  "application/vnd.sigrok.session": {\n    "source": "iana"\n  },\n  "application/vnd.simtech-mindmapper": {\n    "source": "iana",\n    "extensions": ["twd","twds"]\n  },\n  "application/vnd.siren+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.smaf": {\n    "source": "iana",\n    "extensions": ["mmf"]\n  },\n  "application/vnd.smart.notebook": {\n    "source": "iana"\n  },\n  "application/vnd.smart.teacher": {\n    "source": "iana",\n    "extensions": ["teacher"]\n  },\n  "application/vnd.snesdev-page-table": {\n    "source": "iana"\n  },\n  "application/vnd.software602.filler.form+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fo"]\n  },\n  "application/vnd.software602.filler.form-xml-zip": {\n    "source": "iana"\n  },\n  "application/vnd.solent.sdkm+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sdkm","sdkd"]\n  },\n  "application/vnd.spotfire.dxp": {\n    "source": "iana",\n    "extensions": ["dxp"]\n  },\n  "application/vnd.spotfire.sfs": {\n    "source": "iana",\n    "extensions": ["sfs"]\n  },\n  "application/vnd.sqlite3": {\n    "source": "iana"\n  },\n  "application/vnd.sss-cod": {\n    "source": "iana"\n  },\n  "application/vnd.sss-dtf": {\n    "source": "iana"\n  },\n  "application/vnd.sss-ntf": {\n    "source": "iana"\n  },\n  "application/vnd.stardivision.calc": {\n    "source": "apache",\n    "extensions": ["sdc"]\n  },\n  "application/vnd.stardivision.draw": {\n    "source": "apache",\n    "extensions": ["sda"]\n  },\n  "application/vnd.stardivision.impress": {\n    "source": "apache",\n    "extensions": ["sdd"]\n  },\n  "application/vnd.stardivision.math": {\n    "source": "apache",\n    "extensions": ["smf"]\n  },\n  "application/vnd.stardivision.writer": {\n    "source": "apache",\n    "extensions": ["sdw","vor"]\n  },\n  "application/vnd.stardivision.writer-global": {\n    "source": "apache",\n    "extensions": ["sgl"]\n  },\n  "application/vnd.stepmania.package": {\n    "source": "iana",\n    "extensions": ["smzip"]\n  },\n  "application/vnd.stepmania.stepchart": {\n    "source": "iana",\n    "extensions": ["sm"]\n  },\n  "application/vnd.street-stream": {\n    "source": "iana"\n  },\n  "application/vnd.sun.wadl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wadl"]\n  },\n  "application/vnd.sun.xml.calc": {\n    "source": "apache",\n    "extensions": ["sxc"]\n  },\n  "application/vnd.sun.xml.calc.template": {\n    "source": "apache",\n    "extensions": ["stc"]\n  },\n  "application/vnd.sun.xml.draw": {\n    "source": "apache",\n    "extensions": ["sxd"]\n  },\n  "application/vnd.sun.xml.draw.template": {\n    "source": "apache",\n    "extensions": ["std"]\n  },\n  "application/vnd.sun.xml.impress": {\n    "source": "apache",\n    "extensions": ["sxi"]\n  },\n  "application/vnd.sun.xml.impress.template": {\n    "source": "apache",\n    "extensions": ["sti"]\n  },\n  "application/vnd.sun.xml.math": {\n    "source": "apache",\n    "extensions": ["sxm"]\n  },\n  "application/vnd.sun.xml.writer": {\n    "source": "apache",\n    "extensions": ["sxw"]\n  },\n  "application/vnd.sun.xml.writer.global": {\n    "source": "apache",\n    "extensions": ["sxg"]\n  },\n  "application/vnd.sun.xml.writer.template": {\n    "source": "apache",\n    "extensions": ["stw"]\n  },\n  "application/vnd.sus-calendar": {\n    "source": "iana",\n    "extensions": ["sus","susp"]\n  },\n  "application/vnd.svd": {\n    "source": "iana",\n    "extensions": ["svd"]\n  },\n  "application/vnd.swiftview-ics": {\n    "source": "iana"\n  },\n  "application/vnd.sycle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.symbian.install": {\n    "source": "apache",\n    "extensions": ["sis","sisx"]\n  },\n  "application/vnd.syncml+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xsm"]\n  },\n  "application/vnd.syncml.dm+wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["bdm"]\n  },\n  "application/vnd.syncml.dm+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xdm"]\n  },\n  "application/vnd.syncml.dm.notification": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["ddf"]\n  },\n  "application/vnd.syncml.dmtnds+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmtnds+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.syncml.ds.notification": {\n    "source": "iana"\n  },\n  "application/vnd.tableschema+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tao.intent-module-archive": {\n    "source": "iana",\n    "extensions": ["tao"]\n  },\n  "application/vnd.tcpdump.pcap": {\n    "source": "iana",\n    "extensions": ["pcap","cap","dmp"]\n  },\n  "application/vnd.think-cell.ppttc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tmd.mediaflex.api+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tml": {\n    "source": "iana"\n  },\n  "application/vnd.tmobile-livetv": {\n    "source": "iana",\n    "extensions": ["tmo"]\n  },\n  "application/vnd.tri.onesource": {\n    "source": "iana"\n  },\n  "application/vnd.trid.tpt": {\n    "source": "iana",\n    "extensions": ["tpt"]\n  },\n  "application/vnd.triscape.mxs": {\n    "source": "iana",\n    "extensions": ["mxs"]\n  },\n  "application/vnd.trueapp": {\n    "source": "iana",\n    "extensions": ["tra"]\n  },\n  "application/vnd.truedoc": {\n    "source": "iana"\n  },\n  "application/vnd.ubisoft.webplayer": {\n    "source": "iana"\n  },\n  "application/vnd.ufdl": {\n    "source": "iana",\n    "extensions": ["ufd","ufdl"]\n  },\n  "application/vnd.uiq.theme": {\n    "source": "iana",\n    "extensions": ["utz"]\n  },\n  "application/vnd.umajin": {\n    "source": "iana",\n    "extensions": ["umj"]\n  },\n  "application/vnd.unity": {\n    "source": "iana",\n    "extensions": ["unityweb"]\n  },\n  "application/vnd.uoml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uoml"]\n  },\n  "application/vnd.uplanet.alert": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.alert-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.signal": {\n    "source": "iana"\n  },\n  "application/vnd.uri-map": {\n    "source": "iana"\n  },\n  "application/vnd.valve.source.material": {\n    "source": "iana"\n  },\n  "application/vnd.vcx": {\n    "source": "iana",\n    "extensions": ["vcx"]\n  },\n  "application/vnd.vd-study": {\n    "source": "iana"\n  },\n  "application/vnd.vectorworks": {\n    "source": "iana"\n  },\n  "application/vnd.vel+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.verimatrix.vcas": {\n    "source": "iana"\n  },\n  "application/vnd.veryant.thin": {\n    "source": "iana"\n  },\n  "application/vnd.ves.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.vidsoft.vidconference": {\n    "source": "iana"\n  },\n  "application/vnd.visio": {\n    "source": "iana",\n    "extensions": ["vsd","vst","vss","vsw"]\n  },\n  "application/vnd.visionary": {\n    "source": "iana",\n    "extensions": ["vis"]\n  },\n  "application/vnd.vividence.scriptfile": {\n    "source": "iana"\n  },\n  "application/vnd.vsf": {\n    "source": "iana",\n    "extensions": ["vsf"]\n  },\n  "application/vnd.wap.sic": {\n    "source": "iana"\n  },\n  "application/vnd.wap.slc": {\n    "source": "iana"\n  },\n  "application/vnd.wap.wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["wbxml"]\n  },\n  "application/vnd.wap.wmlc": {\n    "source": "iana",\n    "extensions": ["wmlc"]\n  },\n  "application/vnd.wap.wmlscriptc": {\n    "source": "iana",\n    "extensions": ["wmlsc"]\n  },\n  "application/vnd.webturbo": {\n    "source": "iana",\n    "extensions": ["wtb"]\n  },\n  "application/vnd.wfa.dpp": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.p2p": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.wsc": {\n    "source": "iana"\n  },\n  "application/vnd.windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.wmc": {\n    "source": "iana"\n  },\n  "application/vnd.wmf.bootstrap": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica.package": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.player": {\n    "source": "iana",\n    "extensions": ["nbp"]\n  },\n  "application/vnd.wordperfect": {\n    "source": "iana",\n    "extensions": ["wpd"]\n  },\n  "application/vnd.wqd": {\n    "source": "iana",\n    "extensions": ["wqd"]\n  },\n  "application/vnd.wrq-hp3000-labelled": {\n    "source": "iana"\n  },\n  "application/vnd.wt.stf": {\n    "source": "iana",\n    "extensions": ["stf"]\n  },\n  "application/vnd.wv.csp+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.wv.csp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.wv.ssp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xacml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xara": {\n    "source": "iana",\n    "extensions": ["xar"]\n  },\n  "application/vnd.xfdl": {\n    "source": "iana",\n    "extensions": ["xfdl"]\n  },\n  "application/vnd.xfdl.webform": {\n    "source": "iana"\n  },\n  "application/vnd.xmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xmpie.cpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.dpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.plan": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.ppkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.xlim": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.hv-dic": {\n    "source": "iana",\n    "extensions": ["hvd"]\n  },\n  "application/vnd.yamaha.hv-script": {\n    "source": "iana",\n    "extensions": ["hvs"]\n  },\n  "application/vnd.yamaha.hv-voice": {\n    "source": "iana",\n    "extensions": ["hvp"]\n  },\n  "application/vnd.yamaha.openscoreformat": {\n    "source": "iana",\n    "extensions": ["osf"]\n  },\n  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osfpvg"]\n  },\n  "application/vnd.yamaha.remote-setup": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.smaf-audio": {\n    "source": "iana",\n    "extensions": ["saf"]\n  },\n  "application/vnd.yamaha.smaf-phrase": {\n    "source": "iana",\n    "extensions": ["spf"]\n  },\n  "application/vnd.yamaha.through-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.tunnel-udpencap": {\n    "source": "iana"\n  },\n  "application/vnd.yaoweme": {\n    "source": "iana"\n  },\n  "application/vnd.yellowriver-custom-menu": {\n    "source": "iana",\n    "extensions": ["cmp"]\n  },\n  "application/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "application/vnd.zul": {\n    "source": "iana",\n    "extensions": ["zir","zirz"]\n  },\n  "application/vnd.zzazz.deck+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zaz"]\n  },\n  "application/voicexml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vxml"]\n  },\n  "application/voucher-cms+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vq-rtcpxr": {\n    "source": "iana"\n  },\n  "application/wasm": {\n    "compressible": true,\n    "extensions": ["wasm"]\n  },\n  "application/watcherinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/webpush-options+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/whoispp-query": {\n    "source": "iana"\n  },\n  "application/whoispp-response": {\n    "source": "iana"\n  },\n  "application/widget": {\n    "source": "iana",\n    "extensions": ["wgt"]\n  },\n  "application/winhlp": {\n    "source": "apache",\n    "extensions": ["hlp"]\n  },\n  "application/wita": {\n    "source": "iana"\n  },\n  "application/wordperfect5.1": {\n    "source": "iana"\n  },\n  "application/wsdl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wsdl"]\n  },\n  "application/wspolicy+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wspolicy"]\n  },\n  "application/x-7z-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["7z"]\n  },\n  "application/x-abiword": {\n    "source": "apache",\n    "extensions": ["abw"]\n  },\n  "application/x-ace-compressed": {\n    "source": "apache",\n    "extensions": ["ace"]\n  },\n  "application/x-amf": {\n    "source": "apache"\n  },\n  "application/x-apple-diskimage": {\n    "source": "apache",\n    "extensions": ["dmg"]\n  },\n  "application/x-arj": {\n    "compressible": false,\n    "extensions": ["arj"]\n  },\n  "application/x-authorware-bin": {\n    "source": "apache",\n    "extensions": ["aab","x32","u32","vox"]\n  },\n  "application/x-authorware-map": {\n    "source": "apache",\n    "extensions": ["aam"]\n  },\n  "application/x-authorware-seg": {\n    "source": "apache",\n    "extensions": ["aas"]\n  },\n  "application/x-bcpio": {\n    "source": "apache",\n    "extensions": ["bcpio"]\n  },\n  "application/x-bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/x-bittorrent": {\n    "source": "apache",\n    "extensions": ["torrent"]\n  },\n  "application/x-blorb": {\n    "source": "apache",\n    "extensions": ["blb","blorb"]\n  },\n  "application/x-bzip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz"]\n  },\n  "application/x-bzip2": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz2","boz"]\n  },\n  "application/x-cbr": {\n    "source": "apache",\n    "extensions": ["cbr","cba","cbt","cbz","cb7"]\n  },\n  "application/x-cdlink": {\n    "source": "apache",\n    "extensions": ["vcd"]\n  },\n  "application/x-cfs-compressed": {\n    "source": "apache",\n    "extensions": ["cfs"]\n  },\n  "application/x-chat": {\n    "source": "apache",\n    "extensions": ["chat"]\n  },\n  "application/x-chess-pgn": {\n    "source": "apache",\n    "extensions": ["pgn"]\n  },\n  "application/x-chrome-extension": {\n    "extensions": ["crx"]\n  },\n  "application/x-cocoa": {\n    "source": "nginx",\n    "extensions": ["cco"]\n  },\n  "application/x-compress": {\n    "source": "apache"\n  },\n  "application/x-conference": {\n    "source": "apache",\n    "extensions": ["nsc"]\n  },\n  "application/x-cpio": {\n    "source": "apache",\n    "extensions": ["cpio"]\n  },\n  "application/x-csh": {\n    "source": "apache",\n    "extensions": ["csh"]\n  },\n  "application/x-deb": {\n    "compressible": false\n  },\n  "application/x-debian-package": {\n    "source": "apache",\n    "extensions": ["deb","udeb"]\n  },\n  "application/x-dgc-compressed": {\n    "source": "apache",\n    "extensions": ["dgc"]\n  },\n  "application/x-director": {\n    "source": "apache",\n    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]\n  },\n  "application/x-doom": {\n    "source": "apache",\n    "extensions": ["wad"]\n  },\n  "application/x-dtbncx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ncx"]\n  },\n  "application/x-dtbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dtb"]\n  },\n  "application/x-dtbresource+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["res"]\n  },\n  "application/x-dvi": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["dvi"]\n  },\n  "application/x-envoy": {\n    "source": "apache",\n    "extensions": ["evy"]\n  },\n  "application/x-eva": {\n    "source": "apache",\n    "extensions": ["eva"]\n  },\n  "application/x-font-bdf": {\n    "source": "apache",\n    "extensions": ["bdf"]\n  },\n  "application/x-font-dos": {\n    "source": "apache"\n  },\n  "application/x-font-framemaker": {\n    "source": "apache"\n  },\n  "application/x-font-ghostscript": {\n    "source": "apache",\n    "extensions": ["gsf"]\n  },\n  "application/x-font-libgrx": {\n    "source": "apache"\n  },\n  "application/x-font-linux-psf": {\n    "source": "apache",\n    "extensions": ["psf"]\n  },\n  "application/x-font-pcf": {\n    "source": "apache",\n    "extensions": ["pcf"]\n  },\n  "application/x-font-snf": {\n    "source": "apache",\n    "extensions": ["snf"]\n  },\n  "application/x-font-speedo": {\n    "source": "apache"\n  },\n  "application/x-font-sunos-news": {\n    "source": "apache"\n  },\n  "application/x-font-type1": {\n    "source": "apache",\n    "extensions": ["pfa","pfb","pfm","afm"]\n  },\n  "application/x-font-vfont": {\n    "source": "apache"\n  },\n  "application/x-freearc": {\n    "source": "apache",\n    "extensions": ["arc"]\n  },\n  "application/x-futuresplash": {\n    "source": "apache",\n    "extensions": ["spl"]\n  },\n  "application/x-gca-compressed": {\n    "source": "apache",\n    "extensions": ["gca"]\n  },\n  "application/x-glulx": {\n    "source": "apache",\n    "extensions": ["ulx"]\n  },\n  "application/x-gnumeric": {\n    "source": "apache",\n    "extensions": ["gnumeric"]\n  },\n  "application/x-gramps-xml": {\n    "source": "apache",\n    "extensions": ["gramps"]\n  },\n  "application/x-gtar": {\n    "source": "apache",\n    "extensions": ["gtar"]\n  },\n  "application/x-gzip": {\n    "source": "apache"\n  },\n  "application/x-hdf": {\n    "source": "apache",\n    "extensions": ["hdf"]\n  },\n  "application/x-httpd-php": {\n    "compressible": true,\n    "extensions": ["php"]\n  },\n  "application/x-install-instructions": {\n    "source": "apache",\n    "extensions": ["install"]\n  },\n  "application/x-iso9660-image": {\n    "source": "apache",\n    "extensions": ["iso"]\n  },\n  "application/x-java-archive-diff": {\n    "source": "nginx",\n    "extensions": ["jardiff"]\n  },\n  "application/x-java-jnlp-file": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jnlp"]\n  },\n  "application/x-javascript": {\n    "compressible": true\n  },\n  "application/x-keepass2": {\n    "extensions": ["kdbx"]\n  },\n  "application/x-latex": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["latex"]\n  },\n  "application/x-lua-bytecode": {\n    "extensions": ["luac"]\n  },\n  "application/x-lzh-compressed": {\n    "source": "apache",\n    "extensions": ["lzh","lha"]\n  },\n  "application/x-makeself": {\n    "source": "nginx",\n    "extensions": ["run"]\n  },\n  "application/x-mie": {\n    "source": "apache",\n    "extensions": ["mie"]\n  },\n  "application/x-mobipocket-ebook": {\n    "source": "apache",\n    "extensions": ["prc","mobi"]\n  },\n  "application/x-mpegurl": {\n    "compressible": false\n  },\n  "application/x-ms-application": {\n    "source": "apache",\n    "extensions": ["application"]\n  },\n  "application/x-ms-shortcut": {\n    "source": "apache",\n    "extensions": ["lnk"]\n  },\n  "application/x-ms-wmd": {\n    "source": "apache",\n    "extensions": ["wmd"]\n  },\n  "application/x-ms-wmz": {\n    "source": "apache",\n    "extensions": ["wmz"]\n  },\n  "application/x-ms-xbap": {\n    "source": "apache",\n    "extensions": ["xbap"]\n  },\n  "application/x-msaccess": {\n    "source": "apache",\n    "extensions": ["mdb"]\n  },\n  "application/x-msbinder": {\n    "source": "apache",\n    "extensions": ["obd"]\n  },\n  "application/x-mscardfile": {\n    "source": "apache",\n    "extensions": ["crd"]\n  },\n  "application/x-msclip": {\n    "source": "apache",\n    "extensions": ["clp"]\n  },\n  "application/x-msdos-program": {\n    "extensions": ["exe"]\n  },\n  "application/x-msdownload": {\n    "source": "apache",\n    "extensions": ["exe","dll","com","bat","msi"]\n  },\n  "application/x-msmediaview": {\n    "source": "apache",\n    "extensions": ["mvb","m13","m14"]\n  },\n  "application/x-msmetafile": {\n    "source": "apache",\n    "extensions": ["wmf","wmz","emf","emz"]\n  },\n  "application/x-msmoney": {\n    "source": "apache",\n    "extensions": ["mny"]\n  },\n  "application/x-mspublisher": {\n    "source": "apache",\n    "extensions": ["pub"]\n  },\n  "application/x-msschedule": {\n    "source": "apache",\n    "extensions": ["scd"]\n  },\n  "application/x-msterminal": {\n    "source": "apache",\n    "extensions": ["trm"]\n  },\n  "application/x-mswrite": {\n    "source": "apache",\n    "extensions": ["wri"]\n  },\n  "application/x-netcdf": {\n    "source": "apache",\n    "extensions": ["nc","cdf"]\n  },\n  "application/x-ns-proxy-autoconfig": {\n    "compressible": true,\n    "extensions": ["pac"]\n  },\n  "application/x-nzb": {\n    "source": "apache",\n    "extensions": ["nzb"]\n  },\n  "application/x-perl": {\n    "source": "nginx",\n    "extensions": ["pl","pm"]\n  },\n  "application/x-pilot": {\n    "source": "nginx",\n    "extensions": ["prc","pdb"]\n  },\n  "application/x-pkcs12": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["p12","pfx"]\n  },\n  "application/x-pkcs7-certificates": {\n    "source": "apache",\n    "extensions": ["p7b","spc"]\n  },\n  "application/x-pkcs7-certreqresp": {\n    "source": "apache",\n    "extensions": ["p7r"]\n  },\n  "application/x-pki-message": {\n    "source": "iana"\n  },\n  "application/x-rar-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["rar"]\n  },\n  "application/x-redhat-package-manager": {\n    "source": "nginx",\n    "extensions": ["rpm"]\n  },\n  "application/x-research-info-systems": {\n    "source": "apache",\n    "extensions": ["ris"]\n  },\n  "application/x-sea": {\n    "source": "nginx",\n    "extensions": ["sea"]\n  },\n  "application/x-sh": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["sh"]\n  },\n  "application/x-shar": {\n    "source": "apache",\n    "extensions": ["shar"]\n  },\n  "application/x-shockwave-flash": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["swf"]\n  },\n  "application/x-silverlight-app": {\n    "source": "apache",\n    "extensions": ["xap"]\n  },\n  "application/x-sql": {\n    "source": "apache",\n    "extensions": ["sql"]\n  },\n  "application/x-stuffit": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["sit"]\n  },\n  "application/x-stuffitx": {\n    "source": "apache",\n    "extensions": ["sitx"]\n  },\n  "application/x-subrip": {\n    "source": "apache",\n    "extensions": ["srt"]\n  },\n  "application/x-sv4cpio": {\n    "source": "apache",\n    "extensions": ["sv4cpio"]\n  },\n  "application/x-sv4crc": {\n    "source": "apache",\n    "extensions": ["sv4crc"]\n  },\n  "application/x-t3vm-image": {\n    "source": "apache",\n    "extensions": ["t3"]\n  },\n  "application/x-tads": {\n    "source": "apache",\n    "extensions": ["gam"]\n  },\n  "application/x-tar": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["tar"]\n  },\n  "application/x-tcl": {\n    "source": "apache",\n    "extensions": ["tcl","tk"]\n  },\n  "application/x-tex": {\n    "source": "apache",\n    "extensions": ["tex"]\n  },\n  "application/x-tex-tfm": {\n    "source": "apache",\n    "extensions": ["tfm"]\n  },\n  "application/x-texinfo": {\n    "source": "apache",\n    "extensions": ["texinfo","texi"]\n  },\n  "application/x-tgif": {\n    "source": "apache",\n    "extensions": ["obj"]\n  },\n  "application/x-ustar": {\n    "source": "apache",\n    "extensions": ["ustar"]\n  },\n  "application/x-virtualbox-hdd": {\n    "compressible": true,\n    "extensions": ["hdd"]\n  },\n  "application/x-virtualbox-ova": {\n    "compressible": true,\n    "extensions": ["ova"]\n  },\n  "application/x-virtualbox-ovf": {\n    "compressible": true,\n    "extensions": ["ovf"]\n  },\n  "application/x-virtualbox-vbox": {\n    "compressible": true,\n    "extensions": ["vbox"]\n  },\n  "application/x-virtualbox-vbox-extpack": {\n    "compressible": false,\n    "extensions": ["vbox-extpack"]\n  },\n  "application/x-virtualbox-vdi": {\n    "compressible": true,\n    "extensions": ["vdi"]\n  },\n  "application/x-virtualbox-vhd": {\n    "compressible": true,\n    "extensions": ["vhd"]\n  },\n  "application/x-virtualbox-vmdk": {\n    "compressible": true,\n    "extensions": ["vmdk"]\n  },\n  "application/x-wais-source": {\n    "source": "apache",\n    "extensions": ["src"]\n  },\n  "application/x-web-app-manifest+json": {\n    "compressible": true,\n    "extensions": ["webapp"]\n  },\n  "application/x-www-form-urlencoded": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/x-x509-ca-cert": {\n    "source": "iana",\n    "extensions": ["der","crt","pem"]\n  },\n  "application/x-x509-ca-ra-cert": {\n    "source": "iana"\n  },\n  "application/x-x509-next-ca-cert": {\n    "source": "iana"\n  },\n  "application/x-xfig": {\n    "source": "apache",\n    "extensions": ["fig"]\n  },\n  "application/x-xliff+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/x-xpinstall": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["xpi"]\n  },\n  "application/x-xz": {\n    "source": "apache",\n    "extensions": ["xz"]\n  },\n  "application/x-zmachine": {\n    "source": "apache",\n    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]\n  },\n  "application/x400-bp": {\n    "source": "iana"\n  },\n  "application/xacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xaml+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xaml"]\n  },\n  "application/xcap-att+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xav"]\n  },\n  "application/xcap-caps+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xca"]\n  },\n  "application/xcap-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/xcap-el+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xel"]\n  },\n  "application/xcap-error+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcap-ns+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xns"]\n  },\n  "application/xcon-conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcon-conference-info-diff+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xenc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xenc"]\n  },\n  "application/xhtml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xhtml","xht"]\n  },\n  "application/xhtml-voice+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/xliff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml","xsl","xsd","rng"]\n  },\n  "application/xml-dtd": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dtd"]\n  },\n  "application/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "application/xml-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xmpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xop+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xop"]\n  },\n  "application/xproc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xpl"]\n  },\n  "application/xslt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xsl","xslt"]\n  },\n  "application/xspf+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xspf"]\n  },\n  "application/xv+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mxml","xhvml","xvml","xvm"]\n  },\n  "application/yang": {\n    "source": "iana",\n    "extensions": ["yang"]\n  },\n  "application/yang-data+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yin+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["yin"]\n  },\n  "application/zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["zip"]\n  },\n  "application/zlib": {\n    "source": "iana"\n  },\n  "application/zstd": {\n    "source": "iana"\n  },\n  "audio/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "audio/32kadpcm": {\n    "source": "iana"\n  },\n  "audio/3gpp": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["3gpp"]\n  },\n  "audio/3gpp2": {\n    "source": "iana"\n  },\n  "audio/aac": {\n    "source": "iana"\n  },\n  "audio/ac3": {\n    "source": "iana"\n  },\n  "audio/adpcm": {\n    "source": "apache",\n    "extensions": ["adp"]\n  },\n  "audio/amr": {\n    "source": "iana",\n    "extensions": ["amr"]\n  },\n  "audio/amr-wb": {\n    "source": "iana"\n  },\n  "audio/amr-wb+": {\n    "source": "iana"\n  },\n  "audio/aptx": {\n    "source": "iana"\n  },\n  "audio/asc": {\n    "source": "iana"\n  },\n  "audio/atrac-advanced-lossless": {\n    "source": "iana"\n  },\n  "audio/atrac-x": {\n    "source": "iana"\n  },\n  "audio/atrac3": {\n    "source": "iana"\n  },\n  "audio/basic": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["au","snd"]\n  },\n  "audio/bv16": {\n    "source": "iana"\n  },\n  "audio/bv32": {\n    "source": "iana"\n  },\n  "audio/clearmode": {\n    "source": "iana"\n  },\n  "audio/cn": {\n    "source": "iana"\n  },\n  "audio/dat12": {\n    "source": "iana"\n  },\n  "audio/dls": {\n    "source": "iana"\n  },\n  "audio/dsr-es201108": {\n    "source": "iana"\n  },\n  "audio/dsr-es202050": {\n    "source": "iana"\n  },\n  "audio/dsr-es202211": {\n    "source": "iana"\n  },\n  "audio/dsr-es202212": {\n    "source": "iana"\n  },\n  "audio/dv": {\n    "source": "iana"\n  },\n  "audio/dvi4": {\n    "source": "iana"\n  },\n  "audio/eac3": {\n    "source": "iana"\n  },\n  "audio/encaprtp": {\n    "source": "iana"\n  },\n  "audio/evrc": {\n    "source": "iana"\n  },\n  "audio/evrc-qcp": {\n    "source": "iana"\n  },\n  "audio/evrc0": {\n    "source": "iana"\n  },\n  "audio/evrc1": {\n    "source": "iana"\n  },\n  "audio/evrcb": {\n    "source": "iana"\n  },\n  "audio/evrcb0": {\n    "source": "iana"\n  },\n  "audio/evrcb1": {\n    "source": "iana"\n  },\n  "audio/evrcnw": {\n    "source": "iana"\n  },\n  "audio/evrcnw0": {\n    "source": "iana"\n  },\n  "audio/evrcnw1": {\n    "source": "iana"\n  },\n  "audio/evrcwb": {\n    "source": "iana"\n  },\n  "audio/evrcwb0": {\n    "source": "iana"\n  },\n  "audio/evrcwb1": {\n    "source": "iana"\n  },\n  "audio/evs": {\n    "source": "iana"\n  },\n  "audio/flexfec": {\n    "source": "iana"\n  },\n  "audio/fwdred": {\n    "source": "iana"\n  },\n  "audio/g711-0": {\n    "source": "iana"\n  },\n  "audio/g719": {\n    "source": "iana"\n  },\n  "audio/g722": {\n    "source": "iana"\n  },\n  "audio/g7221": {\n    "source": "iana"\n  },\n  "audio/g723": {\n    "source": "iana"\n  },\n  "audio/g726-16": {\n    "source": "iana"\n  },\n  "audio/g726-24": {\n    "source": "iana"\n  },\n  "audio/g726-32": {\n    "source": "iana"\n  },\n  "audio/g726-40": {\n    "source": "iana"\n  },\n  "audio/g728": {\n    "source": "iana"\n  },\n  "audio/g729": {\n    "source": "iana"\n  },\n  "audio/g7291": {\n    "source": "iana"\n  },\n  "audio/g729d": {\n    "source": "iana"\n  },\n  "audio/g729e": {\n    "source": "iana"\n  },\n  "audio/gsm": {\n    "source": "iana"\n  },\n  "audio/gsm-efr": {\n    "source": "iana"\n  },\n  "audio/gsm-hr-08": {\n    "source": "iana"\n  },\n  "audio/ilbc": {\n    "source": "iana"\n  },\n  "audio/ip-mr_v2.5": {\n    "source": "iana"\n  },\n  "audio/isac": {\n    "source": "apache"\n  },\n  "audio/l16": {\n    "source": "iana"\n  },\n  "audio/l20": {\n    "source": "iana"\n  },\n  "audio/l24": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/l8": {\n    "source": "iana"\n  },\n  "audio/lpc": {\n    "source": "iana"\n  },\n  "audio/melp": {\n    "source": "iana"\n  },\n  "audio/melp1200": {\n    "source": "iana"\n  },\n  "audio/melp2400": {\n    "source": "iana"\n  },\n  "audio/melp600": {\n    "source": "iana"\n  },\n  "audio/mhas": {\n    "source": "iana"\n  },\n  "audio/midi": {\n    "source": "apache",\n    "extensions": ["mid","midi","kar","rmi"]\n  },\n  "audio/mobile-xmf": {\n    "source": "iana",\n    "extensions": ["mxmf"]\n  },\n  "audio/mp3": {\n    "compressible": false,\n    "extensions": ["mp3"]\n  },\n  "audio/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["m4a","mp4a"]\n  },\n  "audio/mp4a-latm": {\n    "source": "iana"\n  },\n  "audio/mpa": {\n    "source": "iana"\n  },\n  "audio/mpa-robust": {\n    "source": "iana"\n  },\n  "audio/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]\n  },\n  "audio/mpeg4-generic": {\n    "source": "iana"\n  },\n  "audio/musepack": {\n    "source": "apache"\n  },\n  "audio/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["oga","ogg","spx","opus"]\n  },\n  "audio/opus": {\n    "source": "iana"\n  },\n  "audio/parityfec": {\n    "source": "iana"\n  },\n  "audio/pcma": {\n    "source": "iana"\n  },\n  "audio/pcma-wb": {\n    "source": "iana"\n  },\n  "audio/pcmu": {\n    "source": "iana"\n  },\n  "audio/pcmu-wb": {\n    "source": "iana"\n  },\n  "audio/prs.sid": {\n    "source": "iana"\n  },\n  "audio/qcelp": {\n    "source": "iana"\n  },\n  "audio/raptorfec": {\n    "source": "iana"\n  },\n  "audio/red": {\n    "source": "iana"\n  },\n  "audio/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "audio/rtp-midi": {\n    "source": "iana"\n  },\n  "audio/rtploopback": {\n    "source": "iana"\n  },\n  "audio/rtx": {\n    "source": "iana"\n  },\n  "audio/s3m": {\n    "source": "apache",\n    "extensions": ["s3m"]\n  },\n  "audio/scip": {\n    "source": "iana"\n  },\n  "audio/silk": {\n    "source": "apache",\n    "extensions": ["sil"]\n  },\n  "audio/smv": {\n    "source": "iana"\n  },\n  "audio/smv-qcp": {\n    "source": "iana"\n  },\n  "audio/smv0": {\n    "source": "iana"\n  },\n  "audio/sofa": {\n    "source": "iana"\n  },\n  "audio/sp-midi": {\n    "source": "iana"\n  },\n  "audio/speex": {\n    "source": "iana"\n  },\n  "audio/t140c": {\n    "source": "iana"\n  },\n  "audio/t38": {\n    "source": "iana"\n  },\n  "audio/telephone-event": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp_bb": {\n    "source": "iana"\n  },\n  "audio/tone": {\n    "source": "iana"\n  },\n  "audio/tsvcis": {\n    "source": "iana"\n  },\n  "audio/uemclip": {\n    "source": "iana"\n  },\n  "audio/ulpfec": {\n    "source": "iana"\n  },\n  "audio/usac": {\n    "source": "iana"\n  },\n  "audio/vdvi": {\n    "source": "iana"\n  },\n  "audio/vmr-wb": {\n    "source": "iana"\n  },\n  "audio/vnd.3gpp.iufp": {\n    "source": "iana"\n  },\n  "audio/vnd.4sb": {\n    "source": "iana"\n  },\n  "audio/vnd.audiokoz": {\n    "source": "iana"\n  },\n  "audio/vnd.celp": {\n    "source": "iana"\n  },\n  "audio/vnd.cisco.nse": {\n    "source": "iana"\n  },\n  "audio/vnd.cmles.radio-events": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.anp1": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.inf1": {\n    "source": "iana"\n  },\n  "audio/vnd.dece.audio": {\n    "source": "iana",\n    "extensions": ["uva","uvva"]\n  },\n  "audio/vnd.digital-winds": {\n    "source": "iana",\n    "extensions": ["eol"]\n  },\n  "audio/vnd.dlna.adts": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mlp": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mps": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2x": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2z": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pulse.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dra": {\n    "source": "iana",\n    "extensions": ["dra"]\n  },\n  "audio/vnd.dts": {\n    "source": "iana",\n    "extensions": ["dts"]\n  },\n  "audio/vnd.dts.hd": {\n    "source": "iana",\n    "extensions": ["dtshd"]\n  },\n  "audio/vnd.dts.uhd": {\n    "source": "iana"\n  },\n  "audio/vnd.dvb.file": {\n    "source": "iana"\n  },\n  "audio/vnd.everad.plj": {\n    "source": "iana"\n  },\n  "audio/vnd.hns.audio": {\n    "source": "iana"\n  },\n  "audio/vnd.lucent.voice": {\n    "source": "iana",\n    "extensions": ["lvp"]\n  },\n  "audio/vnd.ms-playready.media.pya": {\n    "source": "iana",\n    "extensions": ["pya"]\n  },\n  "audio/vnd.nokia.mobile-xmf": {\n    "source": "iana"\n  },\n  "audio/vnd.nortel.vbk": {\n    "source": "iana"\n  },\n  "audio/vnd.nuera.ecelp4800": {\n    "source": "iana",\n    "extensions": ["ecelp4800"]\n  },\n  "audio/vnd.nuera.ecelp7470": {\n    "source": "iana",\n    "extensions": ["ecelp7470"]\n  },\n  "audio/vnd.nuera.ecelp9600": {\n    "source": "iana",\n    "extensions": ["ecelp9600"]\n  },\n  "audio/vnd.octel.sbc": {\n    "source": "iana"\n  },\n  "audio/vnd.presonus.multitrack": {\n    "source": "iana"\n  },\n  "audio/vnd.qcelp": {\n    "source": "iana"\n  },\n  "audio/vnd.rhetorex.32kadpcm": {\n    "source": "iana"\n  },\n  "audio/vnd.rip": {\n    "source": "iana",\n    "extensions": ["rip"]\n  },\n  "audio/vnd.rn-realaudio": {\n    "compressible": false\n  },\n  "audio/vnd.sealedmedia.softseal.mpeg": {\n    "source": "iana"\n  },\n  "audio/vnd.vmx.cvsd": {\n    "source": "iana"\n  },\n  "audio/vnd.wave": {\n    "compressible": false\n  },\n  "audio/vorbis": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/vorbis-config": {\n    "source": "iana"\n  },\n  "audio/wav": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/wave": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["weba"]\n  },\n  "audio/x-aac": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["aac"]\n  },\n  "audio/x-aiff": {\n    "source": "apache",\n    "extensions": ["aif","aiff","aifc"]\n  },\n  "audio/x-caf": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["caf"]\n  },\n  "audio/x-flac": {\n    "source": "apache",\n    "extensions": ["flac"]\n  },\n  "audio/x-m4a": {\n    "source": "nginx",\n    "extensions": ["m4a"]\n  },\n  "audio/x-matroska": {\n    "source": "apache",\n    "extensions": ["mka"]\n  },\n  "audio/x-mpegurl": {\n    "source": "apache",\n    "extensions": ["m3u"]\n  },\n  "audio/x-ms-wax": {\n    "source": "apache",\n    "extensions": ["wax"]\n  },\n  "audio/x-ms-wma": {\n    "source": "apache",\n    "extensions": ["wma"]\n  },\n  "audio/x-pn-realaudio": {\n    "source": "apache",\n    "extensions": ["ram","ra"]\n  },\n  "audio/x-pn-realaudio-plugin": {\n    "source": "apache",\n    "extensions": ["rmp"]\n  },\n  "audio/x-realaudio": {\n    "source": "nginx",\n    "extensions": ["ra"]\n  },\n  "audio/x-tta": {\n    "source": "apache"\n  },\n  "audio/x-wav": {\n    "source": "apache",\n    "extensions": ["wav"]\n  },\n  "audio/xm": {\n    "source": "apache",\n    "extensions": ["xm"]\n  },\n  "chemical/x-cdx": {\n    "source": "apache",\n    "extensions": ["cdx"]\n  },\n  "chemical/x-cif": {\n    "source": "apache",\n    "extensions": ["cif"]\n  },\n  "chemical/x-cmdf": {\n    "source": "apache",\n    "extensions": ["cmdf"]\n  },\n  "chemical/x-cml": {\n    "source": "apache",\n    "extensions": ["cml"]\n  },\n  "chemical/x-csml": {\n    "source": "apache",\n    "extensions": ["csml"]\n  },\n  "chemical/x-pdb": {\n    "source": "apache"\n  },\n  "chemical/x-xyz": {\n    "source": "apache",\n    "extensions": ["xyz"]\n  },\n  "font/collection": {\n    "source": "iana",\n    "extensions": ["ttc"]\n  },\n  "font/otf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["otf"]\n  },\n  "font/sfnt": {\n    "source": "iana"\n  },\n  "font/ttf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttf"]\n  },\n  "font/woff": {\n    "source": "iana",\n    "extensions": ["woff"]\n  },\n  "font/woff2": {\n    "source": "iana",\n    "extensions": ["woff2"]\n  },\n  "image/aces": {\n    "source": "iana",\n    "extensions": ["exr"]\n  },\n  "image/apng": {\n    "compressible": false,\n    "extensions": ["apng"]\n  },\n  "image/avci": {\n    "source": "iana"\n  },\n  "image/avcs": {\n    "source": "iana"\n  },\n  "image/avif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["avif"]\n  },\n  "image/bmp": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/cgm": {\n    "source": "iana",\n    "extensions": ["cgm"]\n  },\n  "image/dicom-rle": {\n    "source": "iana",\n    "extensions": ["drle"]\n  },\n  "image/emf": {\n    "source": "iana",\n    "extensions": ["emf"]\n  },\n  "image/fits": {\n    "source": "iana",\n    "extensions": ["fits"]\n  },\n  "image/g3fax": {\n    "source": "iana",\n    "extensions": ["g3"]\n  },\n  "image/gif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gif"]\n  },\n  "image/heic": {\n    "source": "iana",\n    "extensions": ["heic"]\n  },\n  "image/heic-sequence": {\n    "source": "iana",\n    "extensions": ["heics"]\n  },\n  "image/heif": {\n    "source": "iana",\n    "extensions": ["heif"]\n  },\n  "image/heif-sequence": {\n    "source": "iana",\n    "extensions": ["heifs"]\n  },\n  "image/hej2k": {\n    "source": "iana",\n    "extensions": ["hej2"]\n  },\n  "image/hsj2": {\n    "source": "iana",\n    "extensions": ["hsj2"]\n  },\n  "image/ief": {\n    "source": "iana",\n    "extensions": ["ief"]\n  },\n  "image/jls": {\n    "source": "iana",\n    "extensions": ["jls"]\n  },\n  "image/jp2": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jp2","jpg2"]\n  },\n  "image/jpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpeg","jpg","jpe"]\n  },\n  "image/jph": {\n    "source": "iana",\n    "extensions": ["jph"]\n  },\n  "image/jphc": {\n    "source": "iana",\n    "extensions": ["jhc"]\n  },\n  "image/jpm": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpm"]\n  },\n  "image/jpx": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpx","jpf"]\n  },\n  "image/jxr": {\n    "source": "iana",\n    "extensions": ["jxr"]\n  },\n  "image/jxra": {\n    "source": "iana",\n    "extensions": ["jxra"]\n  },\n  "image/jxrs": {\n    "source": "iana",\n    "extensions": ["jxrs"]\n  },\n  "image/jxs": {\n    "source": "iana",\n    "extensions": ["jxs"]\n  },\n  "image/jxsc": {\n    "source": "iana",\n    "extensions": ["jxsc"]\n  },\n  "image/jxsi": {\n    "source": "iana",\n    "extensions": ["jxsi"]\n  },\n  "image/jxss": {\n    "source": "iana",\n    "extensions": ["jxss"]\n  },\n  "image/ktx": {\n    "source": "iana",\n    "extensions": ["ktx"]\n  },\n  "image/ktx2": {\n    "source": "iana",\n    "extensions": ["ktx2"]\n  },\n  "image/naplps": {\n    "source": "iana"\n  },\n  "image/pjpeg": {\n    "compressible": false\n  },\n  "image/png": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["png"]\n  },\n  "image/prs.btif": {\n    "source": "iana",\n    "extensions": ["btif"]\n  },\n  "image/prs.pti": {\n    "source": "iana",\n    "extensions": ["pti"]\n  },\n  "image/pwg-raster": {\n    "source": "iana"\n  },\n  "image/sgi": {\n    "source": "apache",\n    "extensions": ["sgi"]\n  },\n  "image/svg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["svg","svgz"]\n  },\n  "image/t38": {\n    "source": "iana",\n    "extensions": ["t38"]\n  },\n  "image/tiff": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["tif","tiff"]\n  },\n  "image/tiff-fx": {\n    "source": "iana",\n    "extensions": ["tfx"]\n  },\n  "image/vnd.adobe.photoshop": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["psd"]\n  },\n  "image/vnd.airzip.accelerator.azv": {\n    "source": "iana",\n    "extensions": ["azv"]\n  },\n  "image/vnd.cns.inf2": {\n    "source": "iana"\n  },\n  "image/vnd.dece.graphic": {\n    "source": "iana",\n    "extensions": ["uvi","uvvi","uvg","uvvg"]\n  },\n  "image/vnd.djvu": {\n    "source": "iana",\n    "extensions": ["djvu","djv"]\n  },\n  "image/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "image/vnd.dwg": {\n    "source": "iana",\n    "extensions": ["dwg"]\n  },\n  "image/vnd.dxf": {\n    "source": "iana",\n    "extensions": ["dxf"]\n  },\n  "image/vnd.fastbidsheet": {\n    "source": "iana",\n    "extensions": ["fbs"]\n  },\n  "image/vnd.fpx": {\n    "source": "iana",\n    "extensions": ["fpx"]\n  },\n  "image/vnd.fst": {\n    "source": "iana",\n    "extensions": ["fst"]\n  },\n  "image/vnd.fujixerox.edmics-mmr": {\n    "source": "iana",\n    "extensions": ["mmr"]\n  },\n  "image/vnd.fujixerox.edmics-rlc": {\n    "source": "iana",\n    "extensions": ["rlc"]\n  },\n  "image/vnd.globalgraphics.pgb": {\n    "source": "iana"\n  },\n  "image/vnd.microsoft.icon": {\n    "source": "iana",\n    "extensions": ["ico"]\n  },\n  "image/vnd.mix": {\n    "source": "iana"\n  },\n  "image/vnd.mozilla.apng": {\n    "source": "iana"\n  },\n  "image/vnd.ms-dds": {\n    "extensions": ["dds"]\n  },\n  "image/vnd.ms-modi": {\n    "source": "iana",\n    "extensions": ["mdi"]\n  },\n  "image/vnd.ms-photo": {\n    "source": "apache",\n    "extensions": ["wdp"]\n  },\n  "image/vnd.net-fpx": {\n    "source": "iana",\n    "extensions": ["npx"]\n  },\n  "image/vnd.pco.b16": {\n    "source": "iana",\n    "extensions": ["b16"]\n  },\n  "image/vnd.radiance": {\n    "source": "iana"\n  },\n  "image/vnd.sealed.png": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.gif": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.jpg": {\n    "source": "iana"\n  },\n  "image/vnd.svf": {\n    "source": "iana"\n  },\n  "image/vnd.tencent.tap": {\n    "source": "iana",\n    "extensions": ["tap"]\n  },\n  "image/vnd.valve.source.texture": {\n    "source": "iana",\n    "extensions": ["vtf"]\n  },\n  "image/vnd.wap.wbmp": {\n    "source": "iana",\n    "extensions": ["wbmp"]\n  },\n  "image/vnd.xiff": {\n    "source": "iana",\n    "extensions": ["xif"]\n  },\n  "image/vnd.zbrush.pcx": {\n    "source": "iana",\n    "extensions": ["pcx"]\n  },\n  "image/webp": {\n    "source": "apache",\n    "extensions": ["webp"]\n  },\n  "image/wmf": {\n    "source": "iana",\n    "extensions": ["wmf"]\n  },\n  "image/x-3ds": {\n    "source": "apache",\n    "extensions": ["3ds"]\n  },\n  "image/x-cmu-raster": {\n    "source": "apache",\n    "extensions": ["ras"]\n  },\n  "image/x-cmx": {\n    "source": "apache",\n    "extensions": ["cmx"]\n  },\n  "image/x-freehand": {\n    "source": "apache",\n    "extensions": ["fh","fhc","fh4","fh5","fh7"]\n  },\n  "image/x-icon": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ico"]\n  },\n  "image/x-jng": {\n    "source": "nginx",\n    "extensions": ["jng"]\n  },\n  "image/x-mrsid-image": {\n    "source": "apache",\n    "extensions": ["sid"]\n  },\n  "image/x-ms-bmp": {\n    "source": "nginx",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/x-pcx": {\n    "source": "apache",\n    "extensions": ["pcx"]\n  },\n  "image/x-pict": {\n    "source": "apache",\n    "extensions": ["pic","pct"]\n  },\n  "image/x-portable-anymap": {\n    "source": "apache",\n    "extensions": ["pnm"]\n  },\n  "image/x-portable-bitmap": {\n    "source": "apache",\n    "extensions": ["pbm"]\n  },\n  "image/x-portable-graymap": {\n    "source": "apache",\n    "extensions": ["pgm"]\n  },\n  "image/x-portable-pixmap": {\n    "source": "apache",\n    "extensions": ["ppm"]\n  },\n  "image/x-rgb": {\n    "source": "apache",\n    "extensions": ["rgb"]\n  },\n  "image/x-tga": {\n    "source": "apache",\n    "extensions": ["tga"]\n  },\n  "image/x-xbitmap": {\n    "source": "apache",\n    "extensions": ["xbm"]\n  },\n  "image/x-xcf": {\n    "compressible": false\n  },\n  "image/x-xpixmap": {\n    "source": "apache",\n    "extensions": ["xpm"]\n  },\n  "image/x-xwindowdump": {\n    "source": "apache",\n    "extensions": ["xwd"]\n  },\n  "message/cpim": {\n    "source": "iana"\n  },\n  "message/delivery-status": {\n    "source": "iana"\n  },\n  "message/disposition-notification": {\n    "source": "iana",\n    "extensions": [\n      "disposition-notification"\n    ]\n  },\n  "message/external-body": {\n    "source": "iana"\n  },\n  "message/feedback-report": {\n    "source": "iana"\n  },\n  "message/global": {\n    "source": "iana",\n    "extensions": ["u8msg"]\n  },\n  "message/global-delivery-status": {\n    "source": "iana",\n    "extensions": ["u8dsn"]\n  },\n  "message/global-disposition-notification": {\n    "source": "iana",\n    "extensions": ["u8mdn"]\n  },\n  "message/global-headers": {\n    "source": "iana",\n    "extensions": ["u8hdr"]\n  },\n  "message/http": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/imdn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "message/news": {\n    "source": "iana"\n  },\n  "message/partial": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/rfc822": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eml","mime"]\n  },\n  "message/s-http": {\n    "source": "iana"\n  },\n  "message/sip": {\n    "source": "iana"\n  },\n  "message/sipfrag": {\n    "source": "iana"\n  },\n  "message/tracking-status": {\n    "source": "iana"\n  },\n  "message/vnd.si.simp": {\n    "source": "iana"\n  },\n  "message/vnd.wfa.wsc": {\n    "source": "iana",\n    "extensions": ["wsc"]\n  },\n  "model/3mf": {\n    "source": "iana",\n    "extensions": ["3mf"]\n  },\n  "model/e57": {\n    "source": "iana"\n  },\n  "model/gltf+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gltf"]\n  },\n  "model/gltf-binary": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["glb"]\n  },\n  "model/iges": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["igs","iges"]\n  },\n  "model/mesh": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["msh","mesh","silo"]\n  },\n  "model/mtl": {\n    "source": "iana",\n    "extensions": ["mtl"]\n  },\n  "model/obj": {\n    "source": "iana",\n    "extensions": ["obj"]\n  },\n  "model/stl": {\n    "source": "iana",\n    "extensions": ["stl"]\n  },\n  "model/vnd.collada+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dae"]\n  },\n  "model/vnd.dwf": {\n    "source": "iana",\n    "extensions": ["dwf"]\n  },\n  "model/vnd.flatland.3dml": {\n    "source": "iana"\n  },\n  "model/vnd.gdl": {\n    "source": "iana",\n    "extensions": ["gdl"]\n  },\n  "model/vnd.gs-gdl": {\n    "source": "apache"\n  },\n  "model/vnd.gs.gdl": {\n    "source": "iana"\n  },\n  "model/vnd.gtw": {\n    "source": "iana",\n    "extensions": ["gtw"]\n  },\n  "model/vnd.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "model/vnd.mts": {\n    "source": "iana",\n    "extensions": ["mts"]\n  },\n  "model/vnd.opengex": {\n    "source": "iana",\n    "extensions": ["ogex"]\n  },\n  "model/vnd.parasolid.transmit.binary": {\n    "source": "iana",\n    "extensions": ["x_b"]\n  },\n  "model/vnd.parasolid.transmit.text": {\n    "source": "iana",\n    "extensions": ["x_t"]\n  },\n  "model/vnd.rosette.annotated-data-model": {\n    "source": "iana"\n  },\n  "model/vnd.sap.vds": {\n    "source": "iana",\n    "extensions": ["vds"]\n  },\n  "model/vnd.usdz+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["usdz"]\n  },\n  "model/vnd.valve.source.compiled-map": {\n    "source": "iana",\n    "extensions": ["bsp"]\n  },\n  "model/vnd.vtu": {\n    "source": "iana",\n    "extensions": ["vtu"]\n  },\n  "model/vrml": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["wrl","vrml"]\n  },\n  "model/x3d+binary": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3db","x3dbz"]\n  },\n  "model/x3d+fastinfoset": {\n    "source": "iana",\n    "extensions": ["x3db"]\n  },\n  "model/x3d+vrml": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3dv","x3dvz"]\n  },\n  "model/x3d+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["x3d","x3dz"]\n  },\n  "model/x3d-vrml": {\n    "source": "iana",\n    "extensions": ["x3dv"]\n  },\n  "multipart/alternative": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/appledouble": {\n    "source": "iana"\n  },\n  "multipart/byteranges": {\n    "source": "iana"\n  },\n  "multipart/digest": {\n    "source": "iana"\n  },\n  "multipart/encrypted": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/form-data": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/header-set": {\n    "source": "iana"\n  },\n  "multipart/mixed": {\n    "source": "iana"\n  },\n  "multipart/multilingual": {\n    "source": "iana"\n  },\n  "multipart/parallel": {\n    "source": "iana"\n  },\n  "multipart/related": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/report": {\n    "source": "iana"\n  },\n  "multipart/signed": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/vnd.bint.med-plus": {\n    "source": "iana"\n  },\n  "multipart/voice-message": {\n    "source": "iana"\n  },\n  "multipart/x-mixed-replace": {\n    "source": "iana"\n  },\n  "text/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "text/cache-manifest": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["appcache","manifest"]\n  },\n  "text/calendar": {\n    "source": "iana",\n    "extensions": ["ics","ifb"]\n  },\n  "text/calender": {\n    "compressible": true\n  },\n  "text/cmd": {\n    "compressible": true\n  },\n  "text/coffeescript": {\n    "extensions": ["coffee","litcoffee"]\n  },\n  "text/cql": {\n    "source": "iana"\n  },\n  "text/cql-expression": {\n    "source": "iana"\n  },\n  "text/cql-identifier": {\n    "source": "iana"\n  },\n  "text/css": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["css"]\n  },\n  "text/csv": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csv"]\n  },\n  "text/csv-schema": {\n    "source": "iana"\n  },\n  "text/directory": {\n    "source": "iana"\n  },\n  "text/dns": {\n    "source": "iana"\n  },\n  "text/ecmascript": {\n    "source": "iana"\n  },\n  "text/encaprtp": {\n    "source": "iana"\n  },\n  "text/enriched": {\n    "source": "iana"\n  },\n  "text/fhirpath": {\n    "source": "iana"\n  },\n  "text/flexfec": {\n    "source": "iana"\n  },\n  "text/fwdred": {\n    "source": "iana"\n  },\n  "text/gff3": {\n    "source": "iana"\n  },\n  "text/grammar-ref-list": {\n    "source": "iana"\n  },\n  "text/html": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["html","htm","shtml"]\n  },\n  "text/jade": {\n    "extensions": ["jade"]\n  },\n  "text/javascript": {\n    "source": "iana",\n    "compressible": true\n  },\n  "text/jcr-cnd": {\n    "source": "iana"\n  },\n  "text/jsx": {\n    "compressible": true,\n    "extensions": ["jsx"]\n  },\n  "text/less": {\n    "compressible": true,\n    "extensions": ["less"]\n  },\n  "text/markdown": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["markdown","md"]\n  },\n  "text/mathml": {\n    "source": "nginx",\n    "extensions": ["mml"]\n  },\n  "text/mdx": {\n    "compressible": true,\n    "extensions": ["mdx"]\n  },\n  "text/mizar": {\n    "source": "iana"\n  },\n  "text/n3": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["n3"]\n  },\n  "text/parameters": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/parityfec": {\n    "source": "iana"\n  },\n  "text/plain": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["txt","text","conf","def","list","log","in","ini"]\n  },\n  "text/provenance-notation": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/prs.fallenstein.rst": {\n    "source": "iana"\n  },\n  "text/prs.lines.tag": {\n    "source": "iana",\n    "extensions": ["dsc"]\n  },\n  "text/prs.prop.logic": {\n    "source": "iana"\n  },\n  "text/raptorfec": {\n    "source": "iana"\n  },\n  "text/red": {\n    "source": "iana"\n  },\n  "text/rfc822-headers": {\n    "source": "iana"\n  },\n  "text/richtext": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtx"]\n  },\n  "text/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "text/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "text/rtploopback": {\n    "source": "iana"\n  },\n  "text/rtx": {\n    "source": "iana"\n  },\n  "text/sgml": {\n    "source": "iana",\n    "extensions": ["sgml","sgm"]\n  },\n  "text/shaclc": {\n    "source": "iana"\n  },\n  "text/shex": {\n    "extensions": ["shex"]\n  },\n  "text/slim": {\n    "extensions": ["slim","slm"]\n  },\n  "text/spdx": {\n    "source": "iana",\n    "extensions": ["spdx"]\n  },\n  "text/strings": {\n    "source": "iana"\n  },\n  "text/stylus": {\n    "extensions": ["stylus","styl"]\n  },\n  "text/t140": {\n    "source": "iana"\n  },\n  "text/tab-separated-values": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tsv"]\n  },\n  "text/troff": {\n    "source": "iana",\n    "extensions": ["t","tr","roff","man","me","ms"]\n  },\n  "text/turtle": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["ttl"]\n  },\n  "text/ulpfec": {\n    "source": "iana"\n  },\n  "text/uri-list": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uri","uris","urls"]\n  },\n  "text/vcard": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vcard"]\n  },\n  "text/vnd.a": {\n    "source": "iana"\n  },\n  "text/vnd.abc": {\n    "source": "iana"\n  },\n  "text/vnd.ascii-art": {\n    "source": "iana"\n  },\n  "text/vnd.curl": {\n    "source": "iana",\n    "extensions": ["curl"]\n  },\n  "text/vnd.curl.dcurl": {\n    "source": "apache",\n    "extensions": ["dcurl"]\n  },\n  "text/vnd.curl.mcurl": {\n    "source": "apache",\n    "extensions": ["mcurl"]\n  },\n  "text/vnd.curl.scurl": {\n    "source": "apache",\n    "extensions": ["scurl"]\n  },\n  "text/vnd.debian.copyright": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.dmclientscript": {\n    "source": "iana"\n  },\n  "text/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "text/vnd.esmertec.theme-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.ficlab.flt": {\n    "source": "iana"\n  },\n  "text/vnd.fly": {\n    "source": "iana",\n    "extensions": ["fly"]\n  },\n  "text/vnd.fmi.flexstor": {\n    "source": "iana",\n    "extensions": ["flx"]\n  },\n  "text/vnd.gml": {\n    "source": "iana"\n  },\n  "text/vnd.graphviz": {\n    "source": "iana",\n    "extensions": ["gv"]\n  },\n  "text/vnd.hans": {\n    "source": "iana"\n  },\n  "text/vnd.hgl": {\n    "source": "iana"\n  },\n  "text/vnd.in3d.3dml": {\n    "source": "iana",\n    "extensions": ["3dml"]\n  },\n  "text/vnd.in3d.spot": {\n    "source": "iana",\n    "extensions": ["spot"]\n  },\n  "text/vnd.iptc.newsml": {\n    "source": "iana"\n  },\n  "text/vnd.iptc.nitf": {\n    "source": "iana"\n  },\n  "text/vnd.latex-z": {\n    "source": "iana"\n  },\n  "text/vnd.motorola.reflex": {\n    "source": "iana"\n  },\n  "text/vnd.ms-mediapackage": {\n    "source": "iana"\n  },\n  "text/vnd.net2phone.commcenter.command": {\n    "source": "iana"\n  },\n  "text/vnd.radisys.msml-basic-layout": {\n    "source": "iana"\n  },\n  "text/vnd.senx.warpscript": {\n    "source": "iana"\n  },\n  "text/vnd.si.uricatalogue": {\n    "source": "iana"\n  },\n  "text/vnd.sosi": {\n    "source": "iana"\n  },\n  "text/vnd.sun.j2me.app-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["jad"]\n  },\n  "text/vnd.trolltech.linguist": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.wap.si": {\n    "source": "iana"\n  },\n  "text/vnd.wap.sl": {\n    "source": "iana"\n  },\n  "text/vnd.wap.wml": {\n    "source": "iana",\n    "extensions": ["wml"]\n  },\n  "text/vnd.wap.wmlscript": {\n    "source": "iana",\n    "extensions": ["wmls"]\n  },\n  "text/vtt": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["vtt"]\n  },\n  "text/x-asm": {\n    "source": "apache",\n    "extensions": ["s","asm"]\n  },\n  "text/x-c": {\n    "source": "apache",\n    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]\n  },\n  "text/x-component": {\n    "source": "nginx",\n    "extensions": ["htc"]\n  },\n  "text/x-fortran": {\n    "source": "apache",\n    "extensions": ["f","for","f77","f90"]\n  },\n  "text/x-gwt-rpc": {\n    "compressible": true\n  },\n  "text/x-handlebars-template": {\n    "extensions": ["hbs"]\n  },\n  "text/x-java-source": {\n    "source": "apache",\n    "extensions": ["java"]\n  },\n  "text/x-jquery-tmpl": {\n    "compressible": true\n  },\n  "text/x-lua": {\n    "extensions": ["lua"]\n  },\n  "text/x-markdown": {\n    "compressible": true,\n    "extensions": ["mkd"]\n  },\n  "text/x-nfo": {\n    "source": "apache",\n    "extensions": ["nfo"]\n  },\n  "text/x-opml": {\n    "source": "apache",\n    "extensions": ["opml"]\n  },\n  "text/x-org": {\n    "compressible": true,\n    "extensions": ["org"]\n  },\n  "text/x-pascal": {\n    "source": "apache",\n    "extensions": ["p","pas"]\n  },\n  "text/x-processing": {\n    "compressible": true,\n    "extensions": ["pde"]\n  },\n  "text/x-sass": {\n    "extensions": ["sass"]\n  },\n  "text/x-scss": {\n    "extensions": ["scss"]\n  },\n  "text/x-setext": {\n    "source": "apache",\n    "extensions": ["etx"]\n  },\n  "text/x-sfv": {\n    "source": "apache",\n    "extensions": ["sfv"]\n  },\n  "text/x-suse-ymp": {\n    "compressible": true,\n    "extensions": ["ymp"]\n  },\n  "text/x-uuencode": {\n    "source": "apache",\n    "extensions": ["uu"]\n  },\n  "text/x-vcalendar": {\n    "source": "apache",\n    "extensions": ["vcs"]\n  },\n  "text/x-vcard": {\n    "source": "apache",\n    "extensions": ["vcf"]\n  },\n  "text/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml"]\n  },\n  "text/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "text/yaml": {\n    "extensions": ["yaml","yml"]\n  },\n  "video/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "video/3gpp": {\n    "source": "iana",\n    "extensions": ["3gp","3gpp"]\n  },\n  "video/3gpp-tt": {\n    "source": "iana"\n  },\n  "video/3gpp2": {\n    "source": "iana",\n    "extensions": ["3g2"]\n  },\n  "video/av1": {\n    "source": "iana"\n  },\n  "video/bmpeg": {\n    "source": "iana"\n  },\n  "video/bt656": {\n    "source": "iana"\n  },\n  "video/celb": {\n    "source": "iana"\n  },\n  "video/dv": {\n    "source": "iana"\n  },\n  "video/encaprtp": {\n    "source": "iana"\n  },\n  "video/ffv1": {\n    "source": "iana"\n  },\n  "video/flexfec": {\n    "source": "iana"\n  },\n  "video/h261": {\n    "source": "iana",\n    "extensions": ["h261"]\n  },\n  "video/h263": {\n    "source": "iana",\n    "extensions": ["h263"]\n  },\n  "video/h263-1998": {\n    "source": "iana"\n  },\n  "video/h263-2000": {\n    "source": "iana"\n  },\n  "video/h264": {\n    "source": "iana",\n    "extensions": ["h264"]\n  },\n  "video/h264-rcdo": {\n    "source": "iana"\n  },\n  "video/h264-svc": {\n    "source": "iana"\n  },\n  "video/h265": {\n    "source": "iana"\n  },\n  "video/iso.segment": {\n    "source": "iana",\n    "extensions": ["m4s"]\n  },\n  "video/jpeg": {\n    "source": "iana",\n    "extensions": ["jpgv"]\n  },\n  "video/jpeg2000": {\n    "source": "iana"\n  },\n  "video/jpm": {\n    "source": "apache",\n    "extensions": ["jpm","jpgm"]\n  },\n  "video/mj2": {\n    "source": "iana",\n    "extensions": ["mj2","mjp2"]\n  },\n  "video/mp1s": {\n    "source": "iana"\n  },\n  "video/mp2p": {\n    "source": "iana"\n  },\n  "video/mp2t": {\n    "source": "iana",\n    "extensions": ["ts"]\n  },\n  "video/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mp4","mp4v","mpg4"]\n  },\n  "video/mp4v-es": {\n    "source": "iana"\n  },\n  "video/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]\n  },\n  "video/mpeg4-generic": {\n    "source": "iana"\n  },\n  "video/mpv": {\n    "source": "iana"\n  },\n  "video/nv": {\n    "source": "iana"\n  },\n  "video/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogv"]\n  },\n  "video/parityfec": {\n    "source": "iana"\n  },\n  "video/pointer": {\n    "source": "iana"\n  },\n  "video/quicktime": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["qt","mov"]\n  },\n  "video/raptorfec": {\n    "source": "iana"\n  },\n  "video/raw": {\n    "source": "iana"\n  },\n  "video/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "video/rtploopback": {\n    "source": "iana"\n  },\n  "video/rtx": {\n    "source": "iana"\n  },\n  "video/scip": {\n    "source": "iana"\n  },\n  "video/smpte291": {\n    "source": "iana"\n  },\n  "video/smpte292m": {\n    "source": "iana"\n  },\n  "video/ulpfec": {\n    "source": "iana"\n  },\n  "video/vc1": {\n    "source": "iana"\n  },\n  "video/vc2": {\n    "source": "iana"\n  },\n  "video/vnd.cctv": {\n    "source": "iana"\n  },\n  "video/vnd.dece.hd": {\n    "source": "iana",\n    "extensions": ["uvh","uvvh"]\n  },\n  "video/vnd.dece.mobile": {\n    "source": "iana",\n    "extensions": ["uvm","uvvm"]\n  },\n  "video/vnd.dece.mp4": {\n    "source": "iana"\n  },\n  "video/vnd.dece.pd": {\n    "source": "iana",\n    "extensions": ["uvp","uvvp"]\n  },\n  "video/vnd.dece.sd": {\n    "source": "iana",\n    "extensions": ["uvs","uvvs"]\n  },\n  "video/vnd.dece.video": {\n    "source": "iana",\n    "extensions": ["uvv","uvvv"]\n  },\n  "video/vnd.directv.mpeg": {\n    "source": "iana"\n  },\n  "video/vnd.directv.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dlna.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dvb.file": {\n    "source": "iana",\n    "extensions": ["dvb"]\n  },\n  "video/vnd.fvt": {\n    "source": "iana",\n    "extensions": ["fvt"]\n  },\n  "video/vnd.hns.video": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsavc": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsmpeg2": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.video": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.videop": {\n    "source": "iana"\n  },\n  "video/vnd.mpegurl": {\n    "source": "iana",\n    "extensions": ["mxu","m4u"]\n  },\n  "video/vnd.ms-playready.media.pyv": {\n    "source": "iana",\n    "extensions": ["pyv"]\n  },\n  "video/vnd.nokia.interleaved-multimedia": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.mp4vr": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.videovoip": {\n    "source": "iana"\n  },\n  "video/vnd.objectvideo": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.bink": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.smacker": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg1": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg4": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.swf": {\n    "source": "iana"\n  },\n  "video/vnd.sealedmedia.softseal.mov": {\n    "source": "iana"\n  },\n  "video/vnd.uvvu.mp4": {\n    "source": "iana",\n    "extensions": ["uvu","uvvu"]\n  },\n  "video/vnd.vivo": {\n    "source": "iana",\n    "extensions": ["viv"]\n  },\n  "video/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "video/vp8": {\n    "source": "iana"\n  },\n  "video/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["webm"]\n  },\n  "video/x-f4v": {\n    "source": "apache",\n    "extensions": ["f4v"]\n  },\n  "video/x-fli": {\n    "source": "apache",\n    "extensions": ["fli"]\n  },\n  "video/x-flv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["flv"]\n  },\n  "video/x-m4v": {\n    "source": "apache",\n    "extensions": ["m4v"]\n  },\n  "video/x-matroska": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["mkv","mk3d","mks"]\n  },\n  "video/x-mng": {\n    "source": "apache",\n    "extensions": ["mng"]\n  },\n  "video/x-ms-asf": {\n    "source": "apache",\n    "extensions": ["asf","asx"]\n  },\n  "video/x-ms-vob": {\n    "source": "apache",\n    "extensions": ["vob"]\n  },\n  "video/x-ms-wm": {\n    "source": "apache",\n    "extensions": ["wm"]\n  },\n  "video/x-ms-wmv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["wmv"]\n  },\n  "video/x-ms-wmx": {\n    "source": "apache",\n    "extensions": ["wmx"]\n  },\n  "video/x-ms-wvx": {\n    "source": "apache",\n    "extensions": ["wvx"]\n  },\n  "video/x-msvideo": {\n    "source": "apache",\n    "extensions": ["avi"]\n  },\n  "video/x-sgi-movie": {\n    "source": "apache",\n    "extensions": ["movie"]\n  },\n  "video/x-smv": {\n    "source": "apache",\n    "extensions": ["smv"]\n  },\n  "x-conference/x-cooltalk": {\n    "source": "apache",\n    "extensions": ["ice"]\n  },\n  "x-shader/x-fragment": {\n    "compressible": true\n  },\n  "x-shader/x-vertex": {\n    "compressible": true\n  }\n}`);
const osType1 = (()=>{
    if (globalThis.Deno != null) {
        return Deno.build.os;
    }
    const navigator = globalThis.navigator;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path1) {
    if (typeof path1 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path1)}`);
    }
}
function isPosixPathSeparator1(code7) {
    return code7 === 47;
}
function isPathSeparator1(code7) {
    return isPosixPathSeparator1(code7) || code7 === 92;
}
function isWindowsDeviceRoot1(code7) {
    return code7 >= 97 && code7 <= 122 || code7 >= 65 && code7 <= 90;
}
function normalizeString1(path1, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code7;
    for(let i2 = 0, len = path1.length; i2 <= len; ++i2){
        if (i2 < len) code7 = path1.charCodeAt(i2);
        else if (isPathSeparator2(code7)) break;
        else code7 = CHAR_FORWARD_SLASH1;
        if (isPathSeparator2(code7)) {
            if (lastSlash === i2 - 1 || dots === 1) {
            } else if (lastSlash !== i2 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path1.slice(lastSlash + 1, i2);
                else res = path1.slice(lastSlash + 1, i2);
                lastSegmentLength = i2 - lastSlash - 1;
            }
            lastSlash = i2;
            dots = 0;
        } else if (code7 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep3, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep3 + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
class DenoStdInternalError1 extends Error {
    constructor(message9){
        super(message9);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg2 = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg2);
    }
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1; i2--){
        let path1;
        if (i2 >= 0) {
            path1 = pathSegments[i2];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path1 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path1 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path1 === undefined || path1.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path1 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path1);
        const len = path1.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute3 = false;
        const code7 = path1.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code7)) {
                isAbsolute3 = true;
                if (isPathSeparator1(path1.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path1.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path1.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path1.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path1.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code7)) {
                if (path1.charCodeAt(1) === 58) {
                    device = path1.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path1.charCodeAt(2))) {
                            isAbsolute3 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code7)) {
            rootEnd = 1;
            isAbsolute3 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path1.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute3;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute3 = false;
    const code7 = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code7)) {
            isAbsolute3 = true;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path1.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path1.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path1.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code7)) {
            if (path1.charCodeAt(1) === 58) {
                device = path1.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) {
                        isAbsolute3 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code7)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path1.slice(rootEnd), !isAbsolute3, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute3) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path1.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute3) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute3) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return false;
    const code7 = path1.charCodeAt(0);
    if (isPathSeparator1(code7)) {
        return true;
    } else if (isWindowsDeviceRoot1(code7)) {
        if (len > 2 && path1.charCodeAt(1) === 58) {
            if (isPathSeparator1(path1.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join3(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i2 = 0; i2 < pathsCount; ++i2){
        const path1 = paths[i2];
        assertPath1(path1);
        if (path1.length > 0) {
            if (joined === undefined) joined = firstPart = path1;
            else joined += `\\${path1}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize3(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 92) {
                    return toOrig.slice(toStart + i2 + 1);
                } else if (i2 === 2) {
                    return toOrig.slice(toStart + i2);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 92) {
                    lastCommonSep = i2;
                } else if (i2 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i2;
    }
    if (i2 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path1) {
    if (typeof path1 !== "string") return path1;
    if (path1.length === 0) return "";
    const resolvedPath = resolve3(path1);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code7 = resolvedPath.charCodeAt(2);
                if (code7 !== 63 && code7 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path1;
}
function dirname3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code7 = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code7)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path1;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code7)) {
            if (path1.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code7)) {
        return path1;
    }
    for(let i2 = len - 1; i2 >= offset; --i2){
        if (isPathSeparator1(path1.charCodeAt(i2))) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path1.slice(0, end);
}
function basename3(path1, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path1);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (path1.length >= 2) {
        const drive = path1.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path1.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path1.length) {
        if (ext.length === path1.length && ext === path1) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path1.length - 1; i2 >= start; --i2){
            const code7 = path1.charCodeAt(i2);
            if (isPathSeparator1(code7)) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code7 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path1.length;
        return path1.slice(start, end);
    } else {
        for(i2 = path1.length - 1; i2 >= start; --i2){
            if (isPathSeparator1(path1.charCodeAt(i2))) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path1.slice(start, end);
    }
}
function extname3(path1) {
    assertPath1(path1);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path1.length >= 2 && path1.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path1.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i2 = path1.length - 1; i2 >= start; --i2){
        const code7 = path1.charCodeAt(i2);
        if (isPathSeparator1(code7)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code7 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path1.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse4(path1) {
    assertPath1(path1);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path1.length;
    if (len === 0) return ret1;
    let rootEnd = 0;
    let code7 = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code7)) {
            rootEnd = 1;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code7)) {
            if (path1.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) {
                        if (len === 3) {
                            ret1.root = ret1.dir = path1;
                            return ret1;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret1.root = ret1.dir = path1;
                    return ret1;
                }
            }
        }
    } else if (isPathSeparator1(code7)) {
        ret1.root = ret1.dir = path1;
        return ret1;
    }
    if (rootEnd > 0) ret1.root = path1.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i2 = path1.length - 1;
    let preDotState = 0;
    for(; i2 >= rootEnd; --i2){
        code7 = path1.charCodeAt(i2);
        if (isPathSeparator1(code7)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code7 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret1.base = ret1.name = path1.slice(startPart, end);
        }
    } else {
        ret1.name = path1.slice(startPart, startDot);
        ret1.base = path1.slice(startPart, end);
        ret1.ext = path1.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret1.dir = path1.slice(0, startPart - 1);
    } else ret1.dir = ret1.root;
    return ret1;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path1 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path1 = `\\\\${url.hostname}${path1}`;
    }
    return path1;
}
function toFileUrl3(path1) {
    if (!isAbsolute3(path1)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path1.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = function() {
    return {
        sep: sep3,
        delimiter: delimiter3,
        resolve: resolve3,
        normalize: normalize3,
        isAbsolute: isAbsolute3,
        join: join3,
        relative: relative3,
        toNamespacedPath: toNamespacedPath3,
        dirname: dirname3,
        basename: basename3,
        extname: extname3,
        format: format3,
        parse: parse4,
        fromFileUrl: fromFileUrl3,
        toFileUrl: toFileUrl3
    };
}();
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--){
        let path1;
        if (i2 >= 0) path1 = pathSegments[i2];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path1 = Deno.cwd();
        }
        assertPath1(path1);
        if (path1.length === 0) {
            continue;
        }
        resolvedPath = `${path1}/${resolvedPath}`;
        resolvedAbsolute = path1.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize4(path1) {
    assertPath1(path1);
    if (path1.length === 0) return ".";
    const isAbsolute4 = path1.charCodeAt(0) === 47;
    const trailingSeparator = path1.charCodeAt(path1.length - 1) === 47;
    path1 = normalizeString1(path1, !isAbsolute4, "/", isPosixPathSeparator1);
    if (path1.length === 0 && !isAbsolute4) path1 = ".";
    if (path1.length > 0 && trailingSeparator) path1 += "/";
    if (isAbsolute4) return `/${path1}`;
    return path1;
}
function isAbsolute4(path1) {
    assertPath1(path1);
    return path1.length > 0 && path1.charCodeAt(0) === 47;
}
function join4(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i2 = 0, len = paths.length; i2 < len; ++i2){
        const path1 = paths[i2];
        assertPath1(path1);
        if (path1.length > 0) {
            if (!joined) joined = path1;
            else joined += `/${path1}`;
        }
    }
    if (!joined) return ".";
    return normalize4(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 47) {
                    return to.slice(toStart + i2 + 1);
                } else if (i2 === 0) {
                    return to.slice(toStart + i2);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 47) {
                    lastCommonSep = i2;
                } else if (i2 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i2;
    }
    let out = "";
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path1) {
    return path1;
}
function dirname4(path1) {
    assertPath1(path1);
    if (path1.length === 0) return ".";
    const hasRoot = path1.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i2 = path1.length - 1; i2 >= 1; --i2){
        if (path1.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path1.slice(0, end);
}
function basename4(path1, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path1);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext !== undefined && ext.length > 0 && ext.length <= path1.length) {
        if (ext.length === path1.length && ext === path1) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path1.length - 1; i2 >= 0; --i2){
            const code7 = path1.charCodeAt(i2);
            if (code7 === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code7 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path1.length;
        return path1.slice(start, end);
    } else {
        for(i2 = path1.length - 1; i2 >= 0; --i2){
            if (path1.charCodeAt(i2) === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path1.slice(start, end);
    }
}
function extname4(path1) {
    assertPath1(path1);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i2 = path1.length - 1; i2 >= 0; --i2){
        const code7 = path1.charCodeAt(i2);
        if (code7 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code7 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path1.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse5(path1) {
    assertPath1(path1);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path1.length === 0) return ret1;
    const isAbsolute5 = path1.charCodeAt(0) === 47;
    let start;
    if (isAbsolute5) {
        ret1.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path1.length - 1;
    let preDotState = 0;
    for(; i2 >= start; --i2){
        const code7 = path1.charCodeAt(i2);
        if (code7 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code7 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute5) {
                ret1.base = ret1.name = path1.slice(1, end);
            } else {
                ret1.base = ret1.name = path1.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute5) {
            ret1.name = path1.slice(1, startDot);
            ret1.base = path1.slice(1, end);
        } else {
            ret1.name = path1.slice(startPart, startDot);
            ret1.base = path1.slice(startPart, end);
        }
        ret1.ext = path1.slice(startDot, end);
    }
    if (startPart > 0) ret1.dir = path1.slice(0, startPart - 1);
    else if (isAbsolute5) ret1.dir = "/";
    return ret1;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path1) {
    if (!isAbsolute4(path1)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path1.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = function() {
    return {
        sep: sep4,
        delimiter: delimiter4,
        resolve: resolve4,
        normalize: normalize4,
        isAbsolute: isAbsolute4,
        join: join4,
        relative: relative4,
        toNamespacedPath: toNamespacedPath4,
        dirname: dirname4,
        basename: basename4,
        extname: extname4,
        format: format4,
        parse: parse5,
        fromFileUrl: fromFileUrl4,
        toFileUrl: toFileUrl4
    };
}();
const path1 = isWindows1 ? mod2 : mod3;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join5 , normalize: normalize5 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path1;
const EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
const TEXT_TYPE_REGEXP = /^text\//i;
const extensions = new Map();
const types1 = new Map();
function populateMaps(extensions1, types2) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type1 of Object.keys(db)){
        const mime = db[type1];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions1.set(type1, exts);
        for (const ext of exts){
            const current = types2.get(ext);
            if (current) {
                const from = preference.indexOf(db[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from > to || from === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types2.set(ext, type1);
        }
    }
}
populateMaps(extensions, types1);
function charset(type1) {
    const m = EXTRACT_TYPE_REGEXP.exec(type1);
    if (!m) {
        return undefined;
    }
    const [match] = m;
    const mime = db[match.toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    if (TEXT_TYPE_REGEXP.test(match)) {
        return "UTF-8";
    }
    return undefined;
}
function lookup(path2) {
    const extension = extname5("x." + path2).toLowerCase().substr(1);
    return types1.get(extension);
}
function contentType(str2) {
    let mime = str2.includes("/") ? str2 : lookup(str2);
    if (!mime) {
        return undefined;
    }
    if (!mime.includes("charset")) {
        const cs = charset(mime);
        if (cs) {
            mime += `; charset=${cs.toLowerCase()}`;
        }
    }
    return mime;
}
class DenoStdInternalError2 extends Error {
    constructor(message10){
        super(message10);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg2 = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg2);
    }
}
class Tokenizer1 {
    rules;
    constructor(rules3 = []){
        this.rules = rules3;
    }
    addRule(test, fn) {
        this.rules.push({
            test,
            fn
        });
        return this;
    }
    tokenize(string, receiver = (token)=>token
    ) {
        function* generator(rules4) {
            let index = 0;
            for (const rule of rules4){
                const result = rule.test(string);
                if (result) {
                    const { value: value7 , length  } = result;
                    index += length;
                    string = string.slice(length);
                    const token = {
                        ...rule.fn(value7),
                        index
                    };
                    yield receiver(token);
                    yield* generator(rules4);
                }
            }
        }
        const tokenGenerator = generator(this.rules);
        const tokens = [];
        for (const token of tokenGenerator){
            tokens.push(token);
        }
        if (string.length) {
            throw new Error(`parser error: string not fully parsed! ${string.slice(0, 25)}`);
        }
        return tokens;
    }
}
function digits1(value7, count = 2) {
    return String(value7).padStart(count, "0");
}
function createLiteralTestFunction1(value7) {
    return (string)=>{
        return string.startsWith(value7) ? {
            value: value7,
            length: value7.length
        } : undefined;
    };
}
function createMatchTestFunction1(match) {
    return (string)=>{
        const result = match.exec(string);
        if (result) return {
            value: result,
            length: result[0].length
        };
    };
}
const defaultRules1 = [
    {
        test: createLiteralTestFunction1("yyyy"),
        fn: ()=>({
                type: "year",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("yy"),
        fn: ()=>({
                type: "year",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("MM"),
        fn: ()=>({
                type: "month",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("M"),
        fn: ()=>({
                type: "month",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("dd"),
        fn: ()=>({
                type: "day",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("d"),
        fn: ()=>({
                type: "day",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("hh"),
        fn: ()=>({
                type: "hour",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("h"),
        fn: ()=>({
                type: "hour",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("mm"),
        fn: ()=>({
                type: "minute",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("m"),
        fn: ()=>({
                type: "minute",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("ss"),
        fn: ()=>({
                type: "second",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("s"),
        fn: ()=>({
                type: "second",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("SSS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 3
            })
    },
    {
        test: createLiteralTestFunction1("SS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 2
            })
    },
    {
        test: createLiteralTestFunction1("S"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 1
            })
    },
    {
        test: createLiteralTestFunction1("a"),
        fn: (value7)=>({
                type: "dayPeriod",
                value: value7
            })
    },
    {
        test: createMatchTestFunction1(/^(')(?<value>\\.|[^\']*)\1/),
        fn: (match)=>({
                type: "literal",
                value: match.groups.value
            })
    },
    {
        test: createMatchTestFunction1(/^.+?\s*/),
        fn: (match)=>({
                type: "literal",
                value: match[0]
            })
    }, 
];
class DateTimeFormatter1 {
    #format;
    constructor(formatString1, rules4 = defaultRules1){
        const tokenizer1 = new Tokenizer1(rules4);
        this.#format = tokenizer1.tokenize(formatString1, ({ type: type1 , value: value7  })=>({
                type: type1,
                value: value7
            })
        );
    }
    format(date, options = {
    }) {
        let string = "";
        const utc = options.timeZone === "UTC";
        const hour12 = this.#format.find((token)=>token.type === "dayPeriod"
        );
        for (const token of this.#format){
            const type1 = token.type;
            switch(type1){
                case "year":
                    {
                        const value7 = utc ? date.getUTCFullYear() : date.getFullYear();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2).slice(-2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "month":
                    {
                        const value7 = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        const value7 = utc ? date.getUTCDate() : date.getDate();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        let value7 = utc ? date.getUTCHours() : date.getHours();
                        value7 -= hour12 && date.getHours() > 12 ? 12 : 0;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        const value7 = utc ? date.getUTCMinutes() : date.getMinutes();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        const value7 = utc ? date.getUTCSeconds() : date.getSeconds();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value7;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value7, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value7 = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
                        string += digits1(value7, Number(token.value));
                        break;
                    }
                case "timeZoneName":
                    {
                    }
                case "dayPeriod":
                    {
                        string += hour12 ? date.getHours() >= 12 ? "PM" : "AM" : "";
                        break;
                    }
                case "literal":
                    {
                        string += token.value;
                        break;
                    }
                default:
                    throw Error(`FormatterError: { ${token.type} ${token.value} }`);
            }
        }
        return string;
    }
    parseToParts(string) {
        const parts = [];
        for (const token of this.#format){
            const type1 = token.type;
            let value7 = "";
            switch(token.type){
                case "year":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,4}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                        }
                        break;
                    }
                case "month":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            case "narrow":
                                {
                                    value7 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "short":
                                {
                                    value7 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "long":
                                {
                                    value7 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value7 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value7 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        value7 = new RegExp(`^\\d{${token.value}}`).exec(string)?.[0];
                        break;
                    }
                case "timeZoneName":
                    {
                        value7 = token.value;
                        break;
                    }
                case "dayPeriod":
                    {
                        value7 = /^(A|P)M/.exec(string)?.[0];
                        break;
                    }
                case "literal":
                    {
                        if (!string.startsWith(token.value)) {
                            throw Error(`Literal "${token.value}" not found "${string.slice(0, 25)}"`);
                        }
                        value7 = token.value;
                        break;
                    }
                default:
                    throw Error(`${token.type} ${token.value}`);
            }
            if (!value7) {
                throw Error(`value not valid for token { ${type1} ${value7} } ${string.slice(0, 25)}`);
            }
            parts.push({
                type: type1,
                value: value7
            });
            string = string.slice(value7.length);
        }
        if (string.length) {
            throw Error(`datetime string was not fully parsed! ${string.slice(0, 25)}`);
        }
        return parts;
    }
    partsToDate(parts) {
        const date = new Date();
        const utc = parts.find((part)=>part.type === "timeZoneName" && part.value === "UTC"
        );
        utc ? date.setUTCHours(0, 0, 0, 0) : date.setHours(0, 0, 0, 0);
        for (const part of parts){
            switch(part.type){
                case "year":
                    {
                        const value7 = Number(part.value.padStart(4, "20"));
                        utc ? date.setUTCFullYear(value7) : date.setFullYear(value7);
                        break;
                    }
                case "month":
                    {
                        const value7 = Number(part.value) - 1;
                        utc ? date.setUTCMonth(value7) : date.setMonth(value7);
                        break;
                    }
                case "day":
                    {
                        const value7 = Number(part.value);
                        utc ? date.setUTCDate(value7) : date.setDate(value7);
                        break;
                    }
                case "hour":
                    {
                        let value7 = Number(part.value);
                        const dayPeriod = parts.find((part1)=>part1.type === "dayPeriod"
                        );
                        if (dayPeriod?.value === "PM") value7 += 12;
                        utc ? date.setUTCHours(value7) : date.setHours(value7);
                        break;
                    }
                case "minute":
                    {
                        const value7 = Number(part.value);
                        utc ? date.setUTCMinutes(value7) : date.setMinutes(value7);
                        break;
                    }
                case "second":
                    {
                        const value7 = Number(part.value);
                        utc ? date.setUTCSeconds(value7) : date.setSeconds(value7);
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value7 = Number(part.value);
                        utc ? date.setUTCMilliseconds(value7) : date.setMilliseconds(value7);
                        break;
                    }
            }
        }
        return date;
    }
    parse(string) {
        const parts = this.parseToParts(string);
        return this.partsToDate(parts);
    }
}
var Day1;
(function(Day2) {
    Day2[Day2["Sun"] = 0] = "Sun";
    Day2[Day2["Mon"] = 1] = "Mon";
    Day2[Day2["Tue"] = 2] = "Tue";
    Day2[Day2["Wed"] = 3] = "Wed";
    Day2[Day2["Thu"] = 4] = "Thu";
    Day2[Day2["Fri"] = 5] = "Fri";
    Day2[Day2["Sat"] = 6] = "Sat";
})(Day1 || (Day1 = {
}));
var Status1;
(function(Status2) {
    Status2[Status2["Continue"] = 100] = "Continue";
    Status2[Status2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status2[Status2["Processing"] = 102] = "Processing";
    Status2[Status2["EarlyHints"] = 103] = "EarlyHints";
    Status2[Status2["OK"] = 200] = "OK";
    Status2[Status2["Created"] = 201] = "Created";
    Status2[Status2["Accepted"] = 202] = "Accepted";
    Status2[Status2["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status2[Status2["NoContent"] = 204] = "NoContent";
    Status2[Status2["ResetContent"] = 205] = "ResetContent";
    Status2[Status2["PartialContent"] = 206] = "PartialContent";
    Status2[Status2["MultiStatus"] = 207] = "MultiStatus";
    Status2[Status2["AlreadyReported"] = 208] = "AlreadyReported";
    Status2[Status2["IMUsed"] = 226] = "IMUsed";
    Status2[Status2["MultipleChoices"] = 300] = "MultipleChoices";
    Status2[Status2["MovedPermanently"] = 301] = "MovedPermanently";
    Status2[Status2["Found"] = 302] = "Found";
    Status2[Status2["SeeOther"] = 303] = "SeeOther";
    Status2[Status2["NotModified"] = 304] = "NotModified";
    Status2[Status2["UseProxy"] = 305] = "UseProxy";
    Status2[Status2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status2[Status2["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status2[Status2["BadRequest"] = 400] = "BadRequest";
    Status2[Status2["Unauthorized"] = 401] = "Unauthorized";
    Status2[Status2["PaymentRequired"] = 402] = "PaymentRequired";
    Status2[Status2["Forbidden"] = 403] = "Forbidden";
    Status2[Status2["NotFound"] = 404] = "NotFound";
    Status2[Status2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status2[Status2["NotAcceptable"] = 406] = "NotAcceptable";
    Status2[Status2["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status2[Status2["RequestTimeout"] = 408] = "RequestTimeout";
    Status2[Status2["Conflict"] = 409] = "Conflict";
    Status2[Status2["Gone"] = 410] = "Gone";
    Status2[Status2["LengthRequired"] = 411] = "LengthRequired";
    Status2[Status2["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status2[Status2["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status2[Status2["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status2[Status2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status2[Status2["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status2[Status2["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status2[Status2["Teapot"] = 418] = "Teapot";
    Status2[Status2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status2[Status2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status2[Status2["Locked"] = 423] = "Locked";
    Status2[Status2["FailedDependency"] = 424] = "FailedDependency";
    Status2[Status2["TooEarly"] = 425] = "TooEarly";
    Status2[Status2["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status2[Status2["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status2[Status2["TooManyRequests"] = 429] = "TooManyRequests";
    Status2[Status2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status2[Status2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status2[Status2["InternalServerError"] = 500] = "InternalServerError";
    Status2[Status2["NotImplemented"] = 501] = "NotImplemented";
    Status2[Status2["BadGateway"] = 502] = "BadGateway";
    Status2[Status2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status2[Status2["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status2[Status2["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status2[Status2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status2[Status2["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status2[Status2["LoopDetected"] = 508] = "LoopDetected";
    Status2[Status2["NotExtended"] = 510] = "NotExtended";
    Status2[Status2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status1 || (Status1 = {
}));
const STATUS_TEXT1 = new Map([
    [
        Status1.Continue,
        "Continue"
    ],
    [
        Status1.SwitchingProtocols,
        "Switching Protocols"
    ],
    [
        Status1.Processing,
        "Processing"
    ],
    [
        Status1.EarlyHints,
        "Early Hints"
    ],
    [
        Status1.OK,
        "OK"
    ],
    [
        Status1.Created,
        "Created"
    ],
    [
        Status1.Accepted,
        "Accepted"
    ],
    [
        Status1.NonAuthoritativeInfo,
        "Non-Authoritative Information"
    ],
    [
        Status1.NoContent,
        "No Content"
    ],
    [
        Status1.ResetContent,
        "Reset Content"
    ],
    [
        Status1.PartialContent,
        "Partial Content"
    ],
    [
        Status1.MultiStatus,
        "Multi-Status"
    ],
    [
        Status1.AlreadyReported,
        "Already Reported"
    ],
    [
        Status1.IMUsed,
        "IM Used"
    ],
    [
        Status1.MultipleChoices,
        "Multiple Choices"
    ],
    [
        Status1.MovedPermanently,
        "Moved Permanently"
    ],
    [
        Status1.Found,
        "Found"
    ],
    [
        Status1.SeeOther,
        "See Other"
    ],
    [
        Status1.NotModified,
        "Not Modified"
    ],
    [
        Status1.UseProxy,
        "Use Proxy"
    ],
    [
        Status1.TemporaryRedirect,
        "Temporary Redirect"
    ],
    [
        Status1.PermanentRedirect,
        "Permanent Redirect"
    ],
    [
        Status1.BadRequest,
        "Bad Request"
    ],
    [
        Status1.Unauthorized,
        "Unauthorized"
    ],
    [
        Status1.PaymentRequired,
        "Payment Required"
    ],
    [
        Status1.Forbidden,
        "Forbidden"
    ],
    [
        Status1.NotFound,
        "Not Found"
    ],
    [
        Status1.MethodNotAllowed,
        "Method Not Allowed"
    ],
    [
        Status1.NotAcceptable,
        "Not Acceptable"
    ],
    [
        Status1.ProxyAuthRequired,
        "Proxy Authentication Required"
    ],
    [
        Status1.RequestTimeout,
        "Request Timeout"
    ],
    [
        Status1.Conflict,
        "Conflict"
    ],
    [
        Status1.Gone,
        "Gone"
    ],
    [
        Status1.LengthRequired,
        "Length Required"
    ],
    [
        Status1.PreconditionFailed,
        "Precondition Failed"
    ],
    [
        Status1.RequestEntityTooLarge,
        "Request Entity Too Large"
    ],
    [
        Status1.RequestURITooLong,
        "Request URI Too Long"
    ],
    [
        Status1.UnsupportedMediaType,
        "Unsupported Media Type"
    ],
    [
        Status1.RequestedRangeNotSatisfiable,
        "Requested Range Not Satisfiable"
    ],
    [
        Status1.ExpectationFailed,
        "Expectation Failed"
    ],
    [
        Status1.Teapot,
        "I'm a teapot"
    ],
    [
        Status1.MisdirectedRequest,
        "Misdirected Request"
    ],
    [
        Status1.UnprocessableEntity,
        "Unprocessable Entity"
    ],
    [
        Status1.Locked,
        "Locked"
    ],
    [
        Status1.FailedDependency,
        "Failed Dependency"
    ],
    [
        Status1.TooEarly,
        "Too Early"
    ],
    [
        Status1.UpgradeRequired,
        "Upgrade Required"
    ],
    [
        Status1.PreconditionRequired,
        "Precondition Required"
    ],
    [
        Status1.TooManyRequests,
        "Too Many Requests"
    ],
    [
        Status1.RequestHeaderFieldsTooLarge,
        "Request Header Fields Too Large"
    ],
    [
        Status1.UnavailableForLegalReasons,
        "Unavailable For Legal Reasons"
    ],
    [
        Status1.InternalServerError,
        "Internal Server Error"
    ],
    [
        Status1.NotImplemented,
        "Not Implemented"
    ],
    [
        Status1.BadGateway,
        "Bad Gateway"
    ],
    [
        Status1.ServiceUnavailable,
        "Service Unavailable"
    ],
    [
        Status1.GatewayTimeout,
        "Gateway Timeout"
    ],
    [
        Status1.HTTPVersionNotSupported,
        "HTTP Version Not Supported"
    ],
    [
        Status1.VariantAlsoNegotiates,
        "Variant Also Negotiates"
    ],
    [
        Status1.InsufficientStorage,
        "Insufficient Storage"
    ],
    [
        Status1.LoopDetected,
        "Loop Detected"
    ],
    [
        Status1.NotExtended,
        "Not Extended"
    ],
    [
        Status1.NetworkAuthenticationRequired,
        "Network Authentication Required"
    ], 
]);
function deferred1() {
    let methods;
    const promise = new Promise((resolve6, reject)=>{
        methods = {
            resolve: resolve6,
            reject
        };
    });
    return Object.assign(promise, methods);
}
class MuxAsyncIterator1 {
    iteratorCount = 0;
    yields = [];
    throws = [];
    signal = deferred1();
    add(iterator) {
        ++this.iteratorCount;
        this.callIteratorNext(iterator);
    }
    async callIteratorNext(iterator) {
        try {
            const { value: value7 , done  } = await iterator.next();
            if (done) {
                --this.iteratorCount;
            } else {
                this.yields.push({
                    iterator,
                    value: value7
                });
            }
        } catch (e) {
            this.throws.push(e);
        }
        this.signal.resolve();
    }
    async *iterate() {
        while(this.iteratorCount > 0){
            await this.signal;
            for(let i2 = 0; i2 < this.yields.length; i2++){
                const { iterator , value: value7  } = this.yields[i2];
                yield value7;
                this.callIteratorNext(iterator);
            }
            if (this.throws.length) {
                for (const e of this.throws){
                    throw e;
                }
                this.throws.length = 0;
            }
            this.yields.length = 0;
            this.signal = deferred1();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function concat1(origin, b) {
    const output = new Uint8Array(origin.length + b.length);
    output.set(origin, 0);
    output.set(b, origin.length);
    return output;
}
function copyBytes(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const encoder1 = new TextEncoder();
function encode(input5) {
    return encoder1.encode(input5);
}
const decoder1 = new TextDecoder();
function decode(input5) {
    return decoder1.decode(input5);
}
const invalidHeaderCharRegex1 = /[^\t\x20-\x7e\x80-\xff]/g;
function str2(buf) {
    if (buf == null) {
        return "";
    } else {
        return decode(buf);
    }
}
function charCode(s) {
    return s.charCodeAt(0);
}
class TextProtoReader1 {
    r;
    constructor(r2){
        this.r = r2;
    }
    async readLine() {
        const s = await this.readLineSlice();
        if (s === null) return null;
        return str2(s);
    }
    async readMIMEHeader() {
        const m = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str2(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            let i2 = kv.indexOf(charCode(":"));
            if (i2 < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str2(kv)}`);
            }
            const key1 = str2(kv.subarray(0, i2));
            if (key1 == "") {
                continue;
            }
            i2++;
            while(i2 < kv.byteLength && (kv[i2] == charCode(" ") || kv[i2] == charCode("\t"))){
                i2++;
            }
            const value7 = str2(kv.subarray(i2)).replace(invalidHeaderCharRegex1, encodeURI);
            try {
                m.append(key1, value7);
            } catch  {
            }
        }
    }
    async readLineSlice() {
        let line;
        while(true){
            const r3 = await this.r.readLine();
            if (r3 === null) return null;
            const { line: l , more  } = r3;
            if (!line && !more) {
                if (this.skipSpace(l) === 0) {
                    return new Uint8Array(0);
                }
                return l;
            }
            line = line ? concat1(line, l) : l;
            if (!more) {
                break;
            }
        }
        return line;
    }
    skipSpace(l) {
        let n = 0;
        for(let i2 = 0; i2 < l.length; i2++){
            if (l[i2] === charCode(" ") || l[i2] === charCode("\t")) {
                continue;
            }
            n++;
        }
        return n;
    }
}
function emptyReader1() {
    return {
        read (_) {
            return Promise.resolve(null);
        }
    };
}
function bodyReader1(contentLength, r3) {
    let totalRead = 0;
    let finished = false;
    async function read(buf) {
        if (finished) return null;
        let result;
        const remaining = contentLength - totalRead;
        if (remaining >= buf.byteLength) {
            result = await r3.read(buf);
        } else {
            const readBuf = buf.subarray(0, remaining);
            result = await r3.read(readBuf);
        }
        if (result !== null) {
            totalRead += result;
        }
        finished = totalRead === contentLength;
        return result;
    }
    return {
        read
    };
}
function chunkedBodyReader1(h, r3) {
    const tp = new TextProtoReader1(r3);
    let finished = false;
    const chunks = [];
    async function read(buf) {
        if (finished) return null;
        const [chunk] = chunks;
        if (chunk) {
            const chunkRemaining = chunk.data.byteLength - chunk.offset;
            const readLength = Math.min(chunkRemaining, buf.byteLength);
            for(let i2 = 0; i2 < readLength; i2++){
                buf[i2] = chunk.data[chunk.offset + i2];
            }
            chunk.offset += readLength;
            if (chunk.offset === chunk.data.byteLength) {
                chunks.shift();
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
            }
            return readLength;
        }
        const line = await tp.readLine();
        if (line === null) throw new Deno.errors.UnexpectedEof();
        const [chunkSizeString] = line.split(";");
        const chunkSize = parseInt(chunkSizeString, 16);
        if (Number.isNaN(chunkSize) || chunkSize < 0) {
            throw new Error("Invalid chunk size");
        }
        if (chunkSize > 0) {
            if (chunkSize > buf.byteLength) {
                let eof = await r3.readFull(buf);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                eof = await r3.readFull(restChunk);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                } else {
                    chunks.push({
                        offset: 0,
                        data: restChunk
                    });
                }
                return buf.byteLength;
            } else {
                const bufToFill = buf.subarray(0, chunkSize);
                const eof = await r3.readFull(bufToFill);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                return chunkSize;
            }
        } else {
            assert2(chunkSize === 0);
            if (await r3.readLine() === null) {
                throw new Deno.errors.UnexpectedEof();
            }
            await readTrailers2(h, r3);
            finished = true;
            return null;
        }
    }
    return {
        read
    };
}
const DEFAULT_BUF_SIZE1 = 4096;
const MIN_BUF_SIZE1 = 16;
const CR1 = "\r".charCodeAt(0);
const LF1 = "\n".charCodeAt(0);
class BufferFullError1 extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial2){
        super("Buffer full");
        this.partial = partial2;
    }
}
class PartialReadError1 extends Deno.errors.UnexpectedEof {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader1 {
    buf;
    rd;
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader1 ? r : new BufReader1(r, size);
    }
    constructor(rd2, size4 = 4096){
        if (size4 < 16) {
            size4 = MIN_BUF_SIZE1;
        }
        this._reset(new Uint8Array(size4), rd2);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i2 = 100; i2 > 0; i2--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert2(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr1 = await this.rd.read(p);
                const nread = rr1 ?? 0;
                assert2(nread >= 0, "negative read");
                return rr1;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert2(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError1();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                err.partial = p.subarray(0, bytesRead);
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line;
        try {
            line = await this.readSlice(LF1);
        } catch (err) {
            let { partial: partial3  } = err;
            assert2(partial3 instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError1)) {
                throw err;
            }
            if (!this.eof && partial3.byteLength > 0 && partial3[partial3.byteLength - 1] === CR1) {
                assert2(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial3 = partial3.subarray(0, partial3.byteLength - 1);
            }
            return {
                line: partial3,
                more: !this.eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF1) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR1) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i2 = this.buf.subarray(this.r + s, this.w).indexOf(delim);
            if (i2 >= 0) {
                i2 += s;
                slice = this.buf.subarray(this.r, this.r + i2 + 1);
                this.r += i2 + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError1(oldbuf);
            }
            s = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                err.partial = slice;
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                err.partial = this.buf.subarray(this.r, this.w);
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError1(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase1 {
    buf;
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter1 extends AbstractBufBase1 {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter1 ? writer : new BufWriter1(writer, size);
    }
    constructor(writer3, size5 = 4096){
        super();
        this.writer = writer3;
        if (size5 <= 0) {
            size5 = DEFAULT_BUF_SIZE1;
        }
        this.buf = new Uint8Array(size5);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
function isProhibidedForTrailer1(key1) {
    const s = new Set([
        "transfer-encoding",
        "content-length",
        "trailer"
    ]);
    return s.has(key1.toLowerCase());
}
async function readTrailers2(headers, r3) {
    const trailers = parseTrailer2(headers.get("trailer"));
    if (trailers == null) return;
    const trailerNames = [
        ...trailers.keys()
    ];
    const tp = new TextProtoReader1(r3);
    const result = await tp.readMIMEHeader();
    if (result == null) {
        throw new Deno.errors.InvalidData("Missing trailer header.");
    }
    const undeclared = [
        ...result.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [k, v] of result){
        headers.append(k, v);
    }
    const missingTrailers = trailerNames.filter((k1)=>!result.has(k1)
    );
    if (missingTrailers.length > 0) {
        throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
    }
    headers.delete("trailer");
}
function parseTrailer2(field1) {
    if (field1 == null) {
        return undefined;
    }
    const trailerNames = field1.split(",").map((v)=>v.trim().toLowerCase()
    );
    if (trailerNames.length === 0) {
        throw new Deno.errors.InvalidData("Empty trailer header.");
    }
    const prohibited = trailerNames.filter((k)=>isProhibidedForTrailer1(k)
    );
    if (prohibited.length > 0) {
        throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
    }
    return new Headers(trailerNames.map((key1)=>[
            key1,
            ""
        ]
    ));
}
async function writeChunkedBody1(w, r3) {
    const writer4 = BufWriter1.create(w);
    for await (const chunk of Deno.iter(r3)){
        if (chunk.byteLength <= 0) continue;
        const start = encoder1.encode(`${chunk.byteLength.toString(16)}\r\n`);
        const end = encoder1.encode("\r\n");
        await writer4.write(start);
        await writer4.write(chunk);
        await writer4.write(end);
    }
    const endChunk = encoder1.encode("0\r\n\r\n");
    await writer4.write(endChunk);
}
async function writeTrailers1(w, headers, trailers) {
    const trailer = headers.get("trailer");
    if (trailer === null) {
        throw new TypeError("Missing trailer header.");
    }
    const transferEncoding = headers.get("transfer-encoding");
    if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
        throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
    }
    const writer4 = BufWriter1.create(w);
    const trailerNames = trailer.split(",").map((s)=>s.trim().toLowerCase()
    );
    const prohibitedTrailers = trailerNames.filter((k)=>isProhibidedForTrailer1(k)
    );
    if (prohibitedTrailers.length > 0) {
        throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
    }
    const undeclared = [
        ...trailers.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [key1, value7] of trailers){
        await writer4.write(encoder1.encode(`${key1}: ${value7}\r\n`));
    }
    await writer4.write(encoder1.encode("\r\n"));
    await writer4.flush();
}
async function writeResponse1(w, r3) {
    const protoMajor = 1;
    const protoMinor = 1;
    const statusCode = r3.status || 200;
    const statusText = STATUS_TEXT1.get(statusCode);
    const writer4 = BufWriter1.create(w);
    if (!statusText) {
        throw new Deno.errors.InvalidData("Bad status code");
    }
    if (!r3.body) {
        r3.body = new Uint8Array();
    }
    if (typeof r3.body === "string") {
        r3.body = encoder1.encode(r3.body);
    }
    let out = `HTTP/${1}.${1} ${statusCode} ${statusText}\r\n`;
    const headers = r3.headers ?? new Headers();
    if (r3.body && !headers.get("content-length")) {
        if (r3.body instanceof Uint8Array) {
            out += `content-length: ${r3.body.byteLength}\r\n`;
        } else if (!headers.get("transfer-encoding")) {
            out += "transfer-encoding: chunked\r\n";
        }
    }
    for (const [key1, value7] of headers){
        out += `${key1}: ${value7}\r\n`;
    }
    out += `\r\n`;
    const header = encoder1.encode(out);
    const n = await writer4.write(header);
    assert2(n === header.byteLength);
    if (r3.body instanceof Uint8Array) {
        const n1 = await writer4.write(r3.body);
        assert2(n1 === r3.body.byteLength);
    } else if (headers.has("content-length")) {
        const contentLength = headers.get("content-length");
        assert2(contentLength != null);
        const bodyLength = parseInt(contentLength);
        const n1 = await Deno.copy(r3.body, writer4);
        assert2(n1 === bodyLength);
    } else {
        await writeChunkedBody1(writer4, r3.body);
    }
    if (r3.trailers) {
        const t = await r3.trailers();
        await writeTrailers1(writer4, headers, t);
    }
    await writer4.flush();
}
class ServerRequest1 {
    url;
    method;
    proto;
    protoMinor;
    protoMajor;
    headers;
    conn;
    r;
    w;
    done = deferred1();
    _contentLength = undefined;
    get contentLength() {
        if (this._contentLength === undefined) {
            const cl = this.headers.get("content-length");
            if (cl) {
                this._contentLength = parseInt(cl);
                if (Number.isNaN(this._contentLength)) {
                    this._contentLength = null;
                }
            } else {
                this._contentLength = null;
            }
        }
        return this._contentLength;
    }
    _body = null;
    get body() {
        if (!this._body) {
            if (this.contentLength != null) {
                this._body = bodyReader1(this.contentLength, this.r);
            } else {
                const transferEncoding = this.headers.get("transfer-encoding");
                if (transferEncoding != null) {
                    const parts = transferEncoding.split(",").map((e)=>e.trim().toLowerCase()
                    );
                    assert2(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                    this._body = chunkedBodyReader1(this.headers, this.r);
                } else {
                    this._body = emptyReader1();
                }
            }
        }
        return this._body;
    }
    async respond(r) {
        let err;
        try {
            await writeResponse1(this.w, r);
        } catch (e) {
            try {
                this.conn.close();
            } catch  {
            }
            err = e;
        }
        this.done.resolve(err);
        if (err) {
            throw err;
        }
    }
    finalized = false;
    async finalize() {
        if (this.finalized) return;
        const body = this.body;
        const buf = new Uint8Array(1024);
        while(await body.read(buf) !== null){
        }
        this.finalized = true;
    }
}
function parseHTTPVersion1(vers) {
    switch(vers){
        case "HTTP/1.1":
            return [
                1,
                1
            ];
        case "HTTP/1.0":
            return [
                1,
                0
            ];
        default:
            {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > 1000000) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > 1000000) {
                    break;
                }
                return [
                    major,
                    minor
                ];
            }
    }
    throw new Error(`malformed HTTP version ${vers}`);
}
async function readRequest1(conn, bufr) {
    const tp = new TextProtoReader1(bufr);
    const firstLine = await tp.readLine();
    if (firstLine === null) return null;
    const headers = await tp.readMIMEHeader();
    if (headers === null) throw new Deno.errors.UnexpectedEof();
    const req = new ServerRequest1();
    req.conn = conn;
    req.r = bufr;
    [req.method, req.url, req.proto] = firstLine.split(" ", 3);
    [req.protoMinor, req.protoMajor] = parseHTTPVersion1(req.proto);
    req.headers = headers;
    fixLength2(req);
    return req;
}
class Server1 {
    listener;
    closing = false;
    connections = [];
    constructor(listener2){
        this.listener = listener2;
    }
    close() {
        this.closing = true;
        this.listener.close();
        for (const conn of this.connections){
            try {
                conn.close();
            } catch (e) {
                if (!(e instanceof Deno.errors.BadResource)) {
                    throw e;
                }
            }
        }
    }
    async *iterateHttpRequests(conn) {
        const reader = new BufReader1(conn);
        const writer4 = new BufWriter1(conn);
        while(!this.closing){
            let request;
            try {
                request = await readRequest1(conn, reader);
            } catch (error1) {
                if (error1 instanceof Deno.errors.InvalidData || error1 instanceof Deno.errors.UnexpectedEof) {
                    await writeResponse1(writer4, {
                        status: 400,
                        body: encode(`${error1.message}\r\n\r\n`)
                    });
                }
                break;
            }
            if (request === null) {
                break;
            }
            request.w = writer4;
            yield request;
            const responseError = await request.done;
            if (responseError) {
                this.untrackConnection(request.conn);
                return;
            }
            await request.finalize();
        }
        this.untrackConnection(conn);
        try {
            conn.close();
        } catch (e) {
        }
    }
    trackConnection(conn) {
        this.connections.push(conn);
    }
    untrackConnection(conn) {
        const index = this.connections.indexOf(conn);
        if (index !== -1) {
            this.connections.splice(index, 1);
        }
    }
    async *acceptConnAndIterateHttpRequests(mux) {
        if (this.closing) return;
        let conn;
        try {
            conn = await this.listener.accept();
        } catch (error1) {
            if (error1 instanceof Deno.errors.BadResource || error1 instanceof Deno.errors.InvalidData || error1 instanceof Deno.errors.UnexpectedEof) {
                return mux.add(this.acceptConnAndIterateHttpRequests(mux));
            }
            throw error1;
        }
        this.trackConnection(conn);
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        yield* this.iterateHttpRequests(conn);
    }
    [Symbol.asyncIterator]() {
        const mux = new MuxAsyncIterator1();
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        return mux.iterate();
    }
}
function fixLength2(req) {
    const contentLength = req.headers.get("Content-Length");
    if (contentLength) {
        const arrClen = contentLength.split(",");
        if (arrClen.length > 1) {
            const distinct = [
                ...new Set(arrClen.map((e)=>e.trim()
                ))
            ];
            if (distinct.length > 1) {
                throw Error("cannot contain multiple Content-Length headers");
            } else {
                req.headers.set("Content-Length", distinct[0]);
            }
        }
        const c = req.headers.get("Content-Length");
        if (req.method === "HEAD" && c && c !== "0") {
            throw Error("http: method cannot contain a Content-Length");
        }
        if (c && req.headers.has("transfer-encoding")) {
            throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
        }
    }
}
class BufWriterSync1 extends AbstractBufBase1 {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync1 ? writer : new BufWriterSync1(writer, size);
    }
    constructor(writer4, size6 = 4096){
        super();
        this.writer = writer4;
        if (size6 <= 0) {
            size6 = DEFAULT_BUF_SIZE1;
        }
        this.buf = new Uint8Array(size6);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class HttpError extends Error {
    name;
    message;
    status;
    statusCode;
    expose = false;
    constructor(code7, message11){
        super(message11);
        if (!Status1[code7]) {
            throw TypeError(`Unknown HTTP Status Code \`${code7}\``);
        }
        if (code7 < 400 || code7 >= 600) {
            throw TypeError(`Only 4xx or 5xx status codes allowed, but got \`${code7}\``);
        }
        if (code7 >= 400 && code7 < 500) {
            this.expose = true;
        }
        let className = Status1[code7];
        if (!className.endsWith("Error")) {
            className += "Error";
        }
        const msg2 = message11 != null ? message11 : STATUS_TEXT1.get(code7);
        this.message = msg2;
        this.status = this.statusCode = code7;
        this.name = className;
        Error.captureStackTrace(this, this.constructor);
        Object.setPrototypeOf(this, new.target.prototype);
    }
    toString() {
        return `${this.name} [${this.status}]: ${this.message}`;
    }
    toJSON() {
        return {
            name: this.name,
            status: this.status,
            message: this.message
        };
    }
}
class HttpErrorImpl extends HttpError {
}
function createError(status, message12, props) {
    let err;
    if (status instanceof Error) {
        err = status;
        status = err.status || err.statusCode;
        if (typeof status !== "number" || !Status1[status] && (status < 400 || status >= 600)) {
            status = 500;
        }
        props = message12;
    } else if (typeof message12 === "string") {
        err = new HttpErrorImpl(status, message12);
        Error.captureStackTrace(err, createError);
    } else {
        props = message12;
        err = new HttpErrorImpl(status);
        Error.captureStackTrace(err, createError);
    }
    if (!(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
    }
    if (props) {
        for(let key1 in props){
            if (key1 !== "status") {
                err[key1] = props[key1];
            }
        }
    }
    return err;
}
const simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
    const accepts = accept.split(",");
    const parsedAccepts = [];
    for(let i2 = 0; i2 < accepts.length; i2++){
        const charset1 = parseCharset(accepts[i2].trim(), i2);
        if (charset1) {
            parsedAccepts.push(charset1);
        }
    }
    return parsedAccepts;
}
function parseCharset(str3, i2) {
    const match = simpleCharsetRegExp.exec(str3);
    if (!match) return null;
    const charset1 = match[1];
    let q = 1;
    if (match[2]) {
        const params = match[2].split(";");
        for(let j = 0; j < params.length; j++){
            const p = params[j].trim().split("=");
            if (p[0] === "q") {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        charset: charset1,
        q: q,
        i: i2
    };
}
function getCharsetPriority(charset1, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i2 = 0; i2 < accepted.length; i2++){
        const spec = specify1(charset1, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify1(charset1, spec, index) {
    let s = 0;
    if (spec.charset.toLowerCase() === charset1.toLowerCase()) {
        s |= 1;
    } else if (spec.charset !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredCharsets(accept, provided) {
    const accepts = parseAcceptCharset(accept === null ? "*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality1).sort(compareSpecs1).map(getFullCharset);
    }
    const priorities = provided.map(function getPriority(type1, index) {
        return getCharsetPriority(type1, accepts, index);
    });
    return priorities.filter(isQuality1).sort(compareSpecs1).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs1(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
    return spec.charset;
}
function isQuality1(spec) {
    return spec.q > 0;
}
const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
    const accepts = accept.split(",");
    let hasIdentity = false;
    let minQuality = 1;
    const parsedEncodings = [];
    for(let i2 = 0; i2 < accepts.length; i2++){
        const encoding1 = parseEncoding(accepts[i2].trim(), i2);
        if (encoding1) {
            parsedEncodings.push(encoding1);
            hasIdentity = hasIdentity || specify2("identity", encoding1);
            minQuality = Math.min(minQuality, encoding1.q || 1);
        }
    }
    if (!hasIdentity) {
        parsedEncodings.push({
            encoding: "identity",
            q: minQuality,
            i: accepts.length
        });
    }
    return parsedEncodings;
}
function parseEncoding(str3, i2) {
    const match = simpleEncodingRegExp.exec(str3);
    if (!match) return null;
    const encoding1 = match[1];
    let q = 1;
    if (match[2]) {
        const params = match[2].split(";");
        for(var j = 0; j < params.length; j++){
            const p = params[j].trim().split("=");
            if (p[0] === "q") {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        encoding: encoding1,
        q: q,
        i: i2
    };
}
function getEncodingPriority(encoding1, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i2 = 0; i2 < accepted.length; i2++){
        const spec = specify2(encoding1, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify2(encoding1, spec, index) {
    let s = 0;
    if (spec.encoding.toLowerCase() === encoding1.toLowerCase()) {
        s |= 1;
    } else if (spec.encoding !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredEncodings(accept, provided) {
    const accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
        return accepts.filter(isQuality2).sort(compareSpecs2).map(getFullEncoding);
    }
    const priorities = provided.map(function getPriority(type1, index) {
        return getEncodingPriority(type1, accepts, index);
    });
    return priorities.filter(isQuality2).sort(compareSpecs2).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs2(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
    return spec.encoding;
}
function isQuality2(spec) {
    return spec.q > 0;
}
const simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
    const accepts = accept.split(",");
    const parsedEncodings = [];
    for(let i2 = 0; i2 < accepts.length; i2++){
        const language = parseLanguage(accepts[i2].trim(), i2);
        if (language) {
            parsedEncodings.push(language);
        }
    }
    return parsedEncodings;
}
function parseLanguage(str3, i2) {
    const match = simpleLanguageRegExp.exec(str3);
    if (!match) return null;
    const prefix = match[1];
    const suffix = match[2];
    let full = prefix;
    if (suffix) full += "-" + suffix;
    let q = 1;
    if (match[3]) {
        const params = match[3].split(";");
        for(let j = 0; j < params.length; j++){
            const p = params[j].split("=");
            if (p[0] === "q") q = parseFloat(p[1]);
        }
    }
    return {
        prefix,
        suffix,
        q,
        i: i2,
        full
    };
}
function getLanguagePriority(language, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i2 = 0; i2 < accepted.length; i2++){
        const spec = specify3(language, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify3(language, spec, index) {
    const p = parseLanguage(language);
    if (!p) return null;
    let s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
    } else if (spec.full !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
    };
}
function preferredLanguages(accept, provided) {
    const accepts = parseAcceptLanguage(accept === null ? "*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality3).sort(compareSpecs3).map(getFullLanguage);
    }
    const priorities = provided.map(function getPriority(type1, index) {
        return getLanguagePriority(type1, accepts, index);
    });
    return priorities.filter(isQuality3).sort(compareSpecs3).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs3(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
    return spec.full;
}
function isQuality3(spec) {
    return spec.q > 0;
}
const simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
    const accepts = splitMediaTypes(accept);
    const parsedAccepts = [];
    for(let i2 = 0; i2 < accepts.length; i2++){
        const mediaType = parseMediaType(accepts[i2].trim(), i2);
        if (mediaType) {
            parsedAccepts.push(mediaType);
        }
    }
    return parsedAccepts;
}
function parseMediaType(str3, i2) {
    const match = simpleMediaTypeRegExp.exec(str3);
    if (!match) return null;
    const params = Object.create(null);
    let q = 1;
    const subtype = match[2];
    const type1 = match[1];
    if (match[3]) {
        const kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for(let j = 0; j < kvps.length; j++){
            const pair = kvps[j];
            const key1 = pair[0].toLowerCase();
            const val = pair[1];
            const value7 = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
            if (key1 === "q") {
                q = parseFloat(value7);
                break;
            }
            params[key1] = value7;
        }
    }
    return {
        type: type1,
        subtype,
        params,
        q,
        i: i2
    };
}
function getMediaTypePriority(type1, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i2 = 0; i2 < accepted.length; i2++){
        const spec = specify4(type1, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify4(type1, spec, index) {
    const p = parseMediaType(type1);
    let s = 0;
    if (!p) {
        return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
    } else if (spec.type != "*") {
        return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
    } else if (spec.subtype != "*") {
        return null;
    }
    const keys = Object.keys(spec.params);
    if (keys.length > 0) {
        if (keys.every(function(k) {
            return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
            s |= 1;
        } else {
            return null;
        }
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredMediaTypes(accept, provided) {
    const accepts = parseAccept(accept === null ? "*/*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality4).sort(compareSpecs4).map(getFullType);
    }
    const priorities = provided.map(function getPriority(type1, index) {
        return getMediaTypePriority(type1, accepts, index);
    });
    return priorities.filter(isQuality4).sort(compareSpecs4).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs4(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
}
function isQuality4(spec) {
    return spec.q > 0;
}
function quoteCount(string) {
    let count = 0;
    let index = 0;
    while((index = string.indexOf('"', index)) !== -1){
        count++;
        index++;
    }
    return count;
}
function splitKeyValuePair(str3) {
    const index = str3.indexOf("=");
    let key1;
    let val;
    if (index === -1) {
        key1 = str3;
    } else {
        key1 = str3.substr(0, index);
        val = str3.substr(index + 1);
    }
    return [
        key1,
        val
    ];
}
function splitMediaTypes(accept) {
    const accepts = accept.split(",");
    let j = 0;
    for(let i2 = 1; i2 < accepts.length; i2++){
        if (quoteCount(accepts[j]) % 2 == 0) {
            accepts[++j] = accepts[i2];
        } else {
            accepts[j] += "," + accepts[i2];
        }
    }
    accepts.length = j + 1;
    return accepts;
}
function splitParameters(str3) {
    const parameters = str3.split(";");
    let j = 0;
    for(let i2 = 1; i2 < parameters.length; i2++){
        if (quoteCount(parameters[j]) % 2 == 0) {
            parameters[++j] = parameters[i2];
        } else {
            parameters[j] += ";" + parameters[i2];
        }
    }
    parameters.length = j + 1;
    for(let i3 = 0; i3 < parameters.length; i3++){
        parameters[i3] = parameters[i3].trim();
    }
    return parameters;
}
class Negotiator {
    constructor(headers1){
        this.headers = headers1;
    }
    headers;
    charset(available) {
        const set = this.charsets(available);
        return set && set[0];
    }
    charsets(available) {
        return preferredCharsets(this.headers.get("accept-charset"), available);
    }
    encoding(available) {
        const set = this.encodings(available);
        return set && set[0];
    }
    encodings(available) {
        return preferredEncodings(this.headers.get("accept-encoding"), available);
    }
    language(available) {
        const set = this.languages(available);
        return set && set[0];
    }
    languages(available) {
        return preferredLanguages(this.headers.get("accept-language"), available);
    }
    mediaType(available) {
        const set = this.mediaTypes(available);
        return set && set[0];
    }
    mediaTypes(available) {
        return preferredMediaTypes(this.headers.get("accept"), available);
    }
}
const db1 = {
    "application/1d-interleaved-parityfec": {
        source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
    },
    "application/a2l": {
        source: "iana"
    },
    "application/activemessage": {
        source: "iana"
    },
    "application/activity+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-costmap+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-directory+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-error+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
    },
    "application/aml": {
        source: "iana"
    },
    "application/andrew-inset": {
        source: "iana",
        extensions: [
            "ez"
        ]
    },
    "application/applefile": {
        source: "iana"
    },
    "application/applixware": {
        source: "apache",
        extensions: [
            "aw"
        ]
    },
    "application/atf": {
        source: "iana"
    },
    "application/atfx": {
        source: "iana"
    },
    "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atom"
        ]
    },
    "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomcat"
        ]
    },
    "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomdeleted"
        ]
    },
    "application/atomicmail": {
        source: "iana"
    },
    "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomsvc"
        ]
    },
    "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dwd"
        ]
    },
    "application/atsc-dynamic-event-message": {
        source: "iana"
    },
    "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "held"
        ]
    },
    "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
    },
    "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rsat"
        ]
    },
    "application/atxml": {
        source: "iana"
    },
    "application/auth-policy+xml": {
        source: "iana",
        compressible: true
    },
    "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
    },
    "application/batch-smtp": {
        source: "iana"
    },
    "application/bdoc": {
        compressible: false,
        extensions: [
            "bdoc"
        ]
    },
    "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/calendar+json": {
        source: "iana",
        compressible: true
    },
    "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xcs"
        ]
    },
    "application/call-completion": {
        source: "iana"
    },
    "application/cals-1840": {
        source: "iana"
    },
    "application/cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/cbor": {
        source: "iana"
    },
    "application/cbor-seq": {
        source: "iana"
    },
    "application/cccex": {
        source: "iana"
    },
    "application/ccmp+xml": {
        source: "iana",
        compressible: true
    },
    "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ccxml"
        ]
    },
    "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "cdfx"
        ]
    },
    "application/cdmi-capability": {
        source: "iana",
        extensions: [
            "cdmia"
        ]
    },
    "application/cdmi-container": {
        source: "iana",
        extensions: [
            "cdmic"
        ]
    },
    "application/cdmi-domain": {
        source: "iana",
        extensions: [
            "cdmid"
        ]
    },
    "application/cdmi-object": {
        source: "iana",
        extensions: [
            "cdmio"
        ]
    },
    "application/cdmi-queue": {
        source: "iana",
        extensions: [
            "cdmiq"
        ]
    },
    "application/cdni": {
        source: "iana"
    },
    "application/cea": {
        source: "iana"
    },
    "application/cea-2018+xml": {
        source: "iana",
        compressible: true
    },
    "application/cellml+xml": {
        source: "iana",
        compressible: true
    },
    "application/cfw": {
        source: "iana"
    },
    "application/clue+xml": {
        source: "iana",
        compressible: true
    },
    "application/clue_info+xml": {
        source: "iana",
        compressible: true
    },
    "application/cms": {
        source: "iana"
    },
    "application/cnrp+xml": {
        source: "iana",
        compressible: true
    },
    "application/coap-group+json": {
        source: "iana",
        compressible: true
    },
    "application/coap-payload": {
        source: "iana"
    },
    "application/commonground": {
        source: "iana"
    },
    "application/conference-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/cose": {
        source: "iana"
    },
    "application/cose-key": {
        source: "iana"
    },
    "application/cose-key-set": {
        source: "iana"
    },
    "application/cpl+xml": {
        source: "iana",
        compressible: true
    },
    "application/csrattrs": {
        source: "iana"
    },
    "application/csta+xml": {
        source: "iana",
        compressible: true
    },
    "application/cstadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/csvm+json": {
        source: "iana",
        compressible: true
    },
    "application/cu-seeme": {
        source: "apache",
        extensions: [
            "cu"
        ]
    },
    "application/cwt": {
        source: "iana"
    },
    "application/cybercash": {
        source: "iana"
    },
    "application/dart": {
        compressible: true
    },
    "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mpd"
        ]
    },
    "application/dashdelta": {
        source: "iana"
    },
    "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "davmount"
        ]
    },
    "application/dca-rft": {
        source: "iana"
    },
    "application/dcd": {
        source: "iana"
    },
    "application/dec-dx": {
        source: "iana"
    },
    "application/dialog-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/dicom": {
        source: "iana"
    },
    "application/dicom+json": {
        source: "iana",
        compressible: true
    },
    "application/dicom+xml": {
        source: "iana",
        compressible: true
    },
    "application/dii": {
        source: "iana"
    },
    "application/dit": {
        source: "iana"
    },
    "application/dns": {
        source: "iana"
    },
    "application/dns+json": {
        source: "iana",
        compressible: true
    },
    "application/dns-message": {
        source: "iana"
    },
    "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "dbk"
        ]
    },
    "application/dots+cbor": {
        source: "iana"
    },
    "application/dskpp+xml": {
        source: "iana",
        compressible: true
    },
    "application/dssc+der": {
        source: "iana",
        extensions: [
            "dssc"
        ]
    },
    "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdssc"
        ]
    },
    "application/dvcs": {
        source: "iana"
    },
    "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: [
            "ecma",
            "es"
        ]
    },
    "application/edi-consent": {
        source: "iana"
    },
    "application/edi-x12": {
        source: "iana",
        compressible: false
    },
    "application/edifact": {
        source: "iana",
        compressible: false
    },
    "application/efi": {
        source: "iana"
    },
    "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
        source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
    },
    "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "emma"
        ]
    },
    "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "emotionml"
        ]
    },
    "application/encaprtp": {
        source: "iana"
    },
    "application/epp+xml": {
        source: "iana",
        compressible: true
    },
    "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "epub"
        ]
    },
    "application/eshop": {
        source: "iana"
    },
    "application/exi": {
        source: "iana",
        extensions: [
            "exi"
        ]
    },
    "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
    },
    "application/fastinfoset": {
        source: "iana"
    },
    "application/fastsoap": {
        source: "iana"
    },
    "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "fdt"
        ]
    },
    "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/fido.trusted-apps+json": {
        compressible: true
    },
    "application/fits": {
        source: "iana"
    },
    "application/flexfec": {
        source: "iana"
    },
    "application/font-sfnt": {
        source: "iana"
    },
    "application/font-tdpfr": {
        source: "iana",
        extensions: [
            "pfr"
        ]
    },
    "application/font-woff": {
        source: "iana",
        compressible: false
    },
    "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
    },
    "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "geojson"
        ]
    },
    "application/geo+json-seq": {
        source: "iana"
    },
    "application/geopackage+sqlite3": {
        source: "iana"
    },
    "application/geoxacml+xml": {
        source: "iana",
        compressible: true
    },
    "application/gltf-buffer": {
        source: "iana"
    },
    "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "gml"
        ]
    },
    "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "gpx"
        ]
    },
    "application/gxf": {
        source: "apache",
        extensions: [
            "gxf"
        ]
    },
    "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: [
            "gz"
        ]
    },
    "application/h224": {
        source: "iana"
    },
    "application/held+xml": {
        source: "iana",
        compressible: true
    },
    "application/hjson": {
        extensions: [
            "hjson"
        ]
    },
    "application/http": {
        source: "iana"
    },
    "application/hyperstudio": {
        source: "iana",
        extensions: [
            "stk"
        ]
    },
    "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
    },
    "application/ibe-pp-data": {
        source: "iana"
    },
    "application/iges": {
        source: "iana"
    },
    "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/index": {
        source: "iana"
    },
    "application/index.cmd": {
        source: "iana"
    },
    "application/index.obj": {
        source: "iana"
    },
    "application/index.response": {
        source: "iana"
    },
    "application/index.vnd": {
        source: "iana"
    },
    "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ink",
            "inkml"
        ]
    },
    "application/iotp": {
        source: "iana"
    },
    "application/ipfix": {
        source: "iana",
        extensions: [
            "ipfix"
        ]
    },
    "application/ipp": {
        source: "iana"
    },
    "application/isup": {
        source: "iana"
    },
    "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "its"
        ]
    },
    "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: [
            "jar",
            "war",
            "ear"
        ]
    },
    "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: [
            "ser"
        ]
    },
    "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: [
            "class"
        ]
    },
    "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "js",
            "mjs"
        ]
    },
    "application/jf2feed+json": {
        source: "iana",
        compressible: true
    },
    "application/jose": {
        source: "iana"
    },
    "application/jose+json": {
        source: "iana",
        compressible: true
    },
    "application/jrd+json": {
        source: "iana",
        compressible: true
    },
    "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "json",
            "map"
        ]
    },
    "application/json-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/json-seq": {
        source: "iana"
    },
    "application/json5": {
        extensions: [
            "json5"
        ]
    },
    "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: [
            "jsonml"
        ]
    },
    "application/jwk+json": {
        source: "iana",
        compressible: true
    },
    "application/jwk-set+json": {
        source: "iana",
        compressible: true
    },
    "application/jwt": {
        source: "iana"
    },
    "application/kpml-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/kpml-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "jsonld"
        ]
    },
    "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lgr"
        ]
    },
    "application/link-format": {
        source: "iana"
    },
    "application/load-control+xml": {
        source: "iana",
        compressible: true
    },
    "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lostxml"
        ]
    },
    "application/lostsync+xml": {
        source: "iana",
        compressible: true
    },
    "application/lpf+zip": {
        source: "iana",
        compressible: false
    },
    "application/lxf": {
        source: "iana"
    },
    "application/mac-binhex40": {
        source: "iana",
        extensions: [
            "hqx"
        ]
    },
    "application/mac-compactpro": {
        source: "apache",
        extensions: [
            "cpt"
        ]
    },
    "application/macwriteii": {
        source: "iana"
    },
    "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mads"
        ]
    },
    "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "webmanifest"
        ]
    },
    "application/marc": {
        source: "iana",
        extensions: [
            "mrc"
        ]
    },
    "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mrcx"
        ]
    },
    "application/mathematica": {
        source: "iana",
        extensions: [
            "ma",
            "nb",
            "mb"
        ]
    },
    "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mathml"
        ]
    },
    "application/mathml-content+xml": {
        source: "iana",
        compressible: true
    },
    "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-register+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbox": {
        source: "iana",
        extensions: [
            "mbox"
        ]
    },
    "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
    },
    "application/media_control+xml": {
        source: "iana",
        compressible: true
    },
    "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mscml"
        ]
    },
    "application/merge-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "metalink"
        ]
    },
    "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "meta4"
        ]
    },
    "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mets"
        ]
    },
    "application/mf4": {
        source: "iana"
    },
    "application/mikey": {
        source: "iana"
    },
    "application/mipc": {
        source: "iana"
    },
    "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "maei"
        ]
    },
    "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "musd"
        ]
    },
    "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mods"
        ]
    },
    "application/moss-keys": {
        source: "iana"
    },
    "application/moss-signature": {
        source: "iana"
    },
    "application/mosskey-data": {
        source: "iana"
    },
    "application/mosskey-request": {
        source: "iana"
    },
    "application/mp21": {
        source: "iana",
        extensions: [
            "m21",
            "mp21"
        ]
    },
    "application/mp4": {
        source: "iana",
        extensions: [
            "mp4s",
            "m4p"
        ]
    },
    "application/mpeg4-generic": {
        source: "iana"
    },
    "application/mpeg4-iod": {
        source: "iana"
    },
    "application/mpeg4-iod-xmt": {
        source: "iana"
    },
    "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/mrb-publish+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/msword": {
        source: "iana",
        compressible: false,
        extensions: [
            "doc",
            "dot"
        ]
    },
    "application/mud+json": {
        source: "iana",
        compressible: true
    },
    "application/multipart-core": {
        source: "iana"
    },
    "application/mxf": {
        source: "iana",
        extensions: [
            "mxf"
        ]
    },
    "application/n-quads": {
        source: "iana",
        extensions: [
            "nq"
        ]
    },
    "application/n-triples": {
        source: "iana",
        extensions: [
            "nt"
        ]
    },
    "application/nasdata": {
        source: "iana"
    },
    "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
    },
    "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
    },
    "application/news-transmission": {
        source: "iana"
    },
    "application/nlsml+xml": {
        source: "iana",
        compressible: true
    },
    "application/node": {
        source: "iana",
        extensions: [
            "cjs"
        ]
    },
    "application/nss": {
        source: "iana"
    },
    "application/ocsp-request": {
        source: "iana"
    },
    "application/ocsp-response": {
        source: "iana"
    },
    "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: [
            "bin",
            "dms",
            "lrf",
            "mar",
            "so",
            "dist",
            "distz",
            "pkg",
            "bpk",
            "dump",
            "elc",
            "deploy",
            "exe",
            "dll",
            "deb",
            "dmg",
            "iso",
            "img",
            "msi",
            "msp",
            "msm",
            "buffer", 
        ]
    },
    "application/oda": {
        source: "iana",
        extensions: [
            "oda"
        ]
    },
    "application/odm+xml": {
        source: "iana",
        compressible: true
    },
    "application/odx": {
        source: "iana"
    },
    "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "opf"
        ]
    },
    "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "ogx"
        ]
    },
    "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "omdoc"
        ]
    },
    "application/onenote": {
        source: "apache",
        extensions: [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ]
    },
    "application/oscore": {
        source: "iana"
    },
    "application/oxps": {
        source: "iana",
        extensions: [
            "oxps"
        ]
    },
    "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "relo"
        ]
    },
    "application/parityfec": {
        source: "iana"
    },
    "application/passport": {
        source: "iana"
    },
    "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xer"
        ]
    },
    "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: [
            "pdf"
        ]
    },
    "application/pdx": {
        source: "iana"
    },
    "application/pem-certificate-chain": {
        source: "iana"
    },
    "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: [
            "pgp"
        ]
    },
    "application/pgp-keys": {
        source: "iana"
    },
    "application/pgp-signature": {
        source: "iana",
        extensions: [
            "asc",
            "sig"
        ]
    },
    "application/pics-rules": {
        source: "apache",
        extensions: [
            "prf"
        ]
    },
    "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/pkcs10": {
        source: "iana",
        extensions: [
            "p10"
        ]
    },
    "application/pkcs12": {
        source: "iana"
    },
    "application/pkcs7-mime": {
        source: "iana",
        extensions: [
            "p7m",
            "p7c"
        ]
    },
    "application/pkcs7-signature": {
        source: "iana",
        extensions: [
            "p7s"
        ]
    },
    "application/pkcs8": {
        source: "iana",
        extensions: [
            "p8"
        ]
    },
    "application/pkcs8-encrypted": {
        source: "iana"
    },
    "application/pkix-attr-cert": {
        source: "iana",
        extensions: [
            "ac"
        ]
    },
    "application/pkix-cert": {
        source: "iana",
        extensions: [
            "cer"
        ]
    },
    "application/pkix-crl": {
        source: "iana",
        extensions: [
            "crl"
        ]
    },
    "application/pkix-pkipath": {
        source: "iana",
        extensions: [
            "pkipath"
        ]
    },
    "application/pkixcmp": {
        source: "iana",
        extensions: [
            "pki"
        ]
    },
    "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "pls"
        ]
    },
    "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: [
            "ai",
            "eps",
            "ps"
        ]
    },
    "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
    },
    "application/problem+json": {
        source: "iana",
        compressible: true
    },
    "application/problem+xml": {
        source: "iana",
        compressible: true
    },
    "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "provx"
        ]
    },
    "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
    },
    "application/prs.cww": {
        source: "iana",
        extensions: [
            "cww"
        ]
    },
    "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
    },
    "application/prs.nprend": {
        source: "iana"
    },
    "application/prs.plucker": {
        source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
        source: "iana"
    },
    "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
    },
    "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "pskcxml"
        ]
    },
    "application/pvd+json": {
        source: "iana",
        compressible: true
    },
    "application/qsig": {
        source: "iana"
    },
    "application/raml+yaml": {
        compressible: true,
        extensions: [
            "raml"
        ]
    },
    "application/raptorfec": {
        source: "iana"
    },
    "application/rdap+json": {
        source: "iana",
        compressible: true
    },
    "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rdf",
            "owl"
        ]
    },
    "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rif"
        ]
    },
    "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: [
            "rnc"
        ]
    },
    "application/remote-printing": {
        source: "iana"
    },
    "application/reputon+json": {
        source: "iana",
        compressible: true
    },
    "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rl"
        ]
    },
    "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rld"
        ]
    },
    "application/rfc+xml": {
        source: "iana",
        compressible: true
    },
    "application/riscos": {
        source: "iana"
    },
    "application/rlmi+xml": {
        source: "iana",
        compressible: true
    },
    "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rs"
        ]
    },
    "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rapd"
        ]
    },
    "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sls"
        ]
    },
    "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rusd"
        ]
    },
    "application/rpki-ghostbusters": {
        source: "iana",
        extensions: [
            "gbr"
        ]
    },
    "application/rpki-manifest": {
        source: "iana",
        extensions: [
            "mft"
        ]
    },
    "application/rpki-publication": {
        source: "iana"
    },
    "application/rpki-roa": {
        source: "iana",
        extensions: [
            "roa"
        ]
    },
    "application/rpki-updown": {
        source: "iana"
    },
    "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "rsd"
        ]
    },
    "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "rss"
        ]
    },
    "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtf"
        ]
    },
    "application/rtploopback": {
        source: "iana"
    },
    "application/rtx": {
        source: "iana"
    },
    "application/samlassertion+xml": {
        source: "iana",
        compressible: true
    },
    "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/sbe": {
        source: "iana"
    },
    "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sbml"
        ]
    },
    "application/scaip+xml": {
        source: "iana",
        compressible: true
    },
    "application/scim+json": {
        source: "iana",
        compressible: true
    },
    "application/scvp-cv-request": {
        source: "iana",
        extensions: [
            "scq"
        ]
    },
    "application/scvp-cv-response": {
        source: "iana",
        extensions: [
            "scs"
        ]
    },
    "application/scvp-vp-request": {
        source: "iana",
        extensions: [
            "spq"
        ]
    },
    "application/scvp-vp-response": {
        source: "iana",
        extensions: [
            "spp"
        ]
    },
    "application/sdp": {
        source: "iana",
        extensions: [
            "sdp"
        ]
    },
    "application/secevent+jwt": {
        source: "iana"
    },
    "application/senml+cbor": {
        source: "iana"
    },
    "application/senml+json": {
        source: "iana",
        compressible: true
    },
    "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "senmlx"
        ]
    },
    "application/senml-etch+cbor": {
        source: "iana"
    },
    "application/senml-etch+json": {
        source: "iana",
        compressible: true
    },
    "application/senml-exi": {
        source: "iana"
    },
    "application/sensml+cbor": {
        source: "iana"
    },
    "application/sensml+json": {
        source: "iana",
        compressible: true
    },
    "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sensmlx"
        ]
    },
    "application/sensml-exi": {
        source: "iana"
    },
    "application/sep+xml": {
        source: "iana",
        compressible: true
    },
    "application/sep-exi": {
        source: "iana"
    },
    "application/session-info": {
        source: "iana"
    },
    "application/set-payment": {
        source: "iana"
    },
    "application/set-payment-initiation": {
        source: "iana",
        extensions: [
            "setpay"
        ]
    },
    "application/set-registration": {
        source: "iana"
    },
    "application/set-registration-initiation": {
        source: "iana",
        extensions: [
            "setreg"
        ]
    },
    "application/sgml": {
        source: "iana"
    },
    "application/sgml-open-catalog": {
        source: "iana"
    },
    "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "shf"
        ]
    },
    "application/sieve": {
        source: "iana",
        extensions: [
            "siv",
            "sieve"
        ]
    },
    "application/simple-filter+xml": {
        source: "iana",
        compressible: true
    },
    "application/simple-message-summary": {
        source: "iana"
    },
    "application/simplesymbolcontainer": {
        source: "iana"
    },
    "application/sipc": {
        source: "iana"
    },
    "application/slate": {
        source: "iana"
    },
    "application/smil": {
        source: "iana"
    },
    "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "smi",
            "smil"
        ]
    },
    "application/smpte336m": {
        source: "iana"
    },
    "application/soap+fastinfoset": {
        source: "iana"
    },
    "application/soap+xml": {
        source: "iana",
        compressible: true
    },
    "application/sparql-query": {
        source: "iana",
        extensions: [
            "rq"
        ]
    },
    "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "srx"
        ]
    },
    "application/spirits-event+xml": {
        source: "iana",
        compressible: true
    },
    "application/sql": {
        source: "iana"
    },
    "application/srgs": {
        source: "iana",
        extensions: [
            "gram"
        ]
    },
    "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "grxml"
        ]
    },
    "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sru"
        ]
    },
    "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "ssdl"
        ]
    },
    "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ssml"
        ]
    },
    "application/stix+json": {
        source: "iana",
        compressible: true
    },
    "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "swidtag"
        ]
    },
    "application/tamp-apex-update": {
        source: "iana"
    },
    "application/tamp-apex-update-confirm": {
        source: "iana"
    },
    "application/tamp-community-update": {
        source: "iana"
    },
    "application/tamp-community-update-confirm": {
        source: "iana"
    },
    "application/tamp-error": {
        source: "iana"
    },
    "application/tamp-sequence-adjust": {
        source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
        source: "iana"
    },
    "application/tamp-status-query": {
        source: "iana"
    },
    "application/tamp-status-response": {
        source: "iana"
    },
    "application/tamp-update": {
        source: "iana"
    },
    "application/tamp-update-confirm": {
        source: "iana"
    },
    "application/tar": {
        compressible: true
    },
    "application/taxii+json": {
        source: "iana",
        compressible: true
    },
    "application/td+json": {
        source: "iana",
        compressible: true
    },
    "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "tei",
            "teicorpus"
        ]
    },
    "application/tetra_isi": {
        source: "iana"
    },
    "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "tfi"
        ]
    },
    "application/timestamp-query": {
        source: "iana"
    },
    "application/timestamp-reply": {
        source: "iana"
    },
    "application/timestamped-data": {
        source: "iana",
        extensions: [
            "tsd"
        ]
    },
    "application/tlsrpt+gzip": {
        source: "iana"
    },
    "application/tlsrpt+json": {
        source: "iana",
        compressible: true
    },
    "application/tnauthlist": {
        source: "iana"
    },
    "application/toml": {
        compressible: true,
        extensions: [
            "toml"
        ]
    },
    "application/trickle-ice-sdpfrag": {
        source: "iana"
    },
    "application/trig": {
        source: "iana"
    },
    "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ttml"
        ]
    },
    "application/tve-trigger": {
        source: "iana"
    },
    "application/tzif": {
        source: "iana"
    },
    "application/tzif-leap": {
        source: "iana"
    },
    "application/ulpfec": {
        source: "iana"
    },
    "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rsheet"
        ]
    },
    "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true
    },
    "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vcard+json": {
        source: "iana",
        compressible: true
    },
    "application/vcard+xml": {
        source: "iana",
        compressible: true
    },
    "application/vemmi": {
        source: "iana"
    },
    "application/vividence.scriptfile": {
        source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "1km"
        ]
    },
    "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: [
            "plb"
        ]
    },
    "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: [
            "psb"
        ]
    },
    "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: [
            "pvb"
        ]
    },
    "application/vnd.3gpp.sms": {
        source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp2.sms": {
        source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: [
            "tcap"
        ]
    },
    "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: [
            "pwn"
        ]
    },
    "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: [
            "aso"
        ]
    },
    "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: [
            "imp"
        ]
    },
    "application/vnd.acucobol": {
        source: "iana",
        extensions: [
            "acu"
        ]
    },
    "application/vnd.acucorp": {
        source: "iana",
        extensions: [
            "atc",
            "acutc"
        ]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: [
            "air"
        ]
    },
    "application/vnd.adobe.flash.movie": {
        source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: [
            "fcdt"
        ]
    },
    "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: [
            "fxp",
            "fxpl"
        ]
    },
    "application/vnd.adobe.partial-upload": {
        source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdp"
        ]
    },
    "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: [
            "xfdf"
        ]
    },
    "application/vnd.aether.imp": {
        source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
        source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
        source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
        source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
        source: "iana"
    },
    "application/vnd.afpc.modca": {
        source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
        source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
        source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
        source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
    },
    "application/vnd.ah-barcode": {
        source: "iana"
    },
    "application/vnd.ahead.space": {
        source: "iana",
        extensions: [
            "ahead"
        ]
    },
    "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: [
            "azf"
        ]
    },
    "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: [
            "azs"
        ]
    },
    "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: [
            "azw"
        ]
    },
    "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
    },
    "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: [
            "acc"
        ]
    },
    "application/vnd.amiga.ami": {
        source: "iana",
        extensions: [
            "ami"
        ]
    },
    "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.android.ota": {
        source: "iana"
    },
    "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: [
            "apk"
        ]
    },
    "application/vnd.anki": {
        source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: [
            "cii"
        ]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: [
            "fti"
        ]
    },
    "application/vnd.antix.game-component": {
        source: "iana",
        extensions: [
            "atx"
        ]
    },
    "application/vnd.apache.thrift.binary": {
        source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
        source: "iana"
    },
    "application/vnd.apache.thrift.json": {
        source: "iana"
    },
    "application/vnd.api+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mpkg"
        ]
    },
    "application/vnd.apple.keynote": {
        source: "iana",
        extensions: [
            "keynote"
        ]
    },
    "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: [
            "m3u8"
        ]
    },
    "application/vnd.apple.numbers": {
        source: "iana",
        extensions: [
            "numbers"
        ]
    },
    "application/vnd.apple.pages": {
        source: "iana",
        extensions: [
            "pages"
        ]
    },
    "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: [
            "pkpass"
        ]
    },
    "application/vnd.arastra.swi": {
        source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: [
            "swi"
        ]
    },
    "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.artsquare": {
        source: "iana"
    },
    "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: [
            "iota"
        ]
    },
    "application/vnd.audiograph": {
        source: "iana",
        extensions: [
            "aep"
        ]
    },
    "application/vnd.autopackage": {
        source: "iana"
    },
    "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "bmml"
        ]
    },
    "application/vnd.balsamiq.bmpr": {
        source: "iana"
    },
    "application/vnd.banana-accounting": {
        source: "iana"
    },
    "application/vnd.bbf.usp.error": {
        source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
        source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.bint.med-content": {
        source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
    },
    "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: [
            "mpm"
        ]
    },
    "application/vnd.bluetooth.ep.oob": {
        source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
        source: "iana"
    },
    "application/vnd.bmi": {
        source: "iana",
        extensions: [
            "bmi"
        ]
    },
    "application/vnd.bpf": {
        source: "iana"
    },
    "application/vnd.bpf3": {
        source: "iana"
    },
    "application/vnd.businessobjects": {
        source: "iana",
        extensions: [
            "rep"
        ]
    },
    "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cab-jscript": {
        source: "iana"
    },
    "application/vnd.canon-cpdl": {
        source: "iana"
    },
    "application/vnd.canon-lips": {
        source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
        source: "iana"
    },
    "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "cdxml"
        ]
    },
    "application/vnd.chess-pgn": {
        source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: [
            "mmd"
        ]
    },
    "application/vnd.ciedi": {
        source: "iana"
    },
    "application/vnd.cinderella": {
        source: "iana",
        extensions: [
            "cdy"
        ]
    },
    "application/vnd.cirpack.isdn-ext": {
        source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "csl"
        ]
    },
    "application/vnd.claymore": {
        source: "iana",
        extensions: [
            "cla"
        ]
    },
    "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: [
            "rp9"
        ]
    },
    "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: [
            "c11amc"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: [
            "c11amz"
        ]
    },
    "application/vnd.coffeescript": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
    },
    "application/vnd.collection+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.comicbook-rar": {
        source: "iana"
    },
    "application/vnd.commerce-battelle": {
        source: "iana"
    },
    "application/vnd.commonspace": {
        source: "iana",
        extensions: [
            "csp"
        ]
    },
    "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: [
            "cdbcmsg"
        ]
    },
    "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cosmocaller": {
        source: "iana",
        extensions: [
            "cmc"
        ]
    },
    "application/vnd.crick.clicker": {
        source: "iana",
        extensions: [
            "clkx"
        ]
    },
    "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: [
            "clkk"
        ]
    },
    "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: [
            "clkp"
        ]
    },
    "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: [
            "clkt"
        ]
    },
    "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: [
            "clkw"
        ]
    },
    "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wbs"
        ]
    },
    "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.crypto-shade-file": {
        source: "iana"
    },
    "application/vnd.ctc-posml": {
        source: "iana",
        extensions: [
            "pml"
        ]
    },
    "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cups-pdf": {
        source: "iana"
    },
    "application/vnd.cups-postscript": {
        source: "iana"
    },
    "application/vnd.cups-ppd": {
        source: "iana",
        extensions: [
            "ppd"
        ]
    },
    "application/vnd.cups-raster": {
        source: "iana"
    },
    "application/vnd.cups-raw": {
        source: "iana"
    },
    "application/vnd.curl": {
        source: "iana"
    },
    "application/vnd.curl.car": {
        source: "apache",
        extensions: [
            "car"
        ]
    },
    "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: [
            "pcurl"
        ]
    },
    "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cybank": {
        source: "iana"
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: [
            "dart"
        ]
    },
    "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: [
            "rdz"
        ]
    },
    "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dbf": {
        source: "iana"
    },
    "application/vnd.debian.binary-package": {
        source: "iana"
    },
    "application/vnd.dece.data": {
        source: "iana",
        extensions: [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ]
    },
    "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "uvt",
            "uvvt"
        ]
    },
    "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: [
            "uvx",
            "uvvx"
        ]
    },
    "application/vnd.dece.zip": {
        source: "iana",
        extensions: [
            "uvz",
            "uvvz"
        ]
    },
    "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: [
            "fe_launch"
        ]
    },
    "application/vnd.desmume.movie": {
        source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dna": {
        source: "iana",
        extensions: [
            "dna"
        ]
    },
    "application/vnd.document+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: [
            "mlp"
        ]
    },
    "application/vnd.dolby.mobile.1": {
        source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
        source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
    },
    "application/vnd.dpgraph": {
        source: "iana",
        extensions: [
            "dpg"
        ]
    },
    "application/vnd.dreamfactory": {
        source: "iana",
        extensions: [
            "dfac"
        ]
    },
    "application/vnd.drive+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: [
            "kpxx"
        ]
    },
    "application/vnd.dtg.local": {
        source: "iana"
    },
    "application/vnd.dtg.local.flash": {
        source: "iana"
    },
    "application/vnd.dtg.local.html": {
        source: "iana"
    },
    "application/vnd.dvb.ait": {
        source: "iana",
        extensions: [
            "ait"
        ]
    },
    "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.dvbj": {
        source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
        source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.pfr": {
        source: "iana"
    },
    "application/vnd.dvb.service": {
        source: "iana",
        extensions: [
            "svc"
        ]
    },
    "application/vnd.dxr": {
        source: "iana"
    },
    "application/vnd.dynageo": {
        source: "iana",
        extensions: [
            "geo"
        ]
    },
    "application/vnd.dzr": {
        source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
    },
    "application/vnd.ecdis-update": {
        source: "iana"
    },
    "application/vnd.ecip.rlp": {
        source: "iana"
    },
    "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: [
            "mag"
        ]
    },
    "application/vnd.ecowin.filerequest": {
        source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
        source: "iana"
    },
    "application/vnd.ecowin.series": {
        source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
        source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
        source: "iana"
    },
    "application/vnd.efi.img": {
        source: "iana"
    },
    "application/vnd.efi.iso": {
        source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.enliven": {
        source: "iana",
        extensions: [
            "nml"
        ]
    },
    "application/vnd.enphase.envoy": {
        source: "iana"
    },
    "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.epson.esf": {
        source: "iana",
        extensions: [
            "esf"
        ]
    },
    "application/vnd.epson.msf": {
        source: "iana",
        extensions: [
            "msf"
        ]
    },
    "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: [
            "qam"
        ]
    },
    "application/vnd.epson.salt": {
        source: "iana",
        extensions: [
            "slt"
        ]
    },
    "application/vnd.epson.ssf": {
        source: "iana",
        extensions: [
            "ssf"
        ]
    },
    "application/vnd.ericsson.quickcall": {
        source: "iana"
    },
    "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "es3",
            "et3"
        ]
    },
    "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.mheg5": {
        source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
        source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.tsl.der": {
        source: "iana"
    },
    "application/vnd.eudora.data": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
        source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.exstream-package": {
        source: "iana"
    },
    "application/vnd.ezpix-album": {
        source: "iana",
        extensions: [
            "ez2"
        ]
    },
    "application/vnd.ezpix-package": {
        source: "iana",
        extensions: [
            "ez3"
        ]
    },
    "application/vnd.f-secure.mobile": {
        source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
        source: "iana"
    },
    "application/vnd.fdf": {
        source: "iana",
        extensions: [
            "fdf"
        ]
    },
    "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: [
            "mseed"
        ]
    },
    "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: [
            "seed",
            "dataless"
        ]
    },
    "application/vnd.ffsns": {
        source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.filmit.zfc": {
        source: "iana"
    },
    "application/vnd.fints": {
        source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
    },
    "application/vnd.flographit": {
        source: "iana",
        extensions: [
            "gph"
        ]
    },
    "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: [
            "ftc"
        ]
    },
    "application/vnd.font-fontforge-sfd": {
        source: "iana"
    },
    "application/vnd.framemaker": {
        source: "iana",
        extensions: [
            "fm",
            "frame",
            "maker",
            "book"
        ]
    },
    "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: [
            "fnc"
        ]
    },
    "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: [
            "ltf"
        ]
    },
    "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: [
            "fsc"
        ]
    },
    "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: [
            "oas"
        ]
    },
    "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: [
            "oa2"
        ]
    },
    "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: [
            "oa3"
        ]
    },
    "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: [
            "fg5"
        ]
    },
    "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: [
            "bh2"
        ]
    },
    "application/vnd.fujixerox.art-ex": {
        source: "iana"
    },
    "application/vnd.fujixerox.art4": {
        source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: [
            "ddd"
        ]
    },
    "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: [
            "xdw"
        ]
    },
    "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: [
            "xbd"
        ]
    },
    "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
        source: "iana"
    },
    "application/vnd.fut-misnet": {
        source: "iana"
    },
    "application/vnd.futoin+cbor": {
        source: "iana"
    },
    "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: [
            "fzs"
        ]
    },
    "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: [
            "txd"
        ]
    },
    "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geo+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geogebra.file": {
        source: "iana",
        extensions: [
            "ggb"
        ]
    },
    "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: [
            "ggt"
        ]
    },
    "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: [
            "gex",
            "gre"
        ]
    },
    "application/vnd.geonext": {
        source: "iana",
        extensions: [
            "gxt"
        ]
    },
    "application/vnd.geoplan": {
        source: "iana",
        extensions: [
            "g2w"
        ]
    },
    "application/vnd.geospace": {
        source: "iana",
        extensions: [
            "g3w"
        ]
    },
    "application/vnd.gerber": {
        source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
    },
    "application/vnd.gmx": {
        source: "iana",
        extensions: [
            "gmx"
        ]
    },
    "application/vnd.google-apps.document": {
        compressible: false,
        extensions: [
            "gdoc"
        ]
    },
    "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: [
            "gslides"
        ]
    },
    "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: [
            "gsheet"
        ]
    },
    "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "kml"
        ]
    },
    "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: [
            "kmz"
        ]
    },
    "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.grafeq": {
        source: "iana",
        extensions: [
            "gqf",
            "gqs"
        ]
    },
    "application/vnd.gridmp": {
        source: "iana"
    },
    "application/vnd.groove-account": {
        source: "iana",
        extensions: [
            "gac"
        ]
    },
    "application/vnd.groove-help": {
        source: "iana",
        extensions: [
            "ghf"
        ]
    },
    "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: [
            "gim"
        ]
    },
    "application/vnd.groove-injector": {
        source: "iana",
        extensions: [
            "grv"
        ]
    },
    "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: [
            "gtm"
        ]
    },
    "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: [
            "tpl"
        ]
    },
    "application/vnd.groove-vcard": {
        source: "iana",
        extensions: [
            "vcg"
        ]
    },
    "application/vnd.hal+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "hal"
        ]
    },
    "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "zmm"
        ]
    },
    "application/vnd.hbci": {
        source: "iana",
        extensions: [
            "hbci"
        ]
    },
    "application/vnd.hc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hcl-bireports": {
        source: "iana"
    },
    "application/vnd.hdt": {
        source: "iana"
    },
    "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: [
            "les"
        ]
    },
    "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: [
            "hpgl"
        ]
    },
    "application/vnd.hp-hpid": {
        source: "iana",
        extensions: [
            "hpid"
        ]
    },
    "application/vnd.hp-hps": {
        source: "iana",
        extensions: [
            "hps"
        ]
    },
    "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: [
            "jlt"
        ]
    },
    "application/vnd.hp-pcl": {
        source: "iana",
        extensions: [
            "pcl"
        ]
    },
    "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: [
            "pclxl"
        ]
    },
    "application/vnd.httphone": {
        source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: [
            "sfd-hdstx"
        ]
    },
    "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
        source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
        source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
        source: "iana"
    },
    "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: [
            "mpy"
        ]
    },
    "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: [
            "afp",
            "listafp",
            "list3820"
        ]
    },
    "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: [
            "irm"
        ]
    },
    "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: [
            "sc"
        ]
    },
    "application/vnd.iccprofile": {
        source: "iana",
        extensions: [
            "icc",
            "icm"
        ]
    },
    "application/vnd.ieee.1905": {
        source: "iana"
    },
    "application/vnd.igloader": {
        source: "iana",
        extensions: [
            "igl"
        ]
    },
    "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: [
            "ivp"
        ]
    },
    "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: [
            "ivu"
        ]
    },
    "application/vnd.ims.imsccv1p1": {
        source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
        source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
        source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.informix-visionary": {
        source: "iana"
    },
    "application/vnd.infotech.project": {
        source: "iana"
    },
    "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
        source: "iana"
    },
    "application/vnd.insors.igm": {
        source: "iana",
        extensions: [
            "igm"
        ]
    },
    "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: [
            "xpw",
            "xpx"
        ]
    },
    "application/vnd.intergeo": {
        source: "iana",
        extensions: [
            "i2g"
        ]
    },
    "application/vnd.intertrust.digibox": {
        source: "iana"
    },
    "application/vnd.intertrust.nncp": {
        source: "iana"
    },
    "application/vnd.intu.qbo": {
        source: "iana",
        extensions: [
            "qbo"
        ]
    },
    "application/vnd.intu.qfx": {
        source: "iana",
        extensions: [
            "qfx"
        ]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: [
            "rcprofile"
        ]
    },
    "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "irp"
        ]
    },
    "application/vnd.is-xpr": {
        source: "iana",
        extensions: [
            "xpr"
        ]
    },
    "application/vnd.isac.fcs": {
        source: "iana",
        extensions: [
            "fcs"
        ]
    },
    "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.jam": {
        source: "iana",
        extensions: [
            "jam"
        ]
    },
    "application/vnd.japannet-directory-service": {
        source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-registration": {
        source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-verification": {
        source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
        source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: [
            "rms"
        ]
    },
    "application/vnd.jisp": {
        source: "iana",
        extensions: [
            "jisp"
        ]
    },
    "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: [
            "joda"
        ]
    },
    "application/vnd.jsk.isdn-ngn": {
        source: "iana"
    },
    "application/vnd.kahootz": {
        source: "iana",
        extensions: [
            "ktz",
            "ktr"
        ]
    },
    "application/vnd.kde.karbon": {
        source: "iana",
        extensions: [
            "karbon"
        ]
    },
    "application/vnd.kde.kchart": {
        source: "iana",
        extensions: [
            "chrt"
        ]
    },
    "application/vnd.kde.kformula": {
        source: "iana",
        extensions: [
            "kfo"
        ]
    },
    "application/vnd.kde.kivio": {
        source: "iana",
        extensions: [
            "flw"
        ]
    },
    "application/vnd.kde.kontour": {
        source: "iana",
        extensions: [
            "kon"
        ]
    },
    "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: [
            "kpr",
            "kpt"
        ]
    },
    "application/vnd.kde.kspread": {
        source: "iana",
        extensions: [
            "ksp"
        ]
    },
    "application/vnd.kde.kword": {
        source: "iana",
        extensions: [
            "kwd",
            "kwt"
        ]
    },
    "application/vnd.kenameaapp": {
        source: "iana",
        extensions: [
            "htke"
        ]
    },
    "application/vnd.kidspiration": {
        source: "iana",
        extensions: [
            "kia"
        ]
    },
    "application/vnd.kinar": {
        source: "iana",
        extensions: [
            "kne",
            "knp"
        ]
    },
    "application/vnd.koan": {
        source: "iana",
        extensions: [
            "skp",
            "skd",
            "skt",
            "skm"
        ]
    },
    "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: [
            "sse"
        ]
    },
    "application/vnd.las": {
        source: "iana"
    },
    "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lasxml"
        ]
    },
    "application/vnd.laszip": {
        source: "iana"
    },
    "application/vnd.leap+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: [
            "lbd"
        ]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lbe"
        ]
    },
    "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.loom": {
        source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: [
            "123"
        ]
    },
    "application/vnd.lotus-approach": {
        source: "iana",
        extensions: [
            "apr"
        ]
    },
    "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: [
            "pre"
        ]
    },
    "application/vnd.lotus-notes": {
        source: "iana",
        extensions: [
            "nsf"
        ]
    },
    "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: [
            "org"
        ]
    },
    "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: [
            "scm"
        ]
    },
    "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: [
            "lwp"
        ]
    },
    "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: [
            "portpkg"
        ]
    },
    "application/vnd.mapbox-vector-tile": {
        source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
        source: "iana"
    },
    "application/vnd.mason+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
        source: "iana"
    },
    "application/vnd.mcd": {
        source: "iana",
        extensions: [
            "mcd"
        ]
    },
    "application/vnd.medcalcdata": {
        source: "iana",
        extensions: [
            "mc1"
        ]
    },
    "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: [
            "cdkey"
        ]
    },
    "application/vnd.meridian-slingshot": {
        source: "iana"
    },
    "application/vnd.mfer": {
        source: "iana",
        extensions: [
            "mwf"
        ]
    },
    "application/vnd.mfmp": {
        source: "iana",
        extensions: [
            "mfm"
        ]
    },
    "application/vnd.micro+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: [
            "flo"
        ]
    },
    "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: [
            "igx"
        ]
    },
    "application/vnd.microsoft.portable-executable": {
        source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
    },
    "application/vnd.miele+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.mif": {
        source: "iana",
        extensions: [
            "mif"
        ]
    },
    "application/vnd.minisoft-hp3000-save": {
        source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
    },
    "application/vnd.mobius.daf": {
        source: "iana",
        extensions: [
            "daf"
        ]
    },
    "application/vnd.mobius.dis": {
        source: "iana",
        extensions: [
            "dis"
        ]
    },
    "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: [
            "mbk"
        ]
    },
    "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: [
            "mqy"
        ]
    },
    "application/vnd.mobius.msl": {
        source: "iana",
        extensions: [
            "msl"
        ]
    },
    "application/vnd.mobius.plc": {
        source: "iana",
        extensions: [
            "plc"
        ]
    },
    "application/vnd.mobius.txf": {
        source: "iana",
        extensions: [
            "txf"
        ]
    },
    "application/vnd.mophun.application": {
        source: "iana",
        extensions: [
            "mpn"
        ]
    },
    "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: [
            "mpc"
        ]
    },
    "application/vnd.motorola.flexsuite": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
    },
    "application/vnd.motorola.iprm": {
        source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xul"
        ]
    },
    "application/vnd.ms-3mfdocument": {
        source: "iana"
    },
    "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: [
            "cil"
        ]
    },
    "application/vnd.ms-asf": {
        source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: [
            "cab"
        ]
    },
    "application/vnd.ms-color.iccprofile": {
        source: "apache"
    },
    "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: [
            "xls",
            "xlm",
            "xla",
            "xlc",
            "xlt",
            "xlw"
        ]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlam"
        ]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlsb"
        ]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlsm"
        ]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "xltm"
        ]
    },
    "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: [
            "eot"
        ]
    },
    "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: [
            "chm"
        ]
    },
    "application/vnd.ms-ims": {
        source: "iana",
        extensions: [
            "ims"
        ]
    },
    "application/vnd.ms-lrm": {
        source: "iana",
        extensions: [
            "lrm"
        ]
    },
    "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: [
            "thmx"
        ]
    },
    "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
    },
    "application/vnd.ms-outlook": {
        compressible: false,
        extensions: [
            "msg"
        ]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: [
            "cat"
        ]
    },
    "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: [
            "stl"
        ]
    },
    "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: [
            "ppt",
            "pps",
            "pot"
        ]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: [
            "ppam"
        ]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: [
            "pptm"
        ]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: [
            "sldm"
        ]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: [
            "ppsm"
        ]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "potm"
        ]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-project": {
        source: "iana",
        extensions: [
            "mpp",
            "mpt"
        ]
    },
    "application/vnd.ms-tnef": {
        source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
        source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
        source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: [
            "docm"
        ]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "dotm"
        ]
    },
    "application/vnd.ms-works": {
        source: "iana",
        extensions: [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ]
    },
    "application/vnd.ms-wpl": {
        source: "iana",
        extensions: [
            "wpl"
        ]
    },
    "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: [
            "xps"
        ]
    },
    "application/vnd.msa-disk-image": {
        source: "iana"
    },
    "application/vnd.mseq": {
        source: "iana",
        extensions: [
            "mseq"
        ]
    },
    "application/vnd.msign": {
        source: "iana"
    },
    "application/vnd.multiad.creator": {
        source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
        source: "iana"
    },
    "application/vnd.music-niff": {
        source: "iana"
    },
    "application/vnd.musician": {
        source: "iana",
        extensions: [
            "mus"
        ]
    },
    "application/vnd.muvee.style": {
        source: "iana",
        extensions: [
            "msty"
        ]
    },
    "application/vnd.mynfc": {
        source: "iana",
        extensions: [
            "taglet"
        ]
    },
    "application/vnd.ncd.control": {
        source: "iana"
    },
    "application/vnd.ncd.reference": {
        source: "iana"
    },
    "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nervana": {
        source: "iana"
    },
    "application/vnd.netfpx": {
        source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: [
            "nlu"
        ]
    },
    "application/vnd.nimn": {
        source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
        source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
        source: "iana"
    },
    "application/vnd.nitf": {
        source: "iana",
        extensions: [
            "ntf",
            "nitf"
        ]
    },
    "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: [
            "nnd"
        ]
    },
    "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: [
            "nns"
        ]
    },
    "application/vnd.noblenet-web": {
        source: "iana",
        extensions: [
            "nnw"
        ]
    },
    "application/vnd.nokia.catalogs": {
        source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ac"
        ]
    },
    "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: [
            "ngdat"
        ]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: [
            "n-gage"
        ]
    },
    "application/vnd.nokia.ncd": {
        source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: [
            "rpst"
        ]
    },
    "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: [
            "rpss"
        ]
    },
    "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: [
            "edm"
        ]
    },
    "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: [
            "edx"
        ]
    },
    "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: [
            "ext"
        ]
    },
    "application/vnd.ntt-local.content-share": {
        source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
        source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: [
            "odc"
        ]
    },
    "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: [
            "otc"
        ]
    },
    "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: [
            "odb"
        ]
    },
    "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: [
            "odf"
        ]
    },
    "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: [
            "odft"
        ]
    },
    "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: [
            "odg"
        ]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: [
            "otg"
        ]
    },
    "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: [
            "odi"
        ]
    },
    "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: [
            "oti"
        ]
    },
    "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
            "odp"
        ]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: [
            "otp"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: [
            "ods"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: [
            "ots"
        ]
    },
    "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: [
            "odt"
        ]
    },
    "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: [
            "odm"
        ]
    },
    "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: [
            "ott"
        ]
    },
    "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: [
            "oth"
        ]
    },
    "application/vnd.obn": {
        source: "iana"
    },
    "application/vnd.ocf+cbor": {
        source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.pae.gem": {
        source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: [
            "xo"
        ]
    },
    "application/vnd.oma-scws-config": {
        source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
        source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
        source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
        source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
        source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
        source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
        source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.dcd": {
        source: "iana"
    },
    "application/vnd.oma.dcdc": {
        source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dd2"
        ]
    },
    "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
    },
    "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.push": {
        source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omaloc-supl-init": {
        source: "iana"
    },
    "application/vnd.onepager": {
        source: "iana"
    },
    "application/vnd.onepagertamp": {
        source: "iana"
    },
    "application/vnd.onepagertamx": {
        source: "iana"
    },
    "application/vnd.onepagertat": {
        source: "iana"
    },
    "application/vnd.onepagertatp": {
        source: "iana"
    },
    "application/vnd.onepagertatx": {
        source: "iana"
    },
    "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "obgx"
        ]
    },
    "application/vnd.openblox.game-binary": {
        source: "iana"
    },
    "application/vnd.openeye.oeb": {
        source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: [
            "oxt"
        ]
    },
    "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "osm"
        ]
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
            "pptx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: [
            "sldx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: [
            "ppsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: [
            "potx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: [
            "xlsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: [
            "xltx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: [
            "docx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: [
            "dotx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.orange.indata": {
        source: "iana"
    },
    "application/vnd.osa.netdeploy": {
        source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: [
            "mgp"
        ]
    },
    "application/vnd.osgi.bundle": {
        source: "iana"
    },
    "application/vnd.osgi.dp": {
        source: "iana",
        extensions: [
            "dp"
        ]
    },
    "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: [
            "esa"
        ]
    },
    "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oxli.countgraph": {
        source: "iana"
    },
    "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.palm": {
        source: "iana",
        extensions: [
            "pdb",
            "pqa",
            "oprc"
        ]
    },
    "application/vnd.panoply": {
        source: "iana"
    },
    "application/vnd.paos.xml": {
        source: "iana"
    },
    "application/vnd.patentdive": {
        source: "iana"
    },
    "application/vnd.patientecommsdoc": {
        source: "iana"
    },
    "application/vnd.pawaafile": {
        source: "iana",
        extensions: [
            "paw"
        ]
    },
    "application/vnd.pcos": {
        source: "iana"
    },
    "application/vnd.pg.format": {
        source: "iana",
        extensions: [
            "str"
        ]
    },
    "application/vnd.pg.osasli": {
        source: "iana",
        extensions: [
            "ei6"
        ]
    },
    "application/vnd.piaccess.application-licence": {
        source: "iana"
    },
    "application/vnd.picsel": {
        source: "iana",
        extensions: [
            "efif"
        ]
    },
    "application/vnd.pmi.widget": {
        source: "iana",
        extensions: [
            "wg"
        ]
    },
    "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.pocketlearn": {
        source: "iana",
        extensions: [
            "plf"
        ]
    },
    "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: [
            "pbd"
        ]
    },
    "application/vnd.powerbuilder6-s": {
        source: "iana"
    },
    "application/vnd.powerbuilder7": {
        source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
        source: "iana"
    },
    "application/vnd.powerbuilder75": {
        source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
        source: "iana"
    },
    "application/vnd.preminet": {
        source: "iana"
    },
    "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: [
            "box"
        ]
    },
    "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: [
            "mgz"
        ]
    },
    "application/vnd.psfs": {
        source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: [
            "qps"
        ]
    },
    "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: [
            "ptid"
        ]
    },
    "application/vnd.pwg-multiplexed": {
        source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
    },
    "application/vnd.quarantainenet": {
        source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ]
    },
    "application/vnd.quobject-quoxdocument": {
        source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.rainstor.data": {
        source: "iana"
    },
    "application/vnd.rapid": {
        source: "iana"
    },
    "application/vnd.rar": {
        source: "iana"
    },
    "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: [
            "bed"
        ]
    },
    "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: [
            "mxl"
        ]
    },
    "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "musicxml"
        ]
    },
    "application/vnd.renlearn.rlprint": {
        source: "iana"
    },
    "application/vnd.restful+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: [
            "cryptonote"
        ]
    },
    "application/vnd.rim.cod": {
        source: "apache",
        extensions: [
            "cod"
        ]
    },
    "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: [
            "rm"
        ]
    },
    "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: [
            "rmvb"
        ]
    },
    "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "link66"
        ]
    },
    "application/vnd.rs-274x": {
        source: "iana"
    },
    "application/vnd.ruckus.download": {
        source: "iana"
    },
    "application/vnd.s3sms": {
        source: "iana"
    },
    "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: [
            "st"
        ]
    },
    "application/vnd.sar": {
        source: "iana"
    },
    "application/vnd.sbm.cid": {
        source: "iana"
    },
    "application/vnd.sbm.mid2": {
        source: "iana"
    },
    "application/vnd.scribus": {
        source: "iana"
    },
    "application/vnd.sealed.3df": {
        source: "iana"
    },
    "application/vnd.sealed.csf": {
        source: "iana"
    },
    "application/vnd.sealed.doc": {
        source: "iana"
    },
    "application/vnd.sealed.eml": {
        source: "iana"
    },
    "application/vnd.sealed.mht": {
        source: "iana"
    },
    "application/vnd.sealed.net": {
        source: "iana"
    },
    "application/vnd.sealed.ppt": {
        source: "iana"
    },
    "application/vnd.sealed.tiff": {
        source: "iana"
    },
    "application/vnd.sealed.xls": {
        source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
    },
    "application/vnd.seemail": {
        source: "iana",
        extensions: [
            "see"
        ]
    },
    "application/vnd.sema": {
        source: "iana",
        extensions: [
            "sema"
        ]
    },
    "application/vnd.semd": {
        source: "iana",
        extensions: [
            "semd"
        ]
    },
    "application/vnd.semf": {
        source: "iana",
        extensions: [
            "semf"
        ]
    },
    "application/vnd.shade-save-file": {
        source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: [
            "ifm"
        ]
    },
    "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: [
            "itp"
        ]
    },
    "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: [
            "iif"
        ]
    },
    "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: [
            "ipk"
        ]
    },
    "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.shp": {
        source: "iana"
    },
    "application/vnd.shx": {
        source: "iana"
    },
    "application/vnd.sigrok.session": {
        source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: [
            "twd",
            "twds"
        ]
    },
    "application/vnd.siren+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.smaf": {
        source: "iana",
        extensions: [
            "mmf"
        ]
    },
    "application/vnd.smart.notebook": {
        source: "iana"
    },
    "application/vnd.smart.teacher": {
        source: "iana",
        extensions: [
            "teacher"
        ]
    },
    "application/vnd.snesdev-page-table": {
        source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "fo"
        ]
    },
    "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sdkm",
            "sdkd"
        ]
    },
    "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: [
            "dxp"
        ]
    },
    "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: [
            "sfs"
        ]
    },
    "application/vnd.sqlite3": {
        source: "iana"
    },
    "application/vnd.sss-cod": {
        source: "iana"
    },
    "application/vnd.sss-dtf": {
        source: "iana"
    },
    "application/vnd.sss-ntf": {
        source: "iana"
    },
    "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: [
            "sdc"
        ]
    },
    "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: [
            "sda"
        ]
    },
    "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: [
            "sdd"
        ]
    },
    "application/vnd.stardivision.math": {
        source: "apache",
        extensions: [
            "smf"
        ]
    },
    "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: [
            "sdw",
            "vor"
        ]
    },
    "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: [
            "sgl"
        ]
    },
    "application/vnd.stepmania.package": {
        source: "iana",
        extensions: [
            "smzip"
        ]
    },
    "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: [
            "sm"
        ]
    },
    "application/vnd.street-stream": {
        source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wadl"
        ]
    },
    "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: [
            "sxc"
        ]
    },
    "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: [
            "stc"
        ]
    },
    "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: [
            "sxd"
        ]
    },
    "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: [
            "std"
        ]
    },
    "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: [
            "sxi"
        ]
    },
    "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: [
            "sti"
        ]
    },
    "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: [
            "sxm"
        ]
    },
    "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: [
            "sxw"
        ]
    },
    "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: [
            "sxg"
        ]
    },
    "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: [
            "stw"
        ]
    },
    "application/vnd.sus-calendar": {
        source: "iana",
        extensions: [
            "sus",
            "susp"
        ]
    },
    "application/vnd.svd": {
        source: "iana",
        extensions: [
            "svd"
        ]
    },
    "application/vnd.swiftview-ics": {
        source: "iana"
    },
    "application/vnd.symbian.install": {
        source: "apache",
        extensions: [
            "sis",
            "sisx"
        ]
    },
    "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "xsm"
        ]
    },
    "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "bdm"
        ]
    },
    "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "xdm"
        ]
    },
    "application/vnd.syncml.dm.notification": {
        source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "ddf"
        ]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.syncml.ds.notification": {
        source: "iana"
    },
    "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: [
            "tao"
        ]
    },
    "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: [
            "pcap",
            "cap",
            "dmp"
        ]
    },
    "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tml": {
        source: "iana"
    },
    "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: [
            "tmo"
        ]
    },
    "application/vnd.tri.onesource": {
        source: "iana"
    },
    "application/vnd.trid.tpt": {
        source: "iana",
        extensions: [
            "tpt"
        ]
    },
    "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: [
            "mxs"
        ]
    },
    "application/vnd.trueapp": {
        source: "iana",
        extensions: [
            "tra"
        ]
    },
    "application/vnd.truedoc": {
        source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
        source: "iana"
    },
    "application/vnd.ufdl": {
        source: "iana",
        extensions: [
            "ufd",
            "ufdl"
        ]
    },
    "application/vnd.uiq.theme": {
        source: "iana",
        extensions: [
            "utz"
        ]
    },
    "application/vnd.umajin": {
        source: "iana",
        extensions: [
            "umj"
        ]
    },
    "application/vnd.unity": {
        source: "iana",
        extensions: [
            "unityweb"
        ]
    },
    "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "uoml"
        ]
    },
    "application/vnd.uplanet.alert": {
        source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
        source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
        source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.channel": {
        source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.list": {
        source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
        source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.signal": {
        source: "iana"
    },
    "application/vnd.uri-map": {
        source: "iana"
    },
    "application/vnd.valve.source.material": {
        source: "iana"
    },
    "application/vnd.vcx": {
        source: "iana",
        extensions: [
            "vcx"
        ]
    },
    "application/vnd.vd-study": {
        source: "iana"
    },
    "application/vnd.vectorworks": {
        source: "iana"
    },
    "application/vnd.vel+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.verimatrix.vcas": {
        source: "iana"
    },
    "application/vnd.veryant.thin": {
        source: "iana"
    },
    "application/vnd.ves.encrypted": {
        source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
        source: "iana"
    },
    "application/vnd.visio": {
        source: "iana",
        extensions: [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ]
    },
    "application/vnd.visionary": {
        source: "iana",
        extensions: [
            "vis"
        ]
    },
    "application/vnd.vividence.scriptfile": {
        source: "iana"
    },
    "application/vnd.vsf": {
        source: "iana",
        extensions: [
            "vsf"
        ]
    },
    "application/vnd.wap.sic": {
        source: "iana"
    },
    "application/vnd.wap.slc": {
        source: "iana"
    },
    "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "wbxml"
        ]
    },
    "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: [
            "wmlc"
        ]
    },
    "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: [
            "wmlsc"
        ]
    },
    "application/vnd.webturbo": {
        source: "iana",
        extensions: [
            "wtb"
        ]
    },
    "application/vnd.wfa.p2p": {
        source: "iana"
    },
    "application/vnd.wfa.wsc": {
        source: "iana"
    },
    "application/vnd.windows.devicepairing": {
        source: "iana"
    },
    "application/vnd.wmc": {
        source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
        source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
        source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
        source: "iana"
    },
    "application/vnd.wolfram.player": {
        source: "iana",
        extensions: [
            "nbp"
        ]
    },
    "application/vnd.wordperfect": {
        source: "iana",
        extensions: [
            "wpd"
        ]
    },
    "application/vnd.wqd": {
        source: "iana",
        extensions: [
            "wqd"
        ]
    },
    "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
    },
    "application/vnd.wt.stf": {
        source: "iana",
        extensions: [
            "stf"
        ]
    },
    "application/vnd.wv.csp+wbxml": {
        source: "iana"
    },
    "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xara": {
        source: "iana",
        extensions: [
            "xar"
        ]
    },
    "application/vnd.xfdl": {
        source: "iana",
        extensions: [
            "xfdl"
        ]
    },
    "application/vnd.xfdl.webform": {
        source: "iana"
    },
    "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xmpie.cpkg": {
        source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
        source: "iana"
    },
    "application/vnd.xmpie.plan": {
        source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
        source: "iana"
    },
    "application/vnd.xmpie.xlim": {
        source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: [
            "hvd"
        ]
    },
    "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: [
            "hvs"
        ]
    },
    "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: [
            "hvp"
        ]
    },
    "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: [
            "osf"
        ]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "osfpvg"
        ]
    },
    "application/vnd.yamaha.remote-setup": {
        source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: [
            "saf"
        ]
    },
    "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: [
            "spf"
        ]
    },
    "application/vnd.yamaha.through-ngn": {
        source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
    },
    "application/vnd.yaoweme": {
        source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: [
            "cmp"
        ]
    },
    "application/vnd.youtube.yt": {
        source: "iana"
    },
    "application/vnd.zul": {
        source: "iana",
        extensions: [
            "zir",
            "zirz"
        ]
    },
    "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "zaz"
        ]
    },
    "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "vxml"
        ]
    },
    "application/voucher-cms+json": {
        source: "iana",
        compressible: true
    },
    "application/vq-rtcpxr": {
        source: "iana"
    },
    "application/wasm": {
        compressible: true,
        extensions: [
            "wasm"
        ]
    },
    "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/webpush-options+json": {
        source: "iana",
        compressible: true
    },
    "application/whoispp-query": {
        source: "iana"
    },
    "application/whoispp-response": {
        source: "iana"
    },
    "application/widget": {
        source: "iana",
        extensions: [
            "wgt"
        ]
    },
    "application/winhlp": {
        source: "apache",
        extensions: [
            "hlp"
        ]
    },
    "application/wita": {
        source: "iana"
    },
    "application/wordperfect5.1": {
        source: "iana"
    },
    "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wsdl"
        ]
    },
    "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wspolicy"
        ]
    },
    "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
            "7z"
        ]
    },
    "application/x-abiword": {
        source: "apache",
        extensions: [
            "abw"
        ]
    },
    "application/x-ace-compressed": {
        source: "apache",
        extensions: [
            "ace"
        ]
    },
    "application/x-amf": {
        source: "apache"
    },
    "application/x-apple-diskimage": {
        source: "apache",
        extensions: [
            "dmg"
        ]
    },
    "application/x-arj": {
        compressible: false,
        extensions: [
            "arj"
        ]
    },
    "application/x-authorware-bin": {
        source: "apache",
        extensions: [
            "aab",
            "x32",
            "u32",
            "vox"
        ]
    },
    "application/x-authorware-map": {
        source: "apache",
        extensions: [
            "aam"
        ]
    },
    "application/x-authorware-seg": {
        source: "apache",
        extensions: [
            "aas"
        ]
    },
    "application/x-bcpio": {
        source: "apache",
        extensions: [
            "bcpio"
        ]
    },
    "application/x-bdoc": {
        compressible: false,
        extensions: [
            "bdoc"
        ]
    },
    "application/x-bittorrent": {
        source: "apache",
        extensions: [
            "torrent"
        ]
    },
    "application/x-blorb": {
        source: "apache",
        extensions: [
            "blb",
            "blorb"
        ]
    },
    "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: [
            "bz"
        ]
    },
    "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: [
            "bz2",
            "boz"
        ]
    },
    "application/x-cbr": {
        source: "apache",
        extensions: [
            "cbr",
            "cba",
            "cbt",
            "cbz",
            "cb7"
        ]
    },
    "application/x-cdlink": {
        source: "apache",
        extensions: [
            "vcd"
        ]
    },
    "application/x-cfs-compressed": {
        source: "apache",
        extensions: [
            "cfs"
        ]
    },
    "application/x-chat": {
        source: "apache",
        extensions: [
            "chat"
        ]
    },
    "application/x-chess-pgn": {
        source: "apache",
        extensions: [
            "pgn"
        ]
    },
    "application/x-chrome-extension": {
        extensions: [
            "crx"
        ]
    },
    "application/x-cocoa": {
        source: "nginx",
        extensions: [
            "cco"
        ]
    },
    "application/x-compress": {
        source: "apache"
    },
    "application/x-conference": {
        source: "apache",
        extensions: [
            "nsc"
        ]
    },
    "application/x-cpio": {
        source: "apache",
        extensions: [
            "cpio"
        ]
    },
    "application/x-csh": {
        source: "apache",
        extensions: [
            "csh"
        ]
    },
    "application/x-deb": {
        compressible: false
    },
    "application/x-debian-package": {
        source: "apache",
        extensions: [
            "deb",
            "udeb"
        ]
    },
    "application/x-dgc-compressed": {
        source: "apache",
        extensions: [
            "dgc"
        ]
    },
    "application/x-director": {
        source: "apache",
        extensions: [
            "dir",
            "dcr",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ]
    },
    "application/x-doom": {
        source: "apache",
        extensions: [
            "wad"
        ]
    },
    "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "ncx"
        ]
    },
    "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "dtb"
        ]
    },
    "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "res"
        ]
    },
    "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: [
            "dvi"
        ]
    },
    "application/x-envoy": {
        source: "apache",
        extensions: [
            "evy"
        ]
    },
    "application/x-eva": {
        source: "apache",
        extensions: [
            "eva"
        ]
    },
    "application/x-font-bdf": {
        source: "apache",
        extensions: [
            "bdf"
        ]
    },
    "application/x-font-dos": {
        source: "apache"
    },
    "application/x-font-framemaker": {
        source: "apache"
    },
    "application/x-font-ghostscript": {
        source: "apache",
        extensions: [
            "gsf"
        ]
    },
    "application/x-font-libgrx": {
        source: "apache"
    },
    "application/x-font-linux-psf": {
        source: "apache",
        extensions: [
            "psf"
        ]
    },
    "application/x-font-pcf": {
        source: "apache",
        extensions: [
            "pcf"
        ]
    },
    "application/x-font-snf": {
        source: "apache",
        extensions: [
            "snf"
        ]
    },
    "application/x-font-speedo": {
        source: "apache"
    },
    "application/x-font-sunos-news": {
        source: "apache"
    },
    "application/x-font-type1": {
        source: "apache",
        extensions: [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ]
    },
    "application/x-font-vfont": {
        source: "apache"
    },
    "application/x-freearc": {
        source: "apache",
        extensions: [
            "arc"
        ]
    },
    "application/x-futuresplash": {
        source: "apache",
        extensions: [
            "spl"
        ]
    },
    "application/x-gca-compressed": {
        source: "apache",
        extensions: [
            "gca"
        ]
    },
    "application/x-glulx": {
        source: "apache",
        extensions: [
            "ulx"
        ]
    },
    "application/x-gnumeric": {
        source: "apache",
        extensions: [
            "gnumeric"
        ]
    },
    "application/x-gramps-xml": {
        source: "apache",
        extensions: [
            "gramps"
        ]
    },
    "application/x-gtar": {
        source: "apache",
        extensions: [
            "gtar"
        ]
    },
    "application/x-gzip": {
        source: "apache"
    },
    "application/x-hdf": {
        source: "apache",
        extensions: [
            "hdf"
        ]
    },
    "application/x-httpd-php": {
        compressible: true,
        extensions: [
            "php"
        ]
    },
    "application/x-install-instructions": {
        source: "apache",
        extensions: [
            "install"
        ]
    },
    "application/x-iso9660-image": {
        source: "apache",
        extensions: [
            "iso"
        ]
    },
    "application/x-java-archive-diff": {
        source: "nginx",
        extensions: [
            "jardiff"
        ]
    },
    "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: [
            "jnlp"
        ]
    },
    "application/x-javascript": {
        compressible: true
    },
    "application/x-keepass2": {
        extensions: [
            "kdbx"
        ]
    },
    "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: [
            "latex"
        ]
    },
    "application/x-lua-bytecode": {
        extensions: [
            "luac"
        ]
    },
    "application/x-lzh-compressed": {
        source: "apache",
        extensions: [
            "lzh",
            "lha"
        ]
    },
    "application/x-makeself": {
        source: "nginx",
        extensions: [
            "run"
        ]
    },
    "application/x-mie": {
        source: "apache",
        extensions: [
            "mie"
        ]
    },
    "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: [
            "prc",
            "mobi"
        ]
    },
    "application/x-mpegurl": {
        compressible: false
    },
    "application/x-ms-application": {
        source: "apache",
        extensions: [
            "application"
        ]
    },
    "application/x-ms-shortcut": {
        source: "apache",
        extensions: [
            "lnk"
        ]
    },
    "application/x-ms-wmd": {
        source: "apache",
        extensions: [
            "wmd"
        ]
    },
    "application/x-ms-wmz": {
        source: "apache",
        extensions: [
            "wmz"
        ]
    },
    "application/x-ms-xbap": {
        source: "apache",
        extensions: [
            "xbap"
        ]
    },
    "application/x-msaccess": {
        source: "apache",
        extensions: [
            "mdb"
        ]
    },
    "application/x-msbinder": {
        source: "apache",
        extensions: [
            "obd"
        ]
    },
    "application/x-mscardfile": {
        source: "apache",
        extensions: [
            "crd"
        ]
    },
    "application/x-msclip": {
        source: "apache",
        extensions: [
            "clp"
        ]
    },
    "application/x-msdos-program": {
        extensions: [
            "exe"
        ]
    },
    "application/x-msdownload": {
        source: "apache",
        extensions: [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ]
    },
    "application/x-msmediaview": {
        source: "apache",
        extensions: [
            "mvb",
            "m13",
            "m14"
        ]
    },
    "application/x-msmetafile": {
        source: "apache",
        extensions: [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ]
    },
    "application/x-msmoney": {
        source: "apache",
        extensions: [
            "mny"
        ]
    },
    "application/x-mspublisher": {
        source: "apache",
        extensions: [
            "pub"
        ]
    },
    "application/x-msschedule": {
        source: "apache",
        extensions: [
            "scd"
        ]
    },
    "application/x-msterminal": {
        source: "apache",
        extensions: [
            "trm"
        ]
    },
    "application/x-mswrite": {
        source: "apache",
        extensions: [
            "wri"
        ]
    },
    "application/x-netcdf": {
        source: "apache",
        extensions: [
            "nc",
            "cdf"
        ]
    },
    "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: [
            "pac"
        ]
    },
    "application/x-nzb": {
        source: "apache",
        extensions: [
            "nzb"
        ]
    },
    "application/x-perl": {
        source: "nginx",
        extensions: [
            "pl",
            "pm"
        ]
    },
    "application/x-pilot": {
        source: "nginx",
        extensions: [
            "prc",
            "pdb"
        ]
    },
    "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: [
            "p12",
            "pfx"
        ]
    },
    "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: [
            "p7b",
            "spc"
        ]
    },
    "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: [
            "p7r"
        ]
    },
    "application/x-pki-message": {
        source: "iana"
    },
    "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
            "rar"
        ]
    },
    "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: [
            "rpm"
        ]
    },
    "application/x-research-info-systems": {
        source: "apache",
        extensions: [
            "ris"
        ]
    },
    "application/x-sea": {
        source: "nginx",
        extensions: [
            "sea"
        ]
    },
    "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: [
            "sh"
        ]
    },
    "application/x-shar": {
        source: "apache",
        extensions: [
            "shar"
        ]
    },
    "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: [
            "swf"
        ]
    },
    "application/x-silverlight-app": {
        source: "apache",
        extensions: [
            "xap"
        ]
    },
    "application/x-sql": {
        source: "apache",
        extensions: [
            "sql"
        ]
    },
    "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: [
            "sit"
        ]
    },
    "application/x-stuffitx": {
        source: "apache",
        extensions: [
            "sitx"
        ]
    },
    "application/x-subrip": {
        source: "apache",
        extensions: [
            "srt"
        ]
    },
    "application/x-sv4cpio": {
        source: "apache",
        extensions: [
            "sv4cpio"
        ]
    },
    "application/x-sv4crc": {
        source: "apache",
        extensions: [
            "sv4crc"
        ]
    },
    "application/x-t3vm-image": {
        source: "apache",
        extensions: [
            "t3"
        ]
    },
    "application/x-tads": {
        source: "apache",
        extensions: [
            "gam"
        ]
    },
    "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: [
            "tar"
        ]
    },
    "application/x-tcl": {
        source: "apache",
        extensions: [
            "tcl",
            "tk"
        ]
    },
    "application/x-tex": {
        source: "apache",
        extensions: [
            "tex"
        ]
    },
    "application/x-tex-tfm": {
        source: "apache",
        extensions: [
            "tfm"
        ]
    },
    "application/x-texinfo": {
        source: "apache",
        extensions: [
            "texinfo",
            "texi"
        ]
    },
    "application/x-tgif": {
        source: "apache",
        extensions: [
            "obj"
        ]
    },
    "application/x-ustar": {
        source: "apache",
        extensions: [
            "ustar"
        ]
    },
    "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: [
            "hdd"
        ]
    },
    "application/x-virtualbox-ova": {
        compressible: true,
        extensions: [
            "ova"
        ]
    },
    "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: [
            "ovf"
        ]
    },
    "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: [
            "vbox"
        ]
    },
    "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: [
            "vbox-extpack"
        ]
    },
    "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: [
            "vdi"
        ]
    },
    "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: [
            "vhd"
        ]
    },
    "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: [
            "vmdk"
        ]
    },
    "application/x-wais-source": {
        source: "apache",
        extensions: [
            "src"
        ]
    },
    "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: [
            "webapp"
        ]
    },
    "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
    },
    "application/x-x509-ca-cert": {
        source: "iana",
        extensions: [
            "der",
            "crt",
            "pem"
        ]
    },
    "application/x-x509-ca-ra-cert": {
        source: "iana"
    },
    "application/x-x509-next-ca-cert": {
        source: "iana"
    },
    "application/x-xfig": {
        source: "apache",
        extensions: [
            "fig"
        ]
    },
    "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xlf"
        ]
    },
    "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: [
            "xpi"
        ]
    },
    "application/x-xz": {
        source: "apache",
        extensions: [
            "xz"
        ]
    },
    "application/x-zmachine": {
        source: "apache",
        extensions: [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ]
    },
    "application/x400-bp": {
        source: "iana"
    },
    "application/xacml+xml": {
        source: "iana",
        compressible: true
    },
    "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xaml"
        ]
    },
    "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xav"
        ]
    },
    "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xca"
        ]
    },
    "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xel"
        ]
    },
    "application/xcap-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xer"
        ]
    },
    "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xns"
        ]
    },
    "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
    },
    "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xenc"
        ]
    },
    "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xhtml",
            "xht"
        ]
    },
    "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
    },
    "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xlf"
        ]
    },
    "application/xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xml",
            "xsl",
            "xsd",
            "rng"
        ]
    },
    "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: [
            "dtd"
        ]
    },
    "application/xml-external-parsed-entity": {
        source: "iana"
    },
    "application/xml-patch+xml": {
        source: "iana",
        compressible: true
    },
    "application/xmpp+xml": {
        source: "iana",
        compressible: true
    },
    "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xop"
        ]
    },
    "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xpl"
        ]
    },
    "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xslt"
        ]
    },
    "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xspf"
        ]
    },
    "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ]
    },
    "application/yang": {
        source: "iana",
        extensions: [
            "yang"
        ]
    },
    "application/yang-data+json": {
        source: "iana",
        compressible: true
    },
    "application/yang-data+xml": {
        source: "iana",
        compressible: true
    },
    "application/yang-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/yang-patch+xml": {
        source: "iana",
        compressible: true
    },
    "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "yin"
        ]
    },
    "application/zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "zip"
        ]
    },
    "application/zlib": {
        source: "iana"
    },
    "application/zstd": {
        source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
        source: "iana"
    },
    "audio/32kadpcm": {
        source: "iana"
    },
    "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: [
            "3gpp"
        ]
    },
    "audio/3gpp2": {
        source: "iana"
    },
    "audio/aac": {
        source: "iana"
    },
    "audio/ac3": {
        source: "iana"
    },
    "audio/adpcm": {
        source: "apache",
        extensions: [
            "adp"
        ]
    },
    "audio/amr": {
        source: "iana"
    },
    "audio/amr-wb": {
        source: "iana"
    },
    "audio/amr-wb+": {
        source: "iana"
    },
    "audio/aptx": {
        source: "iana"
    },
    "audio/asc": {
        source: "iana"
    },
    "audio/atrac-advanced-lossless": {
        source: "iana"
    },
    "audio/atrac-x": {
        source: "iana"
    },
    "audio/atrac3": {
        source: "iana"
    },
    "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: [
            "au",
            "snd"
        ]
    },
    "audio/bv16": {
        source: "iana"
    },
    "audio/bv32": {
        source: "iana"
    },
    "audio/clearmode": {
        source: "iana"
    },
    "audio/cn": {
        source: "iana"
    },
    "audio/dat12": {
        source: "iana"
    },
    "audio/dls": {
        source: "iana"
    },
    "audio/dsr-es201108": {
        source: "iana"
    },
    "audio/dsr-es202050": {
        source: "iana"
    },
    "audio/dsr-es202211": {
        source: "iana"
    },
    "audio/dsr-es202212": {
        source: "iana"
    },
    "audio/dv": {
        source: "iana"
    },
    "audio/dvi4": {
        source: "iana"
    },
    "audio/eac3": {
        source: "iana"
    },
    "audio/encaprtp": {
        source: "iana"
    },
    "audio/evrc": {
        source: "iana"
    },
    "audio/evrc-qcp": {
        source: "iana"
    },
    "audio/evrc0": {
        source: "iana"
    },
    "audio/evrc1": {
        source: "iana"
    },
    "audio/evrcb": {
        source: "iana"
    },
    "audio/evrcb0": {
        source: "iana"
    },
    "audio/evrcb1": {
        source: "iana"
    },
    "audio/evrcnw": {
        source: "iana"
    },
    "audio/evrcnw0": {
        source: "iana"
    },
    "audio/evrcnw1": {
        source: "iana"
    },
    "audio/evrcwb": {
        source: "iana"
    },
    "audio/evrcwb0": {
        source: "iana"
    },
    "audio/evrcwb1": {
        source: "iana"
    },
    "audio/evs": {
        source: "iana"
    },
    "audio/flexfec": {
        source: "iana"
    },
    "audio/fwdred": {
        source: "iana"
    },
    "audio/g711-0": {
        source: "iana"
    },
    "audio/g719": {
        source: "iana"
    },
    "audio/g722": {
        source: "iana"
    },
    "audio/g7221": {
        source: "iana"
    },
    "audio/g723": {
        source: "iana"
    },
    "audio/g726-16": {
        source: "iana"
    },
    "audio/g726-24": {
        source: "iana"
    },
    "audio/g726-32": {
        source: "iana"
    },
    "audio/g726-40": {
        source: "iana"
    },
    "audio/g728": {
        source: "iana"
    },
    "audio/g729": {
        source: "iana"
    },
    "audio/g7291": {
        source: "iana"
    },
    "audio/g729d": {
        source: "iana"
    },
    "audio/g729e": {
        source: "iana"
    },
    "audio/gsm": {
        source: "iana"
    },
    "audio/gsm-efr": {
        source: "iana"
    },
    "audio/gsm-hr-08": {
        source: "iana"
    },
    "audio/ilbc": {
        source: "iana"
    },
    "audio/ip-mr_v2.5": {
        source: "iana"
    },
    "audio/isac": {
        source: "apache"
    },
    "audio/l16": {
        source: "iana"
    },
    "audio/l20": {
        source: "iana"
    },
    "audio/l24": {
        source: "iana",
        compressible: false
    },
    "audio/l8": {
        source: "iana"
    },
    "audio/lpc": {
        source: "iana"
    },
    "audio/melp": {
        source: "iana"
    },
    "audio/melp1200": {
        source: "iana"
    },
    "audio/melp2400": {
        source: "iana"
    },
    "audio/melp600": {
        source: "iana"
    },
    "audio/mhas": {
        source: "iana"
    },
    "audio/midi": {
        source: "apache",
        extensions: [
            "mid",
            "midi",
            "kar",
            "rmi"
        ]
    },
    "audio/mobile-xmf": {
        source: "iana",
        extensions: [
            "mxmf"
        ]
    },
    "audio/mp3": {
        compressible: false,
        extensions: [
            "mp3"
        ]
    },
    "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
            "m4a",
            "mp4a"
        ]
    },
    "audio/mp4a-latm": {
        source: "iana"
    },
    "audio/mpa": {
        source: "iana"
    },
    "audio/mpa-robust": {
        source: "iana"
    },
    "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "mpga",
            "mp2",
            "mp2a",
            "mp3",
            "m2a",
            "m3a"
        ]
    },
    "audio/mpeg4-generic": {
        source: "iana"
    },
    "audio/musepack": {
        source: "apache"
    },
    "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "oga",
            "ogg",
            "spx"
        ]
    },
    "audio/opus": {
        source: "iana"
    },
    "audio/parityfec": {
        source: "iana"
    },
    "audio/pcma": {
        source: "iana"
    },
    "audio/pcma-wb": {
        source: "iana"
    },
    "audio/pcmu": {
        source: "iana"
    },
    "audio/pcmu-wb": {
        source: "iana"
    },
    "audio/prs.sid": {
        source: "iana"
    },
    "audio/qcelp": {
        source: "iana"
    },
    "audio/raptorfec": {
        source: "iana"
    },
    "audio/red": {
        source: "iana"
    },
    "audio/rtp-enc-aescm128": {
        source: "iana"
    },
    "audio/rtp-midi": {
        source: "iana"
    },
    "audio/rtploopback": {
        source: "iana"
    },
    "audio/rtx": {
        source: "iana"
    },
    "audio/s3m": {
        source: "apache",
        extensions: [
            "s3m"
        ]
    },
    "audio/silk": {
        source: "apache",
        extensions: [
            "sil"
        ]
    },
    "audio/smv": {
        source: "iana"
    },
    "audio/smv-qcp": {
        source: "iana"
    },
    "audio/smv0": {
        source: "iana"
    },
    "audio/sp-midi": {
        source: "iana"
    },
    "audio/speex": {
        source: "iana"
    },
    "audio/t140c": {
        source: "iana"
    },
    "audio/t38": {
        source: "iana"
    },
    "audio/telephone-event": {
        source: "iana"
    },
    "audio/tetra_acelp": {
        source: "iana"
    },
    "audio/tetra_acelp_bb": {
        source: "iana"
    },
    "audio/tone": {
        source: "iana"
    },
    "audio/uemclip": {
        source: "iana"
    },
    "audio/ulpfec": {
        source: "iana"
    },
    "audio/usac": {
        source: "iana"
    },
    "audio/vdvi": {
        source: "iana"
    },
    "audio/vmr-wb": {
        source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
        source: "iana"
    },
    "audio/vnd.4sb": {
        source: "iana"
    },
    "audio/vnd.audiokoz": {
        source: "iana"
    },
    "audio/vnd.celp": {
        source: "iana"
    },
    "audio/vnd.cisco.nse": {
        source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
        source: "iana"
    },
    "audio/vnd.cns.anp1": {
        source: "iana"
    },
    "audio/vnd.cns.inf1": {
        source: "iana"
    },
    "audio/vnd.dece.audio": {
        source: "iana",
        extensions: [
            "uva",
            "uvva"
        ]
    },
    "audio/vnd.digital-winds": {
        source: "iana",
        extensions: [
            "eol"
        ]
    },
    "audio/vnd.dlna.adts": {
        source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
        source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
        source: "iana"
    },
    "audio/vnd.dolby.mlp": {
        source: "iana"
    },
    "audio/vnd.dolby.mps": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
        source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
        source: "iana"
    },
    "audio/vnd.dra": {
        source: "iana",
        extensions: [
            "dra"
        ]
    },
    "audio/vnd.dts": {
        source: "iana",
        extensions: [
            "dts"
        ]
    },
    "audio/vnd.dts.hd": {
        source: "iana",
        extensions: [
            "dtshd"
        ]
    },
    "audio/vnd.dts.uhd": {
        source: "iana"
    },
    "audio/vnd.dvb.file": {
        source: "iana"
    },
    "audio/vnd.everad.plj": {
        source: "iana"
    },
    "audio/vnd.hns.audio": {
        source: "iana"
    },
    "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: [
            "lvp"
        ]
    },
    "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: [
            "pya"
        ]
    },
    "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
    },
    "audio/vnd.nortel.vbk": {
        source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: [
            "ecelp4800"
        ]
    },
    "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: [
            "ecelp7470"
        ]
    },
    "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: [
            "ecelp9600"
        ]
    },
    "audio/vnd.octel.sbc": {
        source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
        source: "iana"
    },
    "audio/vnd.qcelp": {
        source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
    },
    "audio/vnd.rip": {
        source: "iana",
        extensions: [
            "rip"
        ]
    },
    "audio/vnd.rn-realaudio": {
        compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
        source: "iana"
    },
    "audio/vnd.wave": {
        compressible: false
    },
    "audio/vorbis": {
        source: "iana",
        compressible: false
    },
    "audio/vorbis-config": {
        source: "iana"
    },
    "audio/wav": {
        compressible: false,
        extensions: [
            "wav"
        ]
    },
    "audio/wave": {
        compressible: false,
        extensions: [
            "wav"
        ]
    },
    "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: [
            "weba"
        ]
    },
    "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: [
            "aac"
        ]
    },
    "audio/x-aiff": {
        source: "apache",
        extensions: [
            "aif",
            "aiff",
            "aifc"
        ]
    },
    "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: [
            "caf"
        ]
    },
    "audio/x-flac": {
        source: "apache",
        extensions: [
            "flac"
        ]
    },
    "audio/x-m4a": {
        source: "nginx",
        extensions: [
            "m4a"
        ]
    },
    "audio/x-matroska": {
        source: "apache",
        extensions: [
            "mka"
        ]
    },
    "audio/x-mpegurl": {
        source: "apache",
        extensions: [
            "m3u"
        ]
    },
    "audio/x-ms-wax": {
        source: "apache",
        extensions: [
            "wax"
        ]
    },
    "audio/x-ms-wma": {
        source: "apache",
        extensions: [
            "wma"
        ]
    },
    "audio/x-pn-realaudio": {
        source: "apache",
        extensions: [
            "ram",
            "ra"
        ]
    },
    "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: [
            "rmp"
        ]
    },
    "audio/x-realaudio": {
        source: "nginx",
        extensions: [
            "ra"
        ]
    },
    "audio/x-tta": {
        source: "apache"
    },
    "audio/x-wav": {
        source: "apache",
        extensions: [
            "wav"
        ]
    },
    "audio/xm": {
        source: "apache",
        extensions: [
            "xm"
        ]
    },
    "chemical/x-cdx": {
        source: "apache",
        extensions: [
            "cdx"
        ]
    },
    "chemical/x-cif": {
        source: "apache",
        extensions: [
            "cif"
        ]
    },
    "chemical/x-cmdf": {
        source: "apache",
        extensions: [
            "cmdf"
        ]
    },
    "chemical/x-cml": {
        source: "apache",
        extensions: [
            "cml"
        ]
    },
    "chemical/x-csml": {
        source: "apache",
        extensions: [
            "csml"
        ]
    },
    "chemical/x-pdb": {
        source: "apache"
    },
    "chemical/x-xyz": {
        source: "apache",
        extensions: [
            "xyz"
        ]
    },
    "font/collection": {
        source: "iana",
        extensions: [
            "ttc"
        ]
    },
    "font/otf": {
        source: "iana",
        compressible: true,
        extensions: [
            "otf"
        ]
    },
    "font/sfnt": {
        source: "iana"
    },
    "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: [
            "ttf"
        ]
    },
    "font/woff": {
        source: "iana",
        extensions: [
            "woff"
        ]
    },
    "font/woff2": {
        source: "iana",
        extensions: [
            "woff2"
        ]
    },
    "image/aces": {
        source: "iana",
        extensions: [
            "exr"
        ]
    },
    "image/apng": {
        compressible: false,
        extensions: [
            "apng"
        ]
    },
    "image/avci": {
        source: "iana"
    },
    "image/avcs": {
        source: "iana"
    },
    "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: [
            "bmp"
        ]
    },
    "image/cgm": {
        source: "iana",
        extensions: [
            "cgm"
        ]
    },
    "image/dicom-rle": {
        source: "iana",
        extensions: [
            "drle"
        ]
    },
    "image/emf": {
        source: "iana",
        extensions: [
            "emf"
        ]
    },
    "image/fits": {
        source: "iana",
        extensions: [
            "fits"
        ]
    },
    "image/g3fax": {
        source: "iana",
        extensions: [
            "g3"
        ]
    },
    "image/gif": {
        source: "iana",
        compressible: false,
        extensions: [
            "gif"
        ]
    },
    "image/heic": {
        source: "iana",
        extensions: [
            "heic"
        ]
    },
    "image/heic-sequence": {
        source: "iana",
        extensions: [
            "heics"
        ]
    },
    "image/heif": {
        source: "iana",
        extensions: [
            "heif"
        ]
    },
    "image/heif-sequence": {
        source: "iana",
        extensions: [
            "heifs"
        ]
    },
    "image/hej2k": {
        source: "iana",
        extensions: [
            "hej2"
        ]
    },
    "image/hsj2": {
        source: "iana",
        extensions: [
            "hsj2"
        ]
    },
    "image/ief": {
        source: "iana",
        extensions: [
            "ief"
        ]
    },
    "image/jls": {
        source: "iana",
        extensions: [
            "jls"
        ]
    },
    "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: [
            "jp2",
            "jpg2"
        ]
    },
    "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpeg",
            "jpg",
            "jpe"
        ]
    },
    "image/jph": {
        source: "iana",
        extensions: [
            "jph"
        ]
    },
    "image/jphc": {
        source: "iana",
        extensions: [
            "jhc"
        ]
    },
    "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpm"
        ]
    },
    "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpx",
            "jpf"
        ]
    },
    "image/jxr": {
        source: "iana",
        extensions: [
            "jxr"
        ]
    },
    "image/jxra": {
        source: "iana",
        extensions: [
            "jxra"
        ]
    },
    "image/jxrs": {
        source: "iana",
        extensions: [
            "jxrs"
        ]
    },
    "image/jxs": {
        source: "iana",
        extensions: [
            "jxs"
        ]
    },
    "image/jxsc": {
        source: "iana",
        extensions: [
            "jxsc"
        ]
    },
    "image/jxsi": {
        source: "iana",
        extensions: [
            "jxsi"
        ]
    },
    "image/jxss": {
        source: "iana",
        extensions: [
            "jxss"
        ]
    },
    "image/ktx": {
        source: "iana",
        extensions: [
            "ktx"
        ]
    },
    "image/naplps": {
        source: "iana"
    },
    "image/pjpeg": {
        compressible: false
    },
    "image/png": {
        source: "iana",
        compressible: false,
        extensions: [
            "png"
        ]
    },
    "image/prs.btif": {
        source: "iana",
        extensions: [
            "btif"
        ]
    },
    "image/prs.pti": {
        source: "iana",
        extensions: [
            "pti"
        ]
    },
    "image/pwg-raster": {
        source: "iana"
    },
    "image/sgi": {
        source: "apache",
        extensions: [
            "sgi"
        ]
    },
    "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "svg",
            "svgz"
        ]
    },
    "image/t38": {
        source: "iana",
        extensions: [
            "t38"
        ]
    },
    "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: [
            "tif",
            "tiff"
        ]
    },
    "image/tiff-fx": {
        source: "iana",
        extensions: [
            "tfx"
        ]
    },
    "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: [
            "psd"
        ]
    },
    "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: [
            "azv"
        ]
    },
    "image/vnd.cns.inf2": {
        source: "iana"
    },
    "image/vnd.dece.graphic": {
        source: "iana",
        extensions: [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ]
    },
    "image/vnd.djvu": {
        source: "iana",
        extensions: [
            "djvu",
            "djv"
        ]
    },
    "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
            "sub"
        ]
    },
    "image/vnd.dwg": {
        source: "iana",
        extensions: [
            "dwg"
        ]
    },
    "image/vnd.dxf": {
        source: "iana",
        extensions: [
            "dxf"
        ]
    },
    "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: [
            "fbs"
        ]
    },
    "image/vnd.fpx": {
        source: "iana",
        extensions: [
            "fpx"
        ]
    },
    "image/vnd.fst": {
        source: "iana",
        extensions: [
            "fst"
        ]
    },
    "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: [
            "mmr"
        ]
    },
    "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: [
            "rlc"
        ]
    },
    "image/vnd.globalgraphics.pgb": {
        source: "iana"
    },
    "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: [
            "ico"
        ]
    },
    "image/vnd.mix": {
        source: "iana"
    },
    "image/vnd.mozilla.apng": {
        source: "iana"
    },
    "image/vnd.ms-dds": {
        extensions: [
            "dds"
        ]
    },
    "image/vnd.ms-modi": {
        source: "iana",
        extensions: [
            "mdi"
        ]
    },
    "image/vnd.ms-photo": {
        source: "apache",
        extensions: [
            "wdp"
        ]
    },
    "image/vnd.net-fpx": {
        source: "iana",
        extensions: [
            "npx"
        ]
    },
    "image/vnd.radiance": {
        source: "iana"
    },
    "image/vnd.sealed.png": {
        source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
    },
    "image/vnd.svf": {
        source: "iana"
    },
    "image/vnd.tencent.tap": {
        source: "iana",
        extensions: [
            "tap"
        ]
    },
    "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: [
            "vtf"
        ]
    },
    "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: [
            "wbmp"
        ]
    },
    "image/vnd.xiff": {
        source: "iana",
        extensions: [
            "xif"
        ]
    },
    "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: [
            "pcx"
        ]
    },
    "image/webp": {
        source: "apache",
        extensions: [
            "webp"
        ]
    },
    "image/wmf": {
        source: "iana",
        extensions: [
            "wmf"
        ]
    },
    "image/x-3ds": {
        source: "apache",
        extensions: [
            "3ds"
        ]
    },
    "image/x-cmu-raster": {
        source: "apache",
        extensions: [
            "ras"
        ]
    },
    "image/x-cmx": {
        source: "apache",
        extensions: [
            "cmx"
        ]
    },
    "image/x-freehand": {
        source: "apache",
        extensions: [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ]
    },
    "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: [
            "ico"
        ]
    },
    "image/x-jng": {
        source: "nginx",
        extensions: [
            "jng"
        ]
    },
    "image/x-mrsid-image": {
        source: "apache",
        extensions: [
            "sid"
        ]
    },
    "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: [
            "bmp"
        ]
    },
    "image/x-pcx": {
        source: "apache",
        extensions: [
            "pcx"
        ]
    },
    "image/x-pict": {
        source: "apache",
        extensions: [
            "pic",
            "pct"
        ]
    },
    "image/x-portable-anymap": {
        source: "apache",
        extensions: [
            "pnm"
        ]
    },
    "image/x-portable-bitmap": {
        source: "apache",
        extensions: [
            "pbm"
        ]
    },
    "image/x-portable-graymap": {
        source: "apache",
        extensions: [
            "pgm"
        ]
    },
    "image/x-portable-pixmap": {
        source: "apache",
        extensions: [
            "ppm"
        ]
    },
    "image/x-rgb": {
        source: "apache",
        extensions: [
            "rgb"
        ]
    },
    "image/x-tga": {
        source: "apache",
        extensions: [
            "tga"
        ]
    },
    "image/x-xbitmap": {
        source: "apache",
        extensions: [
            "xbm"
        ]
    },
    "image/x-xcf": {
        compressible: false
    },
    "image/x-xpixmap": {
        source: "apache",
        extensions: [
            "xpm"
        ]
    },
    "image/x-xwindowdump": {
        source: "apache",
        extensions: [
            "xwd"
        ]
    },
    "message/cpim": {
        source: "iana"
    },
    "message/delivery-status": {
        source: "iana"
    },
    "message/disposition-notification": {
        source: "iana",
        extensions: [
            "disposition-notification"
        ]
    },
    "message/external-body": {
        source: "iana"
    },
    "message/feedback-report": {
        source: "iana"
    },
    "message/global": {
        source: "iana",
        extensions: [
            "u8msg"
        ]
    },
    "message/global-delivery-status": {
        source: "iana",
        extensions: [
            "u8dsn"
        ]
    },
    "message/global-disposition-notification": {
        source: "iana",
        extensions: [
            "u8mdn"
        ]
    },
    "message/global-headers": {
        source: "iana",
        extensions: [
            "u8hdr"
        ]
    },
    "message/http": {
        source: "iana",
        compressible: false
    },
    "message/imdn+xml": {
        source: "iana",
        compressible: true
    },
    "message/news": {
        source: "iana"
    },
    "message/partial": {
        source: "iana",
        compressible: false
    },
    "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: [
            "eml",
            "mime"
        ]
    },
    "message/s-http": {
        source: "iana"
    },
    "message/sip": {
        source: "iana"
    },
    "message/sipfrag": {
        source: "iana"
    },
    "message/tracking-status": {
        source: "iana"
    },
    "message/vnd.si.simp": {
        source: "iana"
    },
    "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: [
            "wsc"
        ]
    },
    "model/3mf": {
        source: "iana",
        extensions: [
            "3mf"
        ]
    },
    "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "gltf"
        ]
    },
    "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: [
            "glb"
        ]
    },
    "model/iges": {
        source: "iana",
        compressible: false,
        extensions: [
            "igs",
            "iges"
        ]
    },
    "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: [
            "msh",
            "mesh",
            "silo"
        ]
    },
    "model/mtl": {
        source: "iana",
        extensions: [
            "mtl"
        ]
    },
    "model/obj": {
        source: "iana",
        extensions: [
            "obj"
        ]
    },
    "model/stl": {
        source: "iana",
        extensions: [
            "stl"
        ]
    },
    "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dae"
        ]
    },
    "model/vnd.dwf": {
        source: "iana",
        extensions: [
            "dwf"
        ]
    },
    "model/vnd.flatland.3dml": {
        source: "iana"
    },
    "model/vnd.gdl": {
        source: "iana",
        extensions: [
            "gdl"
        ]
    },
    "model/vnd.gs-gdl": {
        source: "apache"
    },
    "model/vnd.gs.gdl": {
        source: "iana"
    },
    "model/vnd.gtw": {
        source: "iana",
        extensions: [
            "gtw"
        ]
    },
    "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
    },
    "model/vnd.mts": {
        source: "iana",
        extensions: [
            "mts"
        ]
    },
    "model/vnd.opengex": {
        source: "iana",
        extensions: [
            "ogex"
        ]
    },
    "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: [
            "x_b"
        ]
    },
    "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: [
            "x_t"
        ]
    },
    "model/vnd.rosette.annotated-data-model": {
        source: "iana"
    },
    "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "usdz"
        ]
    },
    "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: [
            "bsp"
        ]
    },
    "model/vnd.vtu": {
        source: "iana",
        extensions: [
            "vtu"
        ]
    },
    "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: [
            "wrl",
            "vrml"
        ]
    },
    "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: [
            "x3db",
            "x3dbz"
        ]
    },
    "model/x3d+fastinfoset": {
        source: "iana",
        extensions: [
            "x3db"
        ]
    },
    "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: [
            "x3dv",
            "x3dvz"
        ]
    },
    "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "x3d",
            "x3dz"
        ]
    },
    "model/x3d-vrml": {
        source: "iana",
        extensions: [
            "x3dv"
        ]
    },
    "multipart/alternative": {
        source: "iana",
        compressible: false
    },
    "multipart/appledouble": {
        source: "iana"
    },
    "multipart/byteranges": {
        source: "iana"
    },
    "multipart/digest": {
        source: "iana"
    },
    "multipart/encrypted": {
        source: "iana",
        compressible: false
    },
    "multipart/form-data": {
        source: "iana",
        compressible: false
    },
    "multipart/header-set": {
        source: "iana"
    },
    "multipart/mixed": {
        source: "iana"
    },
    "multipart/multilingual": {
        source: "iana"
    },
    "multipart/parallel": {
        source: "iana"
    },
    "multipart/related": {
        source: "iana",
        compressible: false
    },
    "multipart/report": {
        source: "iana"
    },
    "multipart/signed": {
        source: "iana",
        compressible: false
    },
    "multipart/vnd.bint.med-plus": {
        source: "iana"
    },
    "multipart/voice-message": {
        source: "iana"
    },
    "multipart/x-mixed-replace": {
        source: "iana"
    },
    "text/1d-interleaved-parityfec": {
        source: "iana"
    },
    "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: [
            "appcache",
            "manifest"
        ]
    },
    "text/calendar": {
        source: "iana",
        extensions: [
            "ics",
            "ifb"
        ]
    },
    "text/calender": {
        compressible: true
    },
    "text/cmd": {
        compressible: true
    },
    "text/coffeescript": {
        extensions: [
            "coffee",
            "litcoffee"
        ]
    },
    "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "css"
        ]
    },
    "text/csv": {
        source: "iana",
        compressible: true,
        extensions: [
            "csv"
        ]
    },
    "text/csv-schema": {
        source: "iana"
    },
    "text/directory": {
        source: "iana"
    },
    "text/dns": {
        source: "iana"
    },
    "text/ecmascript": {
        source: "iana"
    },
    "text/encaprtp": {
        source: "iana"
    },
    "text/enriched": {
        source: "iana"
    },
    "text/flexfec": {
        source: "iana"
    },
    "text/fwdred": {
        source: "iana"
    },
    "text/grammar-ref-list": {
        source: "iana"
    },
    "text/html": {
        source: "iana",
        compressible: true,
        extensions: [
            "html",
            "htm",
            "shtml"
        ]
    },
    "text/jade": {
        extensions: [
            "jade"
        ]
    },
    "text/javascript": {
        source: "iana",
        compressible: true
    },
    "text/jcr-cnd": {
        source: "iana"
    },
    "text/jsx": {
        compressible: true,
        extensions: [
            "jsx"
        ]
    },
    "text/less": {
        compressible: true,
        extensions: [
            "less"
        ]
    },
    "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: [
            "markdown",
            "md"
        ]
    },
    "text/mathml": {
        source: "nginx",
        extensions: [
            "mml"
        ]
    },
    "text/mdx": {
        compressible: true,
        extensions: [
            "mdx"
        ]
    },
    "text/mizar": {
        source: "iana"
    },
    "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "n3"
        ]
    },
    "text/parameters": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/parityfec": {
        source: "iana"
    },
    "text/plain": {
        source: "iana",
        compressible: true,
        extensions: [
            "txt",
            "text",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "ini"
        ]
    },
    "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
        source: "iana"
    },
    "text/prs.lines.tag": {
        source: "iana",
        extensions: [
            "dsc"
        ]
    },
    "text/prs.prop.logic": {
        source: "iana"
    },
    "text/raptorfec": {
        source: "iana"
    },
    "text/red": {
        source: "iana"
    },
    "text/rfc822-headers": {
        source: "iana"
    },
    "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtx"
        ]
    },
    "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtf"
        ]
    },
    "text/rtp-enc-aescm128": {
        source: "iana"
    },
    "text/rtploopback": {
        source: "iana"
    },
    "text/rtx": {
        source: "iana"
    },
    "text/sgml": {
        source: "iana",
        extensions: [
            "sgml",
            "sgm"
        ]
    },
    "text/shex": {
        extensions: [
            "shex"
        ]
    },
    "text/slim": {
        extensions: [
            "slim",
            "slm"
        ]
    },
    "text/strings": {
        source: "iana"
    },
    "text/stylus": {
        extensions: [
            "stylus",
            "styl"
        ]
    },
    "text/t140": {
        source: "iana"
    },
    "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: [
            "tsv"
        ]
    },
    "text/troff": {
        source: "iana",
        extensions: [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ]
    },
    "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "ttl"
        ]
    },
    "text/ulpfec": {
        source: "iana"
    },
    "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: [
            "uri",
            "uris",
            "urls"
        ]
    },
    "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: [
            "vcard"
        ]
    },
    "text/vnd.a": {
        source: "iana"
    },
    "text/vnd.abc": {
        source: "iana"
    },
    "text/vnd.ascii-art": {
        source: "iana"
    },
    "text/vnd.curl": {
        source: "iana",
        extensions: [
            "curl"
        ]
    },
    "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: [
            "dcurl"
        ]
    },
    "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: [
            "mcurl"
        ]
    },
    "text/vnd.curl.scurl": {
        source: "apache",
        extensions: [
            "scurl"
        ]
    },
    "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
        source: "iana"
    },
    "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
            "sub"
        ]
    },
    "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
        source: "iana"
    },
    "text/vnd.fly": {
        source: "iana",
        extensions: [
            "fly"
        ]
    },
    "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: [
            "flx"
        ]
    },
    "text/vnd.gml": {
        source: "iana"
    },
    "text/vnd.graphviz": {
        source: "iana",
        extensions: [
            "gv"
        ]
    },
    "text/vnd.hgl": {
        source: "iana"
    },
    "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: [
            "3dml"
        ]
    },
    "text/vnd.in3d.spot": {
        source: "iana",
        extensions: [
            "spot"
        ]
    },
    "text/vnd.iptc.newsml": {
        source: "iana"
    },
    "text/vnd.iptc.nitf": {
        source: "iana"
    },
    "text/vnd.latex-z": {
        source: "iana"
    },
    "text/vnd.motorola.reflex": {
        source: "iana"
    },
    "text/vnd.ms-mediapackage": {
        source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
        source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
    },
    "text/vnd.senx.warpscript": {
        source: "iana"
    },
    "text/vnd.si.uricatalogue": {
        source: "iana"
    },
    "text/vnd.sosi": {
        source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "jad"
        ]
    },
    "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.wap.si": {
        source: "iana"
    },
    "text/vnd.wap.sl": {
        source: "iana"
    },
    "text/vnd.wap.wml": {
        source: "iana",
        extensions: [
            "wml"
        ]
    },
    "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: [
            "wmls"
        ]
    },
    "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "vtt"
        ]
    },
    "text/x-asm": {
        source: "apache",
        extensions: [
            "s",
            "asm"
        ]
    },
    "text/x-c": {
        source: "apache",
        extensions: [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ]
    },
    "text/x-component": {
        source: "nginx",
        extensions: [
            "htc"
        ]
    },
    "text/x-fortran": {
        source: "apache",
        extensions: [
            "f",
            "for",
            "f77",
            "f90"
        ]
    },
    "text/x-gwt-rpc": {
        compressible: true
    },
    "text/x-handlebars-template": {
        extensions: [
            "hbs"
        ]
    },
    "text/x-java-source": {
        source: "apache",
        extensions: [
            "java"
        ]
    },
    "text/x-jquery-tmpl": {
        compressible: true
    },
    "text/x-lua": {
        extensions: [
            "lua"
        ]
    },
    "text/x-markdown": {
        compressible: true,
        extensions: [
            "mkd"
        ]
    },
    "text/x-nfo": {
        source: "apache",
        extensions: [
            "nfo"
        ]
    },
    "text/x-opml": {
        source: "apache",
        extensions: [
            "opml"
        ]
    },
    "text/x-org": {
        compressible: true,
        extensions: [
            "org"
        ]
    },
    "text/x-pascal": {
        source: "apache",
        extensions: [
            "p",
            "pas"
        ]
    },
    "text/x-processing": {
        compressible: true,
        extensions: [
            "pde"
        ]
    },
    "text/x-sass": {
        extensions: [
            "sass"
        ]
    },
    "text/x-scss": {
        extensions: [
            "scss"
        ]
    },
    "text/x-setext": {
        source: "apache",
        extensions: [
            "etx"
        ]
    },
    "text/x-sfv": {
        source: "apache",
        extensions: [
            "sfv"
        ]
    },
    "text/x-suse-ymp": {
        compressible: true,
        extensions: [
            "ymp"
        ]
    },
    "text/x-uuencode": {
        source: "apache",
        extensions: [
            "uu"
        ]
    },
    "text/x-vcalendar": {
        source: "apache",
        extensions: [
            "vcs"
        ]
    },
    "text/x-vcard": {
        source: "apache",
        extensions: [
            "vcf"
        ]
    },
    "text/xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xml"
        ]
    },
    "text/xml-external-parsed-entity": {
        source: "iana"
    },
    "text/yaml": {
        extensions: [
            "yaml",
            "yml"
        ]
    },
    "video/1d-interleaved-parityfec": {
        source: "iana"
    },
    "video/3gpp": {
        source: "iana",
        extensions: [
            "3gp",
            "3gpp"
        ]
    },
    "video/3gpp-tt": {
        source: "iana"
    },
    "video/3gpp2": {
        source: "iana",
        extensions: [
            "3g2"
        ]
    },
    "video/bmpeg": {
        source: "iana"
    },
    "video/bt656": {
        source: "iana"
    },
    "video/celb": {
        source: "iana"
    },
    "video/dv": {
        source: "iana"
    },
    "video/encaprtp": {
        source: "iana"
    },
    "video/flexfec": {
        source: "iana"
    },
    "video/h261": {
        source: "iana",
        extensions: [
            "h261"
        ]
    },
    "video/h263": {
        source: "iana",
        extensions: [
            "h263"
        ]
    },
    "video/h263-1998": {
        source: "iana"
    },
    "video/h263-2000": {
        source: "iana"
    },
    "video/h264": {
        source: "iana",
        extensions: [
            "h264"
        ]
    },
    "video/h264-rcdo": {
        source: "iana"
    },
    "video/h264-svc": {
        source: "iana"
    },
    "video/h265": {
        source: "iana"
    },
    "video/iso.segment": {
        source: "iana"
    },
    "video/jpeg": {
        source: "iana",
        extensions: [
            "jpgv"
        ]
    },
    "video/jpeg2000": {
        source: "iana"
    },
    "video/jpm": {
        source: "apache",
        extensions: [
            "jpm",
            "jpgm"
        ]
    },
    "video/mj2": {
        source: "iana",
        extensions: [
            "mj2",
            "mjp2"
        ]
    },
    "video/mp1s": {
        source: "iana"
    },
    "video/mp2p": {
        source: "iana"
    },
    "video/mp2t": {
        source: "iana",
        extensions: [
            "ts"
        ]
    },
    "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
            "mp4",
            "mp4v",
            "mpg4"
        ]
    },
    "video/mp4v-es": {
        source: "iana"
    },
    "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v"
        ]
    },
    "video/mpeg4-generic": {
        source: "iana"
    },
    "video/mpv": {
        source: "iana"
    },
    "video/nv": {
        source: "iana"
    },
    "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "ogv"
        ]
    },
    "video/parityfec": {
        source: "iana"
    },
    "video/pointer": {
        source: "iana"
    },
    "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: [
            "qt",
            "mov"
        ]
    },
    "video/raptorfec": {
        source: "iana"
    },
    "video/raw": {
        source: "iana"
    },
    "video/rtp-enc-aescm128": {
        source: "iana"
    },
    "video/rtploopback": {
        source: "iana"
    },
    "video/rtx": {
        source: "iana"
    },
    "video/smpte291": {
        source: "iana"
    },
    "video/smpte292m": {
        source: "iana"
    },
    "video/ulpfec": {
        source: "iana"
    },
    "video/vc1": {
        source: "iana"
    },
    "video/vc2": {
        source: "iana"
    },
    "video/vnd.cctv": {
        source: "iana"
    },
    "video/vnd.dece.hd": {
        source: "iana",
        extensions: [
            "uvh",
            "uvvh"
        ]
    },
    "video/vnd.dece.mobile": {
        source: "iana",
        extensions: [
            "uvm",
            "uvvm"
        ]
    },
    "video/vnd.dece.mp4": {
        source: "iana"
    },
    "video/vnd.dece.pd": {
        source: "iana",
        extensions: [
            "uvp",
            "uvvp"
        ]
    },
    "video/vnd.dece.sd": {
        source: "iana",
        extensions: [
            "uvs",
            "uvvs"
        ]
    },
    "video/vnd.dece.video": {
        source: "iana",
        extensions: [
            "uvv",
            "uvvv"
        ]
    },
    "video/vnd.directv.mpeg": {
        source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
        source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
        source: "iana"
    },
    "video/vnd.dvb.file": {
        source: "iana",
        extensions: [
            "dvb"
        ]
    },
    "video/vnd.fvt": {
        source: "iana",
        extensions: [
            "fvt"
        ]
    },
    "video/vnd.hns.video": {
        source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
        source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
    },
    "video/vnd.motorola.video": {
        source: "iana"
    },
    "video/vnd.motorola.videop": {
        source: "iana"
    },
    "video/vnd.mpegurl": {
        source: "iana",
        extensions: [
            "mxu",
            "m4u"
        ]
    },
    "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: [
            "pyv"
        ]
    },
    "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
        source: "iana"
    },
    "video/vnd.nokia.videovoip": {
        source: "iana"
    },
    "video/vnd.objectvideo": {
        source: "iana"
    },
    "video/vnd.radgamettools.bink": {
        source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
        source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
        source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
        source: "iana"
    },
    "video/vnd.sealed.swf": {
        source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
    },
    "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: [
            "uvu",
            "uvvu"
        ]
    },
    "video/vnd.vivo": {
        source: "iana",
        extensions: [
            "viv"
        ]
    },
    "video/vnd.youtube.yt": {
        source: "iana"
    },
    "video/vp8": {
        source: "iana"
    },
    "video/webm": {
        source: "apache",
        compressible: false,
        extensions: [
            "webm"
        ]
    },
    "video/x-f4v": {
        source: "apache",
        extensions: [
            "f4v"
        ]
    },
    "video/x-fli": {
        source: "apache",
        extensions: [
            "fli"
        ]
    },
    "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: [
            "flv"
        ]
    },
    "video/x-m4v": {
        source: "apache",
        extensions: [
            "m4v"
        ]
    },
    "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: [
            "mkv",
            "mk3d",
            "mks"
        ]
    },
    "video/x-mng": {
        source: "apache",
        extensions: [
            "mng"
        ]
    },
    "video/x-ms-asf": {
        source: "apache",
        extensions: [
            "asf",
            "asx"
        ]
    },
    "video/x-ms-vob": {
        source: "apache",
        extensions: [
            "vob"
        ]
    },
    "video/x-ms-wm": {
        source: "apache",
        extensions: [
            "wm"
        ]
    },
    "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: [
            "wmv"
        ]
    },
    "video/x-ms-wmx": {
        source: "apache",
        extensions: [
            "wmx"
        ]
    },
    "video/x-ms-wvx": {
        source: "apache",
        extensions: [
            "wvx"
        ]
    },
    "video/x-msvideo": {
        source: "apache",
        extensions: [
            "avi"
        ]
    },
    "video/x-sgi-movie": {
        source: "apache",
        extensions: [
            "movie"
        ]
    },
    "video/x-smv": {
        source: "apache",
        extensions: [
            "smv"
        ]
    },
    "x-conference/x-cooltalk": {
        source: "apache",
        extensions: [
            "ice"
        ]
    },
    "x-shader/x-fragment": {
        compressible: true
    },
    "x-shader/x-vertex": {
        compressible: true
    }
};
const CHAR_FORWARD_SLASH2 = 47;
let NATIVE_OS = "linux";
const navigator = globalThis.navigator;
if (globalThis.Deno != null) {
    NATIVE_OS = Deno.build.os;
} else if (navigator?.appVersion?.includes?.("Win") ?? false) {
    NATIVE_OS = "windows";
}
const isWindows2 = NATIVE_OS == "windows";
function assertPath2(path2) {
    if (typeof path2 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
}
function isPosixPathSeparator2(code8) {
    return code8 === 47;
}
function isPathSeparator2(code8) {
    return isPosixPathSeparator2(code8) || code8 === 92;
}
function isWindowsDeviceRoot2(code8) {
    return code8 >= 97 && code8 <= 122 || code8 >= 65 && code8 <= 90;
}
function normalizeString2(path2, allowAboveRoot, separator, isPathSeparator3) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code8;
    for(let i2 = 0, len = path2.length; i2 <= len; ++i2){
        if (i2 < len) code8 = path2.charCodeAt(i2);
        else if (isPathSeparator3(code8)) break;
        else code8 = CHAR_FORWARD_SLASH2;
        if (isPathSeparator3(code8)) {
            if (lastSlash === i2 - 1 || dots === 1) {
            } else if (lastSlash !== i2 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path2.slice(lastSlash + 1, i2);
                else res = path2.slice(lastSlash + 1, i2);
                lastSegmentLength = i2 - lastSlash - 1;
            }
            lastSlash = i2;
            dots = 0;
        } else if (code8 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep6, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep6 + base;
}
const sep6 = "\\";
const delimiter6 = ";";
function resolve6(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1; i2--){
        let path2;
        if (i2 >= 0) {
            path2 = pathSegments[i2];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path2 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path2 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path2 === undefined || path2.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path2 = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path2);
        const len = path2.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute6 = false;
        const code8 = path2.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code8)) {
                isAbsolute6 = true;
                if (isPathSeparator2(path2.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path2.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path2.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path2.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code8)) {
                if (path2.charCodeAt(1) === 58) {
                    device = path2.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path2.charCodeAt(2))) {
                            isAbsolute6 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code8)) {
            rootEnd = 1;
            isAbsolute6 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path2.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute6;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute6 = false;
    const code8 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code8)) {
            isAbsolute6 = true;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path2.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path2.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code8)) {
            if (path2.charCodeAt(1) === 58) {
                device = path2.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) {
                        isAbsolute6 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code8)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path2.slice(rootEnd), !isAbsolute6, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute6) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path2.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute6) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute6) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return false;
    const code8 = path2.charCodeAt(0);
    if (isPathSeparator2(code8)) {
        return true;
    } else if (isWindowsDeviceRoot2(code8)) {
        if (len > 2 && path2.charCodeAt(1) === 58) {
            if (isPathSeparator2(path2.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join6(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i2 = 0; i2 < pathsCount; ++i2){
        const path2 = paths[i2];
        assertPath2(path2);
        if (path2.length > 0) {
            if (joined === undefined) joined = firstPart = path2;
            else joined += `\\${path2}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert2(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize6(joined);
}
function relative6(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    const fromOrig = resolve6(from);
    const toOrig = resolve6(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 92) {
                    return toOrig.slice(toStart + i2 + 1);
                } else if (i2 === 2) {
                    return toOrig.slice(toStart + i2);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 92) {
                    lastCommonSep = i2;
                } else if (i2 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i2;
    }
    if (i2 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path2) {
    if (typeof path2 !== "string") return path2;
    if (path2.length === 0) return "";
    const resolvedPath = resolve6(path2);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code8 = resolvedPath.charCodeAt(2);
                if (code8 !== 63 && code8 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path2;
}
function dirname6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code8 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code8)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path2;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code8)) {
            if (path2.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code8)) {
        return path2;
    }
    for(let i2 = len - 1; i2 >= offset; --i2){
        if (isPathSeparator2(path2.charCodeAt(i2))) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path2.slice(0, end);
}
function basename6(path2, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path2);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (path2.length >= 2) {
        const drive = path2.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path2.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path2.length - 1; i2 >= start; --i2){
            const code8 = path2.charCodeAt(i2);
            if (isPathSeparator2(code8)) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code8 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
    } else {
        for(i2 = path2.length - 1; i2 >= start; --i2){
            if (isPathSeparator2(path2.charCodeAt(i2))) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    }
}
function extname6(path2) {
    assertPath2(path2);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path2.length >= 2 && path2.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path2.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i2 = path2.length - 1; i2 >= start; --i2){
        const code8 = path2.charCodeAt(i2);
        if (isPathSeparator2(code8)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path2.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("\\", pathObject);
}
function parse7(path2) {
    assertPath2(path2);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path2.length;
    if (len === 0) return ret1;
    let rootEnd = 0;
    let code8 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code8)) {
            rootEnd = 1;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code8)) {
            if (path2.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) {
                        if (len === 3) {
                            ret1.root = ret1.dir = path2;
                            return ret1;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret1.root = ret1.dir = path2;
                    return ret1;
                }
            }
        }
    } else if (isPathSeparator2(code8)) {
        ret1.root = ret1.dir = path2;
        return ret1;
    }
    if (rootEnd > 0) ret1.root = path2.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for(; i2 >= rootEnd; --i2){
        code8 = path2.charCodeAt(i2);
        if (isPathSeparator2(code8)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret1.base = ret1.name = path2.slice(startPart, end);
        }
    } else {
        ret1.name = path2.slice(startPart, startDot);
        ret1.base = path2.slice(startPart, end);
        ret1.ext = path2.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret1.dir = path2.slice(0, startPart - 1);
    } else ret1.dir = ret1.root;
    return ret1;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path2 = decodeURIComponent(url.pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    if (url.hostname != "") {
        path2 = `\\\\${url.hostname}${path2}`;
    }
    return path2;
}
const mod4 = function() {
    return {
        sep: sep6,
        delimiter: delimiter6,
        resolve: resolve6,
        normalize: normalize6,
        isAbsolute: isAbsolute6,
        join: join6,
        relative: relative6,
        toNamespacedPath: toNamespacedPath6,
        dirname: dirname6,
        basename: basename6,
        extname: extname6,
        format: format6,
        parse: parse7,
        fromFileUrl: fromFileUrl6
    };
}();
const sep7 = "/";
const delimiter7 = ":";
function resolve7(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--){
        let path2;
        if (i2 >= 0) path2 = pathSegments[i2];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path2 = Deno.cwd();
        }
        assertPath2(path2);
        if (path2.length === 0) {
            continue;
        }
        resolvedPath = `${path2}/${resolvedPath}`;
        resolvedAbsolute = path2.charCodeAt(0) === CHAR_FORWARD_SLASH2;
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize7(path2) {
    assertPath2(path2);
    if (path2.length === 0) return ".";
    const isAbsolute7 = path2.charCodeAt(0) === 47;
    const trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = normalizeString2(path2, !isAbsolute7, "/", isPosixPathSeparator2);
    if (path2.length === 0 && !isAbsolute7) path2 = ".";
    if (path2.length > 0 && trailingSeparator) path2 += "/";
    if (isAbsolute7) return `/${path2}`;
    return path2;
}
function isAbsolute7(path2) {
    assertPath2(path2);
    return path2.length > 0 && path2.charCodeAt(0) === 47;
}
function join7(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i2 = 0, len = paths.length; i2 < len; ++i2){
        const path2 = paths[i2];
        assertPath2(path2);
        if (path2.length > 0) {
            if (!joined) joined = path2;
            else joined += `/${path2}`;
        }
    }
    if (!joined) return ".";
    return normalize7(joined);
}
function relative7(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    from = resolve7(from);
    to = resolve7(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 47) {
                    return to.slice(toStart + i2 + 1);
                } else if (i2 === 0) {
                    return to.slice(toStart + i2);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 47) {
                    lastCommonSep = i2;
                } else if (i2 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i2;
    }
    let out = "";
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path2) {
    return path2;
}
function dirname7(path2) {
    assertPath2(path2);
    if (path2.length === 0) return ".";
    const hasRoot = path2.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i2 = path2.length - 1; i2 >= 1; --i2){
        if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path2.slice(0, end);
}
function basename7(path2, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path2);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path2.length - 1; i2 >= 0; --i2){
            const code8 = path2.charCodeAt(i2);
            if (code8 === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code8 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
    } else {
        for(i2 = path2.length - 1; i2 >= 0; --i2){
            if (path2.charCodeAt(i2) === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    }
}
function extname7(path2) {
    assertPath2(path2);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i2 = path2.length - 1; i2 >= 0; --i2){
        const code8 = path2.charCodeAt(i2);
        if (code8 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path2.slice(startDot, end);
}
function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("/", pathObject);
}
function parse8(path2) {
    assertPath2(path2);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path2.length === 0) return ret1;
    const isAbsolute8 = path2.charCodeAt(0) === 47;
    let start;
    if (isAbsolute8) {
        ret1.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for(; i2 >= start; --i2){
        const code8 = path2.charCodeAt(i2);
        if (code8 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute8) {
                ret1.base = ret1.name = path2.slice(1, end);
            } else {
                ret1.base = ret1.name = path2.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute8) {
            ret1.name = path2.slice(1, startDot);
            ret1.base = path2.slice(1, end);
        } else {
            ret1.name = path2.slice(startPart, startDot);
            ret1.base = path2.slice(startPart, end);
        }
        ret1.ext = path2.slice(startDot, end);
    }
    if (startPart > 0) ret1.dir = path2.slice(0, startPart - 1);
    else if (isAbsolute8) ret1.dir = "/";
    return ret1;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
const mod5 = function() {
    return {
        sep: sep7,
        delimiter: delimiter7,
        resolve: resolve7,
        normalize: normalize7,
        isAbsolute: isAbsolute7,
        join: join7,
        relative: relative7,
        toNamespacedPath: toNamespacedPath7,
        dirname: dirname7,
        basename: basename7,
        extname: extname7,
        format: format7,
        parse: parse8,
        fromFileUrl: fromFileUrl7
    };
}();
const path2 = isWindows2 ? mod4 : mod5;
const { basename: basename8 , delimiter: delimiter8 , dirname: dirname8 , extname: extname8 , format: format8 , fromFileUrl: fromFileUrl8 , isAbsolute: isAbsolute8 , join: join8 , normalize: normalize8 , parse: parse9 , relative: relative8 , resolve: resolve8 , sep: sep8 , toNamespacedPath: toNamespacedPath8 ,  } = path2;
const extensions1 = new Map();
const types2 = new Map();
function populateMaps1(extensions2, types3) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type1 of Object.keys(db1)){
        const mime = db1[type1];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions2.set(type1, exts);
        for (const ext of exts){
            const current = types3.get(ext);
            if (current) {
                const from = preference.indexOf(db1[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from > to || from === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types3.set(ext, type1);
        }
    }
}
populateMaps1(extensions1, types2);
function lookup1(path3) {
    const extension = extname8("x." + path3).toLowerCase().substr(1);
    return types2.get(extension);
}
class Accepts {
    headers;
    negotiator;
    constructor(headers2){
        this.headers = headers2;
        this.negotiator = new Negotiator(headers2);
    }
    types(types) {
        if (!types || types.length === 0) {
            return this.negotiator.mediaTypes();
        }
        if (!this.headers.get("accept")) {
            return types[0];
        }
        const mimes = types.map(extToMime);
        const accepts = this.negotiator.mediaTypes(mimes.filter((t)=>t && validMime(t)
        ));
        const first = accepts[0];
        return first ? types[mimes.indexOf(first)] : false;
    }
    encodings(encodings) {
        if (!encodings || encodings.length === 0) {
            return this.negotiator.encodings();
        }
        return this.negotiator.encodings(encodings)[0] || false;
    }
    charsets(charsets) {
        if (!charsets || charsets.length === 0) {
            return this.negotiator.charsets();
        }
        return this.negotiator.charsets(charsets)[0] || false;
    }
    languages(languages) {
        if (!languages || languages.length === 0) {
            return this.negotiator.languages();
        }
        return this.negotiator.languages(languages)[0] || false;
    }
}
function extToMime(type1) {
    return type1.indexOf("/") === -1 ? lookup1(type1) : type1;
}
function validMime(type1) {
    return typeof type1 === "string";
}
const db2 = JSON.parse(`{\n  "application/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "application/3gpdash-qoe-report+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/3gpp-ims+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/a2l": {\n    "source": "iana"\n  },\n  "application/activemessage": {\n    "source": "iana"\n  },\n  "application/activity+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-directory+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcost+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcostparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointprop+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointpropparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-error+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamcontrol+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/aml": {\n    "source": "iana"\n  },\n  "application/andrew-inset": {\n    "source": "iana",\n    "extensions": ["ez"]\n  },\n  "application/applefile": {\n    "source": "iana"\n  },\n  "application/applixware": {\n    "source": "apache",\n    "extensions": ["aw"]\n  },\n  "application/atf": {\n    "source": "iana"\n  },\n  "application/atfx": {\n    "source": "iana"\n  },\n  "application/atom+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atom"]\n  },\n  "application/atomcat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomcat"]\n  },\n  "application/atomdeleted+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomdeleted"]\n  },\n  "application/atomicmail": {\n    "source": "iana"\n  },\n  "application/atomsvc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomsvc"]\n  },\n  "application/atsc-dwd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dwd"]\n  },\n  "application/atsc-dynamic-event-message": {\n    "source": "iana"\n  },\n  "application/atsc-held+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["held"]\n  },\n  "application/atsc-rdt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/atsc-rsat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsat"]\n  },\n  "application/atxml": {\n    "source": "iana"\n  },\n  "application/auth-policy+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/bacnet-xdd+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/batch-smtp": {\n    "source": "iana"\n  },\n  "application/bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/beep+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/calendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/calendar+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xcs"]\n  },\n  "application/call-completion": {\n    "source": "iana"\n  },\n  "application/cals-1840": {\n    "source": "iana"\n  },\n  "application/captive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cbor": {\n    "source": "iana"\n  },\n  "application/cbor-seq": {\n    "source": "iana"\n  },\n  "application/cccex": {\n    "source": "iana"\n  },\n  "application/ccmp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ccxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ccxml"]\n  },\n  "application/cdfx+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdfx"]\n  },\n  "application/cdmi-capability": {\n    "source": "iana",\n    "extensions": ["cdmia"]\n  },\n  "application/cdmi-container": {\n    "source": "iana",\n    "extensions": ["cdmic"]\n  },\n  "application/cdmi-domain": {\n    "source": "iana",\n    "extensions": ["cdmid"]\n  },\n  "application/cdmi-object": {\n    "source": "iana",\n    "extensions": ["cdmio"]\n  },\n  "application/cdmi-queue": {\n    "source": "iana",\n    "extensions": ["cdmiq"]\n  },\n  "application/cdni": {\n    "source": "iana"\n  },\n  "application/cea": {\n    "source": "iana"\n  },\n  "application/cea-2018+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cellml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cfw": {\n    "source": "iana"\n  },\n  "application/clr": {\n    "source": "iana"\n  },\n  "application/clue+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/clue_info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cms": {\n    "source": "iana"\n  },\n  "application/cnrp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-group+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-payload": {\n    "source": "iana"\n  },\n  "application/commonground": {\n    "source": "iana"\n  },\n  "application/conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cose": {\n    "source": "iana"\n  },\n  "application/cose-key": {\n    "source": "iana"\n  },\n  "application/cose-key-set": {\n    "source": "iana"\n  },\n  "application/cpl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csrattrs": {\n    "source": "iana"\n  },\n  "application/csta+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cstadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csvm+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cu-seeme": {\n    "source": "apache",\n    "extensions": ["cu"]\n  },\n  "application/cwt": {\n    "source": "iana"\n  },\n  "application/cybercash": {\n    "source": "iana"\n  },\n  "application/dart": {\n    "compressible": true\n  },\n  "application/dash+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpd"]\n  },\n  "application/dashdelta": {\n    "source": "iana"\n  },\n  "application/davmount+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["davmount"]\n  },\n  "application/dca-rft": {\n    "source": "iana"\n  },\n  "application/dcd": {\n    "source": "iana"\n  },\n  "application/dec-dx": {\n    "source": "iana"\n  },\n  "application/dialog-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom": {\n    "source": "iana"\n  },\n  "application/dicom+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dii": {\n    "source": "iana"\n  },\n  "application/dit": {\n    "source": "iana"\n  },\n  "application/dns": {\n    "source": "iana"\n  },\n  "application/dns+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dns-message": {\n    "source": "iana"\n  },\n  "application/docbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dbk"]\n  },\n  "application/dots+cbor": {\n    "source": "iana"\n  },\n  "application/dskpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dssc+der": {\n    "source": "iana",\n    "extensions": ["dssc"]\n  },\n  "application/dssc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdssc"]\n  },\n  "application/dvcs": {\n    "source": "iana"\n  },\n  "application/ecmascript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es","ecma"]\n  },\n  "application/edi-consent": {\n    "source": "iana"\n  },\n  "application/edi-x12": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/edifact": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/efi": {\n    "source": "iana"\n  },\n  "application/elm+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/elm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.cap+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/emergencycalldata.comment+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.deviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.ecall.msd": {\n    "source": "iana"\n  },\n  "application/emergencycalldata.providerinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.serviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.subscriberinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.veds+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emma+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emma"]\n  },\n  "application/emotionml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emotionml"]\n  },\n  "application/encaprtp": {\n    "source": "iana"\n  },\n  "application/epp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/epub+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["epub"]\n  },\n  "application/eshop": {\n    "source": "iana"\n  },\n  "application/exi": {\n    "source": "iana",\n    "extensions": ["exi"]\n  },\n  "application/expect-ct-report+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/fastinfoset": {\n    "source": "iana"\n  },\n  "application/fastsoap": {\n    "source": "iana"\n  },\n  "application/fdt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fdt"]\n  },\n  "application/fhir+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fhir+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fido.trusted-apps+json": {\n    "compressible": true\n  },\n  "application/fits": {\n    "source": "iana"\n  },\n  "application/flexfec": {\n    "source": "iana"\n  },\n  "application/font-sfnt": {\n    "source": "iana"\n  },\n  "application/font-tdpfr": {\n    "source": "iana",\n    "extensions": ["pfr"]\n  },\n  "application/font-woff": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/framework-attributes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/geo+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["geojson"]\n  },\n  "application/geo+json-seq": {\n    "source": "iana"\n  },\n  "application/geopackage+sqlite3": {\n    "source": "iana"\n  },\n  "application/geoxacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/gltf-buffer": {\n    "source": "iana"\n  },\n  "application/gml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gml"]\n  },\n  "application/gpx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["gpx"]\n  },\n  "application/gxf": {\n    "source": "apache",\n    "extensions": ["gxf"]\n  },\n  "application/gzip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gz"]\n  },\n  "application/h224": {\n    "source": "iana"\n  },\n  "application/held+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/hjson": {\n    "extensions": ["hjson"]\n  },\n  "application/http": {\n    "source": "iana"\n  },\n  "application/hyperstudio": {\n    "source": "iana",\n    "extensions": ["stk"]\n  },\n  "application/ibe-key-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pkg-reply+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pp-data": {\n    "source": "iana"\n  },\n  "application/iges": {\n    "source": "iana"\n  },\n  "application/im-iscomposing+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/index": {\n    "source": "iana"\n  },\n  "application/index.cmd": {\n    "source": "iana"\n  },\n  "application/index.obj": {\n    "source": "iana"\n  },\n  "application/index.response": {\n    "source": "iana"\n  },\n  "application/index.vnd": {\n    "source": "iana"\n  },\n  "application/inkml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ink","inkml"]\n  },\n  "application/iotp": {\n    "source": "iana"\n  },\n  "application/ipfix": {\n    "source": "iana",\n    "extensions": ["ipfix"]\n  },\n  "application/ipp": {\n    "source": "iana"\n  },\n  "application/isup": {\n    "source": "iana"\n  },\n  "application/its+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["its"]\n  },\n  "application/java-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jar","war","ear"]\n  },\n  "application/java-serialized-object": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["ser"]\n  },\n  "application/java-vm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["class"]\n  },\n  "application/javascript": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["js","mjs"]\n  },\n  "application/jf2feed+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jose": {\n    "source": "iana"\n  },\n  "application/jose+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jrd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jscalendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["json","map"]\n  },\n  "application/json-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json-seq": {\n    "source": "iana"\n  },\n  "application/json5": {\n    "extensions": ["json5"]\n  },\n  "application/jsonml+json": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["jsonml"]\n  },\n  "application/jwk+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwk-set+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwt": {\n    "source": "iana"\n  },\n  "application/kpml-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/kpml-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ld+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["jsonld"]\n  },\n  "application/lgr+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lgr"]\n  },\n  "application/link-format": {\n    "source": "iana"\n  },\n  "application/load-control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lost+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lostxml"]\n  },\n  "application/lostsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lpf+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/lxf": {\n    "source": "iana"\n  },\n  "application/mac-binhex40": {\n    "source": "iana",\n    "extensions": ["hqx"]\n  },\n  "application/mac-compactpro": {\n    "source": "apache",\n    "extensions": ["cpt"]\n  },\n  "application/macwriteii": {\n    "source": "iana"\n  },\n  "application/mads+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mads"]\n  },\n  "application/manifest+json": {\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["webmanifest"]\n  },\n  "application/marc": {\n    "source": "iana",\n    "extensions": ["mrc"]\n  },\n  "application/marcxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mrcx"]\n  },\n  "application/mathematica": {\n    "source": "iana",\n    "extensions": ["ma","nb","mb"]\n  },\n  "application/mathml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mathml"]\n  },\n  "application/mathml-content+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mathml-presentation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-associated-procedure-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-deregister+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-envelope+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-protection-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-reception-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-schedule+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-user-service-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbox": {\n    "source": "iana",\n    "extensions": ["mbox"]\n  },\n  "application/media-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/media_control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mediaservercontrol+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mscml"]\n  },\n  "application/merge-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/metalink+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["metalink"]\n  },\n  "application/metalink4+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["meta4"]\n  },\n  "application/mets+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mets"]\n  },\n  "application/mf4": {\n    "source": "iana"\n  },\n  "application/mikey": {\n    "source": "iana"\n  },\n  "application/mipc": {\n    "source": "iana"\n  },\n  "application/mmt-aei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["maei"]\n  },\n  "application/mmt-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musd"]\n  },\n  "application/mods+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mods"]\n  },\n  "application/moss-keys": {\n    "source": "iana"\n  },\n  "application/moss-signature": {\n    "source": "iana"\n  },\n  "application/mosskey-data": {\n    "source": "iana"\n  },\n  "application/mosskey-request": {\n    "source": "iana"\n  },\n  "application/mp21": {\n    "source": "iana",\n    "extensions": ["m21","mp21"]\n  },\n  "application/mp4": {\n    "source": "iana",\n    "extensions": ["mp4s","m4p"]\n  },\n  "application/mpeg4-generic": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod-xmt": {\n    "source": "iana"\n  },\n  "application/mrb-consumer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mrb-publish+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/msc-ivr+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msc-mixer+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msword": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["doc","dot"]\n  },\n  "application/mud+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/multipart-core": {\n    "source": "iana"\n  },\n  "application/mxf": {\n    "source": "iana",\n    "extensions": ["mxf"]\n  },\n  "application/n-quads": {\n    "source": "iana",\n    "extensions": ["nq"]\n  },\n  "application/n-triples": {\n    "source": "iana",\n    "extensions": ["nt"]\n  },\n  "application/nasdata": {\n    "source": "iana"\n  },\n  "application/news-checkgroups": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-groupinfo": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-transmission": {\n    "source": "iana"\n  },\n  "application/nlsml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/node": {\n    "source": "iana",\n    "extensions": ["cjs"]\n  },\n  "application/nss": {\n    "source": "iana"\n  },\n  "application/ocsp-request": {\n    "source": "iana"\n  },\n  "application/ocsp-response": {\n    "source": "iana"\n  },\n  "application/octet-stream": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]\n  },\n  "application/oda": {\n    "source": "iana",\n    "extensions": ["oda"]\n  },\n  "application/odm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/odx": {\n    "source": "iana"\n  },\n  "application/oebps-package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["opf"]\n  },\n  "application/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogx"]\n  },\n  "application/omdoc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["omdoc"]\n  },\n  "application/onenote": {\n    "source": "apache",\n    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]\n  },\n  "application/opc-nodeset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/oscore": {\n    "source": "iana"\n  },\n  "application/oxps": {\n    "source": "iana",\n    "extensions": ["oxps"]\n  },\n  "application/p2p-overlay+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["relo"]\n  },\n  "application/parityfec": {\n    "source": "iana"\n  },\n  "application/passport": {\n    "source": "iana"\n  },\n  "application/patch-ops-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/pdf": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pdf"]\n  },\n  "application/pdx": {\n    "source": "iana"\n  },\n  "application/pem-certificate-chain": {\n    "source": "iana"\n  },\n  "application/pgp-encrypted": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pgp"]\n  },\n  "application/pgp-keys": {\n    "source": "iana"\n  },\n  "application/pgp-signature": {\n    "source": "iana",\n    "extensions": ["asc","sig"]\n  },\n  "application/pics-rules": {\n    "source": "apache",\n    "extensions": ["prf"]\n  },\n  "application/pidf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pidf-diff+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pkcs10": {\n    "source": "iana",\n    "extensions": ["p10"]\n  },\n  "application/pkcs12": {\n    "source": "iana"\n  },\n  "application/pkcs7-mime": {\n    "source": "iana",\n    "extensions": ["p7m","p7c"]\n  },\n  "application/pkcs7-signature": {\n    "source": "iana",\n    "extensions": ["p7s"]\n  },\n  "application/pkcs8": {\n    "source": "iana",\n    "extensions": ["p8"]\n  },\n  "application/pkcs8-encrypted": {\n    "source": "iana"\n  },\n  "application/pkix-attr-cert": {\n    "source": "iana",\n    "extensions": ["ac"]\n  },\n  "application/pkix-cert": {\n    "source": "iana",\n    "extensions": ["cer"]\n  },\n  "application/pkix-crl": {\n    "source": "iana",\n    "extensions": ["crl"]\n  },\n  "application/pkix-pkipath": {\n    "source": "iana",\n    "extensions": ["pkipath"]\n  },\n  "application/pkixcmp": {\n    "source": "iana",\n    "extensions": ["pki"]\n  },\n  "application/pls+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pls"]\n  },\n  "application/poc-settings+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/postscript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ai","eps","ps"]\n  },\n  "application/ppsp-tracker+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/provenance+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["provx"]\n  },\n  "application/prs.alvestrand.titrax-sheet": {\n    "source": "iana"\n  },\n  "application/prs.cww": {\n    "source": "iana",\n    "extensions": ["cww"]\n  },\n  "application/prs.cyn": {\n    "source": "iana",\n    "charset": "7-BIT"\n  },\n  "application/prs.hpub+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/prs.nprend": {\n    "source": "iana"\n  },\n  "application/prs.plucker": {\n    "source": "iana"\n  },\n  "application/prs.rdf-xml-crypt": {\n    "source": "iana"\n  },\n  "application/prs.xsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/pskc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pskcxml"]\n  },\n  "application/pvd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/qsig": {\n    "source": "iana"\n  },\n  "application/raml+yaml": {\n    "compressible": true,\n    "extensions": ["raml"]\n  },\n  "application/raptorfec": {\n    "source": "iana"\n  },\n  "application/rdap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rdf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rdf","owl"]\n  },\n  "application/reginfo+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rif"]\n  },\n  "application/relax-ng-compact-syntax": {\n    "source": "iana",\n    "extensions": ["rnc"]\n  },\n  "application/remote-printing": {\n    "source": "iana"\n  },\n  "application/reputon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/resource-lists+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rl"]\n  },\n  "application/resource-lists-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rld"]\n  },\n  "application/rfc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/riscos": {\n    "source": "iana"\n  },\n  "application/rlmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rls-services+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rs"]\n  },\n  "application/route-apd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rapd"]\n  },\n  "application/route-s-tsid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sls"]\n  },\n  "application/route-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rusd"]\n  },\n  "application/rpki-ghostbusters": {\n    "source": "iana",\n    "extensions": ["gbr"]\n  },\n  "application/rpki-manifest": {\n    "source": "iana",\n    "extensions": ["mft"]\n  },\n  "application/rpki-publication": {\n    "source": "iana"\n  },\n  "application/rpki-roa": {\n    "source": "iana",\n    "extensions": ["roa"]\n  },\n  "application/rpki-updown": {\n    "source": "iana"\n  },\n  "application/rsd+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rsd"]\n  },\n  "application/rss+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rss"]\n  },\n  "application/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "application/rtploopback": {\n    "source": "iana"\n  },\n  "application/rtx": {\n    "source": "iana"\n  },\n  "application/samlassertion+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/samlmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sarif+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sbe": {\n    "source": "iana"\n  },\n  "application/sbml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sbml"]\n  },\n  "application/scaip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scim+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scvp-cv-request": {\n    "source": "iana",\n    "extensions": ["scq"]\n  },\n  "application/scvp-cv-response": {\n    "source": "iana",\n    "extensions": ["scs"]\n  },\n  "application/scvp-vp-request": {\n    "source": "iana",\n    "extensions": ["spq"]\n  },\n  "application/scvp-vp-response": {\n    "source": "iana",\n    "extensions": ["spp"]\n  },\n  "application/sdp": {\n    "source": "iana",\n    "extensions": ["sdp"]\n  },\n  "application/secevent+jwt": {\n    "source": "iana"\n  },\n  "application/senml+cbor": {\n    "source": "iana"\n  },\n  "application/senml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["senmlx"]\n  },\n  "application/senml-etch+cbor": {\n    "source": "iana"\n  },\n  "application/senml-etch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml-exi": {\n    "source": "iana"\n  },\n  "application/sensml+cbor": {\n    "source": "iana"\n  },\n  "application/sensml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sensml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sensmlx"]\n  },\n  "application/sensml-exi": {\n    "source": "iana"\n  },\n  "application/sep+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sep-exi": {\n    "source": "iana"\n  },\n  "application/session-info": {\n    "source": "iana"\n  },\n  "application/set-payment": {\n    "source": "iana"\n  },\n  "application/set-payment-initiation": {\n    "source": "iana",\n    "extensions": ["setpay"]\n  },\n  "application/set-registration": {\n    "source": "iana"\n  },\n  "application/set-registration-initiation": {\n    "source": "iana",\n    "extensions": ["setreg"]\n  },\n  "application/sgml": {\n    "source": "iana"\n  },\n  "application/sgml-open-catalog": {\n    "source": "iana"\n  },\n  "application/shf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["shf"]\n  },\n  "application/sieve": {\n    "source": "iana",\n    "extensions": ["siv","sieve"]\n  },\n  "application/simple-filter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/simple-message-summary": {\n    "source": "iana"\n  },\n  "application/simplesymbolcontainer": {\n    "source": "iana"\n  },\n  "application/sipc": {\n    "source": "iana"\n  },\n  "application/slate": {\n    "source": "iana"\n  },\n  "application/smil": {\n    "source": "iana"\n  },\n  "application/smil+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["smi","smil"]\n  },\n  "application/smpte336m": {\n    "source": "iana"\n  },\n  "application/soap+fastinfoset": {\n    "source": "iana"\n  },\n  "application/soap+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sparql-query": {\n    "source": "iana",\n    "extensions": ["rq"]\n  },\n  "application/sparql-results+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["srx"]\n  },\n  "application/spirits-event+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sql": {\n    "source": "iana"\n  },\n  "application/srgs": {\n    "source": "iana",\n    "extensions": ["gram"]\n  },\n  "application/srgs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["grxml"]\n  },\n  "application/sru+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sru"]\n  },\n  "application/ssdl+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ssdl"]\n  },\n  "application/ssml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ssml"]\n  },\n  "application/stix+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/swid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["swidtag"]\n  },\n  "application/tamp-apex-update": {\n    "source": "iana"\n  },\n  "application/tamp-apex-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-community-update": {\n    "source": "iana"\n  },\n  "application/tamp-community-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-error": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-status-query": {\n    "source": "iana"\n  },\n  "application/tamp-status-response": {\n    "source": "iana"\n  },\n  "application/tamp-update": {\n    "source": "iana"\n  },\n  "application/tamp-update-confirm": {\n    "source": "iana"\n  },\n  "application/tar": {\n    "compressible": true\n  },\n  "application/taxii+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/td+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tei","teicorpus"]\n  },\n  "application/tetra_isi": {\n    "source": "iana"\n  },\n  "application/thraud+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tfi"]\n  },\n  "application/timestamp-query": {\n    "source": "iana"\n  },\n  "application/timestamp-reply": {\n    "source": "iana"\n  },\n  "application/timestamped-data": {\n    "source": "iana",\n    "extensions": ["tsd"]\n  },\n  "application/tlsrpt+gzip": {\n    "source": "iana"\n  },\n  "application/tlsrpt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tnauthlist": {\n    "source": "iana"\n  },\n  "application/toml": {\n    "compressible": true,\n    "extensions": ["toml"]\n  },\n  "application/trickle-ice-sdpfrag": {\n    "source": "iana"\n  },\n  "application/trig": {\n    "source": "iana"\n  },\n  "application/ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttml"]\n  },\n  "application/tve-trigger": {\n    "source": "iana"\n  },\n  "application/tzif": {\n    "source": "iana"\n  },\n  "application/tzif-leap": {\n    "source": "iana"\n  },\n  "application/ubjson": {\n    "compressible": false,\n    "extensions": ["ubj"]\n  },\n  "application/ulpfec": {\n    "source": "iana"\n  },\n  "application/urc-grpsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/urc-ressheet+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsheet"]\n  },\n  "application/urc-targetdesc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["td"]\n  },\n  "application/urc-uisocketdesc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vemmi": {\n    "source": "iana"\n  },\n  "application/vividence.scriptfile": {\n    "source": "apache"\n  },\n  "application/vnd.1000minds.decision-model+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["1km"]\n  },\n  "application/vnd.3gpp-prose+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-prose-pc3ch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-v2x-local-service-information": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.access-transfer-events+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.bsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.gmop+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.interworking-data": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mc-signalling-ear": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-payload": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-signalling": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-floor-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-signed+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-init-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-transmission-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mid-call+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.pic-bw-large": {\n    "source": "iana",\n    "extensions": ["plb"]\n  },\n  "application/vnd.3gpp.pic-bw-small": {\n    "source": "iana",\n    "extensions": ["psb"]\n  },\n  "application/vnd.3gpp.pic-bw-var": {\n    "source": "iana",\n    "extensions": ["pvb"]\n  },\n  "application/vnd.3gpp.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.sms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-ext+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.state-and-event-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.ussd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.bcmcsinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp2.tcap": {\n    "source": "iana",\n    "extensions": ["tcap"]\n  },\n  "application/vnd.3lightssoftware.imagescal": {\n    "source": "iana"\n  },\n  "application/vnd.3m.post-it-notes": {\n    "source": "iana",\n    "extensions": ["pwn"]\n  },\n  "application/vnd.accpac.simply.aso": {\n    "source": "iana",\n    "extensions": ["aso"]\n  },\n  "application/vnd.accpac.simply.imp": {\n    "source": "iana",\n    "extensions": ["imp"]\n  },\n  "application/vnd.acucobol": {\n    "source": "iana",\n    "extensions": ["acu"]\n  },\n  "application/vnd.acucorp": {\n    "source": "iana",\n    "extensions": ["atc","acutc"]\n  },\n  "application/vnd.adobe.air-application-installer-package+zip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["air"]\n  },\n  "application/vnd.adobe.flash.movie": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.formscentral.fcdt": {\n    "source": "iana",\n    "extensions": ["fcdt"]\n  },\n  "application/vnd.adobe.fxp": {\n    "source": "iana",\n    "extensions": ["fxp","fxpl"]\n  },\n  "application/vnd.adobe.partial-upload": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.xdp+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdp"]\n  },\n  "application/vnd.adobe.xfdf": {\n    "source": "iana",\n    "extensions": ["xfdf"]\n  },\n  "application/vnd.aether.imp": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata-pagedef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.cmoca-cmresource": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-charset": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codedfont": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codepage": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-cmtable": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-formdef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-mediummap": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-objectcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-overlay": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-pagesegment": {\n    "source": "iana"\n  },\n  "application/vnd.ah-barcode": {\n    "source": "iana"\n  },\n  "application/vnd.ahead.space": {\n    "source": "iana",\n    "extensions": ["ahead"]\n  },\n  "application/vnd.airzip.filesecure.azf": {\n    "source": "iana",\n    "extensions": ["azf"]\n  },\n  "application/vnd.airzip.filesecure.azs": {\n    "source": "iana",\n    "extensions": ["azs"]\n  },\n  "application/vnd.amadeus+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.amazon.ebook": {\n    "source": "apache",\n    "extensions": ["azw"]\n  },\n  "application/vnd.amazon.mobi8-ebook": {\n    "source": "iana"\n  },\n  "application/vnd.americandynamics.acc": {\n    "source": "iana",\n    "extensions": ["acc"]\n  },\n  "application/vnd.amiga.ami": {\n    "source": "iana",\n    "extensions": ["ami"]\n  },\n  "application/vnd.amundsen.maze+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.android.ota": {\n    "source": "iana"\n  },\n  "application/vnd.android.package-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["apk"]\n  },\n  "application/vnd.anki": {\n    "source": "iana"\n  },\n  "application/vnd.anser-web-certificate-issue-initiation": {\n    "source": "iana",\n    "extensions": ["cii"]\n  },\n  "application/vnd.anser-web-funds-transfer-initiation": {\n    "source": "apache",\n    "extensions": ["fti"]\n  },\n  "application/vnd.antix.game-component": {\n    "source": "iana",\n    "extensions": ["atx"]\n  },\n  "application/vnd.apache.thrift.binary": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.compact": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.json": {\n    "source": "iana"\n  },\n  "application/vnd.api+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.aplextor.warrp+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apothekende.reservation+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apple.installer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpkg"]\n  },\n  "application/vnd.apple.keynote": {\n    "source": "iana",\n    "extensions": ["key"]\n  },\n  "application/vnd.apple.mpegurl": {\n    "source": "iana",\n    "extensions": ["m3u8"]\n  },\n  "application/vnd.apple.numbers": {\n    "source": "iana",\n    "extensions": ["numbers"]\n  },\n  "application/vnd.apple.pages": {\n    "source": "iana",\n    "extensions": ["pages"]\n  },\n  "application/vnd.apple.pkpass": {\n    "compressible": false,\n    "extensions": ["pkpass"]\n  },\n  "application/vnd.arastra.swi": {\n    "source": "iana"\n  },\n  "application/vnd.aristanetworks.swi": {\n    "source": "iana",\n    "extensions": ["swi"]\n  },\n  "application/vnd.artisan+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.artsquare": {\n    "source": "iana"\n  },\n  "application/vnd.astraea-software.iota": {\n    "source": "iana",\n    "extensions": ["iota"]\n  },\n  "application/vnd.audiograph": {\n    "source": "iana",\n    "extensions": ["aep"]\n  },\n  "application/vnd.autopackage": {\n    "source": "iana"\n  },\n  "application/vnd.avalon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.avistar+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.balsamiq.bmml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmml"]\n  },\n  "application/vnd.balsamiq.bmpr": {\n    "source": "iana"\n  },\n  "application/vnd.banana-accounting": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.error": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bekitzur-stech+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bint.med-content": {\n    "source": "iana"\n  },\n  "application/vnd.biopax.rdf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.blink-idb-value-wrapper": {\n    "source": "iana"\n  },\n  "application/vnd.blueice.multipass": {\n    "source": "iana",\n    "extensions": ["mpm"]\n  },\n  "application/vnd.bluetooth.ep.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bluetooth.le.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bmi": {\n    "source": "iana",\n    "extensions": ["bmi"]\n  },\n  "application/vnd.bpf": {\n    "source": "iana"\n  },\n  "application/vnd.bpf3": {\n    "source": "iana"\n  },\n  "application/vnd.businessobjects": {\n    "source": "iana",\n    "extensions": ["rep"]\n  },\n  "application/vnd.byu.uapi+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cab-jscript": {\n    "source": "iana"\n  },\n  "application/vnd.canon-cpdl": {\n    "source": "iana"\n  },\n  "application/vnd.canon-lips": {\n    "source": "iana"\n  },\n  "application/vnd.capasystems-pg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cendio.thinlinc.clientconf": {\n    "source": "iana"\n  },\n  "application/vnd.century-systems.tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.chemdraw+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdxml"]\n  },\n  "application/vnd.chess-pgn": {\n    "source": "iana"\n  },\n  "application/vnd.chipnuts.karaoke-mmd": {\n    "source": "iana",\n    "extensions": ["mmd"]\n  },\n  "application/vnd.ciedi": {\n    "source": "iana"\n  },\n  "application/vnd.cinderella": {\n    "source": "iana",\n    "extensions": ["cdy"]\n  },\n  "application/vnd.cirpack.isdn-ext": {\n    "source": "iana"\n  },\n  "application/vnd.citationstyles.style+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csl"]\n  },\n  "application/vnd.claymore": {\n    "source": "iana",\n    "extensions": ["cla"]\n  },\n  "application/vnd.cloanto.rp9": {\n    "source": "iana",\n    "extensions": ["rp9"]\n  },\n  "application/vnd.clonk.c4group": {\n    "source": "iana",\n    "extensions": ["c4g","c4d","c4f","c4p","c4u"]\n  },\n  "application/vnd.cluetrust.cartomobile-config": {\n    "source": "iana",\n    "extensions": ["c11amc"]\n  },\n  "application/vnd.cluetrust.cartomobile-config-pkg": {\n    "source": "iana",\n    "extensions": ["c11amz"]\n  },\n  "application/vnd.coffeescript": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet-template": {\n    "source": "iana"\n  },\n  "application/vnd.collection+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.doc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.next+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.comicbook+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.comicbook-rar": {\n    "source": "iana"\n  },\n  "application/vnd.commerce-battelle": {\n    "source": "iana"\n  },\n  "application/vnd.commonspace": {\n    "source": "iana",\n    "extensions": ["csp"]\n  },\n  "application/vnd.contact.cmsg": {\n    "source": "iana",\n    "extensions": ["cdbcmsg"]\n  },\n  "application/vnd.coreos.ignition+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cosmocaller": {\n    "source": "iana",\n    "extensions": ["cmc"]\n  },\n  "application/vnd.crick.clicker": {\n    "source": "iana",\n    "extensions": ["clkx"]\n  },\n  "application/vnd.crick.clicker.keyboard": {\n    "source": "iana",\n    "extensions": ["clkk"]\n  },\n  "application/vnd.crick.clicker.palette": {\n    "source": "iana",\n    "extensions": ["clkp"]\n  },\n  "application/vnd.crick.clicker.template": {\n    "source": "iana",\n    "extensions": ["clkt"]\n  },\n  "application/vnd.crick.clicker.wordbank": {\n    "source": "iana",\n    "extensions": ["clkw"]\n  },\n  "application/vnd.criticaltools.wbs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wbs"]\n  },\n  "application/vnd.cryptii.pipe+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.crypto-shade-file": {\n    "source": "iana"\n  },\n  "application/vnd.cryptomator.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.ctc-posml": {\n    "source": "iana",\n    "extensions": ["pml"]\n  },\n  "application/vnd.ctct.ws+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cups-pdf": {\n    "source": "iana"\n  },\n  "application/vnd.cups-postscript": {\n    "source": "iana"\n  },\n  "application/vnd.cups-ppd": {\n    "source": "iana",\n    "extensions": ["ppd"]\n  },\n  "application/vnd.cups-raster": {\n    "source": "iana"\n  },\n  "application/vnd.cups-raw": {\n    "source": "iana"\n  },\n  "application/vnd.curl": {\n    "source": "iana"\n  },\n  "application/vnd.curl.car": {\n    "source": "apache",\n    "extensions": ["car"]\n  },\n  "application/vnd.curl.pcurl": {\n    "source": "apache",\n    "extensions": ["pcurl"]\n  },\n  "application/vnd.cyan.dean.root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cybank": {\n    "source": "iana"\n  },\n  "application/vnd.cyclonedx+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cyclonedx+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.d2l.coursepackage1p0+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.d3m-dataset": {\n    "source": "iana"\n  },\n  "application/vnd.d3m-problem": {\n    "source": "iana"\n  },\n  "application/vnd.dart": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dart"]\n  },\n  "application/vnd.data-vision.rdz": {\n    "source": "iana",\n    "extensions": ["rdz"]\n  },\n  "application/vnd.datapackage+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dataresource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dbf": {\n    "source": "iana",\n    "extensions": ["dbf"]\n  },\n  "application/vnd.debian.binary-package": {\n    "source": "iana"\n  },\n  "application/vnd.dece.data": {\n    "source": "iana",\n    "extensions": ["uvf","uvvf","uvd","uvvd"]\n  },\n  "application/vnd.dece.ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uvt","uvvt"]\n  },\n  "application/vnd.dece.unspecified": {\n    "source": "iana",\n    "extensions": ["uvx","uvvx"]\n  },\n  "application/vnd.dece.zip": {\n    "source": "iana",\n    "extensions": ["uvz","uvvz"]\n  },\n  "application/vnd.denovo.fcselayout-link": {\n    "source": "iana",\n    "extensions": ["fe_launch"]\n  },\n  "application/vnd.desmume.movie": {\n    "source": "iana"\n  },\n  "application/vnd.dir-bi.plate-dl-nosuffix": {\n    "source": "iana"\n  },\n  "application/vnd.dm.delegation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dna": {\n    "source": "iana",\n    "extensions": ["dna"]\n  },\n  "application/vnd.document+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dolby.mlp": {\n    "source": "apache",\n    "extensions": ["mlp"]\n  },\n  "application/vnd.dolby.mobile.1": {\n    "source": "iana"\n  },\n  "application/vnd.dolby.mobile.2": {\n    "source": "iana"\n  },\n  "application/vnd.doremir.scorecloud-binary-document": {\n    "source": "iana"\n  },\n  "application/vnd.dpgraph": {\n    "source": "iana",\n    "extensions": ["dpg"]\n  },\n  "application/vnd.dreamfactory": {\n    "source": "iana",\n    "extensions": ["dfac"]\n  },\n  "application/vnd.drive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ds-keypoint": {\n    "source": "apache",\n    "extensions": ["kpxx"]\n  },\n  "application/vnd.dtg.local": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.flash": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.html": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ait": {\n    "source": "iana",\n    "extensions": ["ait"]\n  },\n  "application/vnd.dvb.dvbisl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.dvbj": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.esgcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcdftnotifaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess2": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgpdd": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcroaming": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-base": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-enhancement": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.notif-aggregate-root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-container+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-generic+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-msglist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-init+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.pfr": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.service": {\n    "source": "iana",\n    "extensions": ["svc"]\n  },\n  "application/vnd.dxr": {\n    "source": "iana"\n  },\n  "application/vnd.dynageo": {\n    "source": "iana",\n    "extensions": ["geo"]\n  },\n  "application/vnd.dzr": {\n    "source": "iana"\n  },\n  "application/vnd.easykaraoke.cdgdownload": {\n    "source": "iana"\n  },\n  "application/vnd.ecdis-update": {\n    "source": "iana"\n  },\n  "application/vnd.ecip.rlp": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.chart": {\n    "source": "iana",\n    "extensions": ["mag"]\n  },\n  "application/vnd.ecowin.filerequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.fileupdate": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.series": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesrequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesupdate": {\n    "source": "iana"\n  },\n  "application/vnd.efi.img": {\n    "source": "iana"\n  },\n  "application/vnd.efi.iso": {\n    "source": "iana"\n  },\n  "application/vnd.emclient.accessrequest+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.enliven": {\n    "source": "iana",\n    "extensions": ["nml"]\n  },\n  "application/vnd.enphase.envoy": {\n    "source": "iana"\n  },\n  "application/vnd.eprints.data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.epson.esf": {\n    "source": "iana",\n    "extensions": ["esf"]\n  },\n  "application/vnd.epson.msf": {\n    "source": "iana",\n    "extensions": ["msf"]\n  },\n  "application/vnd.epson.quickanime": {\n    "source": "iana",\n    "extensions": ["qam"]\n  },\n  "application/vnd.epson.salt": {\n    "source": "iana",\n    "extensions": ["slt"]\n  },\n  "application/vnd.epson.ssf": {\n    "source": "iana",\n    "extensions": ["ssf"]\n  },\n  "application/vnd.ericsson.quickcall": {\n    "source": "iana"\n  },\n  "application/vnd.espass-espass+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.eszigno3+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es3","et3"]\n  },\n  "application/vnd.etsi.aoc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.asic-e+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.asic-s+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.cug+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvcommand+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-bc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-cod+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-npvr+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvservice+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mcid+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mheg5": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.overload-control-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.pstn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.sci+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.simservs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.timestamp-token": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.tsl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.tsl.der": {\n    "source": "iana"\n  },\n  "application/vnd.eudora.data": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.profile": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.settings": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.theme": {\n    "source": "iana"\n  },\n  "application/vnd.exstream-empower+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.exstream-package": {\n    "source": "iana"\n  },\n  "application/vnd.ezpix-album": {\n    "source": "iana",\n    "extensions": ["ez2"]\n  },\n  "application/vnd.ezpix-package": {\n    "source": "iana",\n    "extensions": ["ez3"]\n  },\n  "application/vnd.f-secure.mobile": {\n    "source": "iana"\n  },\n  "application/vnd.fastcopy-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.fdf": {\n    "source": "iana",\n    "extensions": ["fdf"]\n  },\n  "application/vnd.fdsn.mseed": {\n    "source": "iana",\n    "extensions": ["mseed"]\n  },\n  "application/vnd.fdsn.seed": {\n    "source": "iana",\n    "extensions": ["seed","dataless"]\n  },\n  "application/vnd.ffsns": {\n    "source": "iana"\n  },\n  "application/vnd.ficlab.flb+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.filmit.zfc": {\n    "source": "iana"\n  },\n  "application/vnd.fints": {\n    "source": "iana"\n  },\n  "application/vnd.firemonkeys.cloudcell": {\n    "source": "iana"\n  },\n  "application/vnd.flographit": {\n    "source": "iana",\n    "extensions": ["gph"]\n  },\n  "application/vnd.fluxtime.clip": {\n    "source": "iana",\n    "extensions": ["ftc"]\n  },\n  "application/vnd.font-fontforge-sfd": {\n    "source": "iana"\n  },\n  "application/vnd.framemaker": {\n    "source": "iana",\n    "extensions": ["fm","frame","maker","book"]\n  },\n  "application/vnd.frogans.fnc": {\n    "source": "iana",\n    "extensions": ["fnc"]\n  },\n  "application/vnd.frogans.ltf": {\n    "source": "iana",\n    "extensions": ["ltf"]\n  },\n  "application/vnd.fsc.weblaunch": {\n    "source": "iana",\n    "extensions": ["fsc"]\n  },\n  "application/vnd.fujitsu.oasys": {\n    "source": "iana",\n    "extensions": ["oas"]\n  },\n  "application/vnd.fujitsu.oasys2": {\n    "source": "iana",\n    "extensions": ["oa2"]\n  },\n  "application/vnd.fujitsu.oasys3": {\n    "source": "iana",\n    "extensions": ["oa3"]\n  },\n  "application/vnd.fujitsu.oasysgp": {\n    "source": "iana",\n    "extensions": ["fg5"]\n  },\n  "application/vnd.fujitsu.oasysprs": {\n    "source": "iana",\n    "extensions": ["bh2"]\n  },\n  "application/vnd.fujixerox.art-ex": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.art4": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.ddd": {\n    "source": "iana",\n    "extensions": ["ddd"]\n  },\n  "application/vnd.fujixerox.docuworks": {\n    "source": "iana",\n    "extensions": ["xdw"]\n  },\n  "application/vnd.fujixerox.docuworks.binder": {\n    "source": "iana",\n    "extensions": ["xbd"]\n  },\n  "application/vnd.fujixerox.docuworks.container": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.hbpl": {\n    "source": "iana"\n  },\n  "application/vnd.fut-misnet": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.fuzzysheet": {\n    "source": "iana",\n    "extensions": ["fzs"]\n  },\n  "application/vnd.genomatix.tuxedo": {\n    "source": "iana",\n    "extensions": ["txd"]\n  },\n  "application/vnd.gentics.grd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geo+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geocube+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geogebra.file": {\n    "source": "iana",\n    "extensions": ["ggb"]\n  },\n  "application/vnd.geogebra.slides": {\n    "source": "iana"\n  },\n  "application/vnd.geogebra.tool": {\n    "source": "iana",\n    "extensions": ["ggt"]\n  },\n  "application/vnd.geometry-explorer": {\n    "source": "iana",\n    "extensions": ["gex","gre"]\n  },\n  "application/vnd.geonext": {\n    "source": "iana",\n    "extensions": ["gxt"]\n  },\n  "application/vnd.geoplan": {\n    "source": "iana",\n    "extensions": ["g2w"]\n  },\n  "application/vnd.geospace": {\n    "source": "iana",\n    "extensions": ["g3w"]\n  },\n  "application/vnd.gerber": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt-response": {\n    "source": "iana"\n  },\n  "application/vnd.gmx": {\n    "source": "iana",\n    "extensions": ["gmx"]\n  },\n  "application/vnd.google-apps.document": {\n    "compressible": false,\n    "extensions": ["gdoc"]\n  },\n  "application/vnd.google-apps.presentation": {\n    "compressible": false,\n    "extensions": ["gslides"]\n  },\n  "application/vnd.google-apps.spreadsheet": {\n    "compressible": false,\n    "extensions": ["gsheet"]\n  },\n  "application/vnd.google-earth.kml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["kml"]\n  },\n  "application/vnd.google-earth.kmz": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["kmz"]\n  },\n  "application/vnd.gov.sk.e-form+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.gov.sk.e-form+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.gov.sk.xmldatacontainer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.grafeq": {\n    "source": "iana",\n    "extensions": ["gqf","gqs"]\n  },\n  "application/vnd.gridmp": {\n    "source": "iana"\n  },\n  "application/vnd.groove-account": {\n    "source": "iana",\n    "extensions": ["gac"]\n  },\n  "application/vnd.groove-help": {\n    "source": "iana",\n    "extensions": ["ghf"]\n  },\n  "application/vnd.groove-identity-message": {\n    "source": "iana",\n    "extensions": ["gim"]\n  },\n  "application/vnd.groove-injector": {\n    "source": "iana",\n    "extensions": ["grv"]\n  },\n  "application/vnd.groove-tool-message": {\n    "source": "iana",\n    "extensions": ["gtm"]\n  },\n  "application/vnd.groove-tool-template": {\n    "source": "iana",\n    "extensions": ["tpl"]\n  },\n  "application/vnd.groove-vcard": {\n    "source": "iana",\n    "extensions": ["vcg"]\n  },\n  "application/vnd.hal+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hal+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["hal"]\n  },\n  "application/vnd.handheld-entertainment+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zmm"]\n  },\n  "application/vnd.hbci": {\n    "source": "iana",\n    "extensions": ["hbci"]\n  },\n  "application/vnd.hc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hcl-bireports": {\n    "source": "iana"\n  },\n  "application/vnd.hdt": {\n    "source": "iana"\n  },\n  "application/vnd.heroku+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hhe.lesson-player": {\n    "source": "iana",\n    "extensions": ["les"]\n  },\n  "application/vnd.hp-hpgl": {\n    "source": "iana",\n    "extensions": ["hpgl"]\n  },\n  "application/vnd.hp-hpid": {\n    "source": "iana",\n    "extensions": ["hpid"]\n  },\n  "application/vnd.hp-hps": {\n    "source": "iana",\n    "extensions": ["hps"]\n  },\n  "application/vnd.hp-jlyt": {\n    "source": "iana",\n    "extensions": ["jlt"]\n  },\n  "application/vnd.hp-pcl": {\n    "source": "iana",\n    "extensions": ["pcl"]\n  },\n  "application/vnd.hp-pclxl": {\n    "source": "iana",\n    "extensions": ["pclxl"]\n  },\n  "application/vnd.httphone": {\n    "source": "iana"\n  },\n  "application/vnd.hydrostatix.sof-data": {\n    "source": "iana",\n    "extensions": ["sfd-hdstx"]\n  },\n  "application/vnd.hyper+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyper-item+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyperdrive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hzn-3d-crossword": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.electronic-media": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.minipay": {\n    "source": "iana",\n    "extensions": ["mpy"]\n  },\n  "application/vnd.ibm.modcap": {\n    "source": "iana",\n    "extensions": ["afp","listafp","list3820"]\n  },\n  "application/vnd.ibm.rights-management": {\n    "source": "iana",\n    "extensions": ["irm"]\n  },\n  "application/vnd.ibm.secure-container": {\n    "source": "iana",\n    "extensions": ["sc"]\n  },\n  "application/vnd.iccprofile": {\n    "source": "iana",\n    "extensions": ["icc","icm"]\n  },\n  "application/vnd.ieee.1905": {\n    "source": "iana"\n  },\n  "application/vnd.igloader": {\n    "source": "iana",\n    "extensions": ["igl"]\n  },\n  "application/vnd.imagemeter.folder+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.imagemeter.image+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.immervision-ivp": {\n    "source": "iana",\n    "extensions": ["ivp"]\n  },\n  "application/vnd.immervision-ivu": {\n    "source": "iana",\n    "extensions": ["ivu"]\n  },\n  "application/vnd.ims.imsccv1p1": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p2": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p3": {\n    "source": "iana"\n  },\n  "application/vnd.ims.lis.v2.result+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy.id+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings.simple+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informedcontrol.rms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informix-visionary": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.innopath.wamp.notification": {\n    "source": "iana"\n  },\n  "application/vnd.insors.igm": {\n    "source": "iana",\n    "extensions": ["igm"]\n  },\n  "application/vnd.intercon.formnet": {\n    "source": "iana",\n    "extensions": ["xpw","xpx"]\n  },\n  "application/vnd.intergeo": {\n    "source": "iana",\n    "extensions": ["i2g"]\n  },\n  "application/vnd.intertrust.digibox": {\n    "source": "iana"\n  },\n  "application/vnd.intertrust.nncp": {\n    "source": "iana"\n  },\n  "application/vnd.intu.qbo": {\n    "source": "iana",\n    "extensions": ["qbo"]\n  },\n  "application/vnd.intu.qfx": {\n    "source": "iana",\n    "extensions": ["qfx"]\n  },\n  "application/vnd.iptc.g2.catalogitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.conceptitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.knowledgeitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.packageitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.planningitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ipunplugged.rcprofile": {\n    "source": "iana",\n    "extensions": ["rcprofile"]\n  },\n  "application/vnd.irepository.package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["irp"]\n  },\n  "application/vnd.is-xpr": {\n    "source": "iana",\n    "extensions": ["xpr"]\n  },\n  "application/vnd.isac.fcs": {\n    "source": "iana",\n    "extensions": ["fcs"]\n  },\n  "application/vnd.iso11783-10+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.jam": {\n    "source": "iana",\n    "extensions": ["jam"]\n  },\n  "application/vnd.japannet-directory-service": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-jpnstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-payment-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-setstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.jcp.javame.midlet-rms": {\n    "source": "iana",\n    "extensions": ["rms"]\n  },\n  "application/vnd.jisp": {\n    "source": "iana",\n    "extensions": ["jisp"]\n  },\n  "application/vnd.joost.joda-archive": {\n    "source": "iana",\n    "extensions": ["joda"]\n  },\n  "application/vnd.jsk.isdn-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.kahootz": {\n    "source": "iana",\n    "extensions": ["ktz","ktr"]\n  },\n  "application/vnd.kde.karbon": {\n    "source": "iana",\n    "extensions": ["karbon"]\n  },\n  "application/vnd.kde.kchart": {\n    "source": "iana",\n    "extensions": ["chrt"]\n  },\n  "application/vnd.kde.kformula": {\n    "source": "iana",\n    "extensions": ["kfo"]\n  },\n  "application/vnd.kde.kivio": {\n    "source": "iana",\n    "extensions": ["flw"]\n  },\n  "application/vnd.kde.kontour": {\n    "source": "iana",\n    "extensions": ["kon"]\n  },\n  "application/vnd.kde.kpresenter": {\n    "source": "iana",\n    "extensions": ["kpr","kpt"]\n  },\n  "application/vnd.kde.kspread": {\n    "source": "iana",\n    "extensions": ["ksp"]\n  },\n  "application/vnd.kde.kword": {\n    "source": "iana",\n    "extensions": ["kwd","kwt"]\n  },\n  "application/vnd.kenameaapp": {\n    "source": "iana",\n    "extensions": ["htke"]\n  },\n  "application/vnd.kidspiration": {\n    "source": "iana",\n    "extensions": ["kia"]\n  },\n  "application/vnd.kinar": {\n    "source": "iana",\n    "extensions": ["kne","knp"]\n  },\n  "application/vnd.koan": {\n    "source": "iana",\n    "extensions": ["skp","skd","skt","skm"]\n  },\n  "application/vnd.kodak-descriptor": {\n    "source": "iana",\n    "extensions": ["sse"]\n  },\n  "application/vnd.las": {\n    "source": "iana"\n  },\n  "application/vnd.las.las+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.las.las+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lasxml"]\n  },\n  "application/vnd.laszip": {\n    "source": "iana"\n  },\n  "application/vnd.leap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.liberty-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.llamagraphics.life-balance.desktop": {\n    "source": "iana",\n    "extensions": ["lbd"]\n  },\n  "application/vnd.llamagraphics.life-balance.exchange+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lbe"]\n  },\n  "application/vnd.logipipe.circuit+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.loom": {\n    "source": "iana"\n  },\n  "application/vnd.lotus-1-2-3": {\n    "source": "iana",\n    "extensions": ["123"]\n  },\n  "application/vnd.lotus-approach": {\n    "source": "iana",\n    "extensions": ["apr"]\n  },\n  "application/vnd.lotus-freelance": {\n    "source": "iana",\n    "extensions": ["pre"]\n  },\n  "application/vnd.lotus-notes": {\n    "source": "iana",\n    "extensions": ["nsf"]\n  },\n  "application/vnd.lotus-organizer": {\n    "source": "iana",\n    "extensions": ["org"]\n  },\n  "application/vnd.lotus-screencam": {\n    "source": "iana",\n    "extensions": ["scm"]\n  },\n  "application/vnd.lotus-wordpro": {\n    "source": "iana",\n    "extensions": ["lwp"]\n  },\n  "application/vnd.macports.portpkg": {\n    "source": "iana",\n    "extensions": ["portpkg"]\n  },\n  "application/vnd.mapbox-vector-tile": {\n    "source": "iana"\n  },\n  "application/vnd.marlin.drm.actiontoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.conftoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.license+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.mdcf": {\n    "source": "iana"\n  },\n  "application/vnd.mason+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.maxmind.maxmind-db": {\n    "source": "iana"\n  },\n  "application/vnd.mcd": {\n    "source": "iana",\n    "extensions": ["mcd"]\n  },\n  "application/vnd.medcalcdata": {\n    "source": "iana",\n    "extensions": ["mc1"]\n  },\n  "application/vnd.mediastation.cdkey": {\n    "source": "iana",\n    "extensions": ["cdkey"]\n  },\n  "application/vnd.meridian-slingshot": {\n    "source": "iana"\n  },\n  "application/vnd.mfer": {\n    "source": "iana",\n    "extensions": ["mwf"]\n  },\n  "application/vnd.mfmp": {\n    "source": "iana",\n    "extensions": ["mfm"]\n  },\n  "application/vnd.micro+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.micrografx.flo": {\n    "source": "iana",\n    "extensions": ["flo"]\n  },\n  "application/vnd.micrografx.igx": {\n    "source": "iana",\n    "extensions": ["igx"]\n  },\n  "application/vnd.microsoft.portable-executable": {\n    "source": "iana"\n  },\n  "application/vnd.microsoft.windows.thumbnail-cache": {\n    "source": "iana"\n  },\n  "application/vnd.miele+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.mif": {\n    "source": "iana",\n    "extensions": ["mif"]\n  },\n  "application/vnd.minisoft-hp3000-save": {\n    "source": "iana"\n  },\n  "application/vnd.mitsubishi.misty-guard.trustweb": {\n    "source": "iana"\n  },\n  "application/vnd.mobius.daf": {\n    "source": "iana",\n    "extensions": ["daf"]\n  },\n  "application/vnd.mobius.dis": {\n    "source": "iana",\n    "extensions": ["dis"]\n  },\n  "application/vnd.mobius.mbk": {\n    "source": "iana",\n    "extensions": ["mbk"]\n  },\n  "application/vnd.mobius.mqy": {\n    "source": "iana",\n    "extensions": ["mqy"]\n  },\n  "application/vnd.mobius.msl": {\n    "source": "iana",\n    "extensions": ["msl"]\n  },\n  "application/vnd.mobius.plc": {\n    "source": "iana",\n    "extensions": ["plc"]\n  },\n  "application/vnd.mobius.txf": {\n    "source": "iana",\n    "extensions": ["txf"]\n  },\n  "application/vnd.mophun.application": {\n    "source": "iana",\n    "extensions": ["mpn"]\n  },\n  "application/vnd.mophun.certificate": {\n    "source": "iana",\n    "extensions": ["mpc"]\n  },\n  "application/vnd.motorola.flexsuite": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.adsi": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.fis": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.gotap": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.kmr": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.ttc": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.wem": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.iprm": {\n    "source": "iana"\n  },\n  "application/vnd.mozilla.xul+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xul"]\n  },\n  "application/vnd.ms-3mfdocument": {\n    "source": "iana"\n  },\n  "application/vnd.ms-artgalry": {\n    "source": "iana",\n    "extensions": ["cil"]\n  },\n  "application/vnd.ms-asf": {\n    "source": "iana"\n  },\n  "application/vnd.ms-cab-compressed": {\n    "source": "iana",\n    "extensions": ["cab"]\n  },\n  "application/vnd.ms-color.iccprofile": {\n    "source": "apache"\n  },\n  "application/vnd.ms-excel": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]\n  },\n  "application/vnd.ms-excel.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlam"]\n  },\n  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsb"]\n  },\n  "application/vnd.ms-excel.sheet.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsm"]\n  },\n  "application/vnd.ms-excel.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xltm"]\n  },\n  "application/vnd.ms-fontobject": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eot"]\n  },\n  "application/vnd.ms-htmlhelp": {\n    "source": "iana",\n    "extensions": ["chm"]\n  },\n  "application/vnd.ms-ims": {\n    "source": "iana",\n    "extensions": ["ims"]\n  },\n  "application/vnd.ms-lrm": {\n    "source": "iana",\n    "extensions": ["lrm"]\n  },\n  "application/vnd.ms-office.activex+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-officetheme": {\n    "source": "iana",\n    "extensions": ["thmx"]\n  },\n  "application/vnd.ms-opentype": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-outlook": {\n    "compressible": false,\n    "extensions": ["msg"]\n  },\n  "application/vnd.ms-package.obfuscated-opentype": {\n    "source": "apache"\n  },\n  "application/vnd.ms-pki.seccat": {\n    "source": "apache",\n    "extensions": ["cat"]\n  },\n  "application/vnd.ms-pki.stl": {\n    "source": "apache",\n    "extensions": ["stl"]\n  },\n  "application/vnd.ms-playready.initiator+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-powerpoint": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ppt","pps","pot"]\n  },\n  "application/vnd.ms-powerpoint.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppam"]\n  },\n  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["pptm"]\n  },\n  "application/vnd.ms-powerpoint.slide.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["sldm"]\n  },\n  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppsm"]\n  },\n  "application/vnd.ms-powerpoint.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["potm"]\n  },\n  "application/vnd.ms-printdevicecapabilities+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-printing.printticket+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-printschematicket+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-project": {\n    "source": "iana",\n    "extensions": ["mpp","mpt"]\n  },\n  "application/vnd.ms-tnef": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.nwprinting.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.printerpairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.wsd.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-word.document.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["docm"]\n  },\n  "application/vnd.ms-word.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["dotm"]\n  },\n  "application/vnd.ms-works": {\n    "source": "iana",\n    "extensions": ["wps","wks","wcm","wdb"]\n  },\n  "application/vnd.ms-wpl": {\n    "source": "iana",\n    "extensions": ["wpl"]\n  },\n  "application/vnd.ms-xpsdocument": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xps"]\n  },\n  "application/vnd.msa-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.mseq": {\n    "source": "iana",\n    "extensions": ["mseq"]\n  },\n  "application/vnd.msign": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator.cif": {\n    "source": "iana"\n  },\n  "application/vnd.music-niff": {\n    "source": "iana"\n  },\n  "application/vnd.musician": {\n    "source": "iana",\n    "extensions": ["mus"]\n  },\n  "application/vnd.muvee.style": {\n    "source": "iana",\n    "extensions": ["msty"]\n  },\n  "application/vnd.mynfc": {\n    "source": "iana",\n    "extensions": ["taglet"]\n  },\n  "application/vnd.ncd.control": {\n    "source": "iana"\n  },\n  "application/vnd.ncd.reference": {\n    "source": "iana"\n  },\n  "application/vnd.nearst.inv+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nebumind.line": {\n    "source": "iana"\n  },\n  "application/vnd.nervana": {\n    "source": "iana"\n  },\n  "application/vnd.netfpx": {\n    "source": "iana"\n  },\n  "application/vnd.neurolanguage.nlu": {\n    "source": "iana",\n    "extensions": ["nlu"]\n  },\n  "application/vnd.nimn": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.nitro.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.snes.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nitf": {\n    "source": "iana",\n    "extensions": ["ntf","nitf"]\n  },\n  "application/vnd.noblenet-directory": {\n    "source": "iana",\n    "extensions": ["nnd"]\n  },\n  "application/vnd.noblenet-sealer": {\n    "source": "iana",\n    "extensions": ["nns"]\n  },\n  "application/vnd.noblenet-web": {\n    "source": "iana",\n    "extensions": ["nnw"]\n  },\n  "application/vnd.nokia.catalogs": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.iptv.config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.isds-radio-presets": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.landmarkcollection+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.n-gage.ac+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ac"]\n  },\n  "application/vnd.nokia.n-gage.data": {\n    "source": "iana",\n    "extensions": ["ngdat"]\n  },\n  "application/vnd.nokia.n-gage.symbian.install": {\n    "source": "iana",\n    "extensions": ["n-gage"]\n  },\n  "application/vnd.nokia.ncd": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.radio-preset": {\n    "source": "iana",\n    "extensions": ["rpst"]\n  },\n  "application/vnd.nokia.radio-presets": {\n    "source": "iana",\n    "extensions": ["rpss"]\n  },\n  "application/vnd.novadigm.edm": {\n    "source": "iana",\n    "extensions": ["edm"]\n  },\n  "application/vnd.novadigm.edx": {\n    "source": "iana",\n    "extensions": ["edx"]\n  },\n  "application/vnd.novadigm.ext": {\n    "source": "iana",\n    "extensions": ["ext"]\n  },\n  "application/vnd.ntt-local.content-share": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.file-transfer": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.ogw_remote-access": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_remote": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.oasis.opendocument.chart": {\n    "source": "iana",\n    "extensions": ["odc"]\n  },\n  "application/vnd.oasis.opendocument.chart-template": {\n    "source": "iana",\n    "extensions": ["otc"]\n  },\n  "application/vnd.oasis.opendocument.database": {\n    "source": "iana",\n    "extensions": ["odb"]\n  },\n  "application/vnd.oasis.opendocument.formula": {\n    "source": "iana",\n    "extensions": ["odf"]\n  },\n  "application/vnd.oasis.opendocument.formula-template": {\n    "source": "iana",\n    "extensions": ["odft"]\n  },\n  "application/vnd.oasis.opendocument.graphics": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odg"]\n  },\n  "application/vnd.oasis.opendocument.graphics-template": {\n    "source": "iana",\n    "extensions": ["otg"]\n  },\n  "application/vnd.oasis.opendocument.image": {\n    "source": "iana",\n    "extensions": ["odi"]\n  },\n  "application/vnd.oasis.opendocument.image-template": {\n    "source": "iana",\n    "extensions": ["oti"]\n  },\n  "application/vnd.oasis.opendocument.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odp"]\n  },\n  "application/vnd.oasis.opendocument.presentation-template": {\n    "source": "iana",\n    "extensions": ["otp"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ods"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet-template": {\n    "source": "iana",\n    "extensions": ["ots"]\n  },\n  "application/vnd.oasis.opendocument.text": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odt"]\n  },\n  "application/vnd.oasis.opendocument.text-master": {\n    "source": "iana",\n    "extensions": ["odm"]\n  },\n  "application/vnd.oasis.opendocument.text-template": {\n    "source": "iana",\n    "extensions": ["ott"]\n  },\n  "application/vnd.oasis.opendocument.text-web": {\n    "source": "iana",\n    "extensions": ["oth"]\n  },\n  "application/vnd.obn": {\n    "source": "iana"\n  },\n  "application/vnd.ocf+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oci.image.manifest.v1+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oftn.l10n+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessdownload+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessstreaming+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.cspg-hexbinary": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.dae.svg+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.dae.xhtml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.mippvcontrolmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.pae.gem": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.spdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.spdlist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.ueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.userprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.olpc-sugar": {\n    "source": "iana",\n    "extensions": ["xo"]\n  },\n  "application/vnd.oma-scws-config": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-request": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-response": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.drm-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.imd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.ltkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.notification+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.provisioningtrigger": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgboot": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgdd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sgdu": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.simple-symbol-container": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.smartcard-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sprov+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.stkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.cab-address-book+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-feature-handler+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-pcc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-subs-invite+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-user-prefs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.dcd": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dcdc": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dd2+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dd2"]\n  },\n  "application/vnd.oma.drm.risd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.group-usage-list+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oma.lwm2m+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+tlv": {\n    "source": "iana"\n  },\n  "application/vnd.oma.pal+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.detailed-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.final-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.groups+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.invocation-descriptor+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.optimized-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.push": {\n    "source": "iana"\n  },\n  "application/vnd.oma.scidm.messages+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.xcap-directory+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.omads-email+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-file+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-folder+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omaloc-supl-init": {\n    "source": "iana"\n  },\n  "application/vnd.onepager": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamx": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertat": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatx": {\n    "source": "iana"\n  },\n  "application/vnd.openblox.game+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["obgx"]\n  },\n  "application/vnd.openblox.game-binary": {\n    "source": "iana"\n  },\n  "application/vnd.openeye.oeb": {\n    "source": "iana"\n  },\n  "application/vnd.openofficeorg.extension": {\n    "source": "apache",\n    "extensions": ["oxt"]\n  },\n  "application/vnd.openstreetmap.data+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osm"]\n  },\n  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawing+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pptx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide": {\n    "source": "iana",\n    "extensions": ["sldx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {\n    "source": "iana",\n    "extensions": ["ppsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template": {\n    "source": "iana",\n    "extensions": ["potx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xlsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {\n    "source": "iana",\n    "extensions": ["xltx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.theme+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.vmldrawing": {\n    "source": "iana"\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["docx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {\n    "source": "iana",\n    "extensions": ["dotx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.core-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.relationships+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oracle.resource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.orange.indata": {\n    "source": "iana"\n  },\n  "application/vnd.osa.netdeploy": {\n    "source": "iana"\n  },\n  "application/vnd.osgeo.mapguide.package": {\n    "source": "iana",\n    "extensions": ["mgp"]\n  },\n  "application/vnd.osgi.bundle": {\n    "source": "iana"\n  },\n  "application/vnd.osgi.dp": {\n    "source": "iana",\n    "extensions": ["dp"]\n  },\n  "application/vnd.osgi.subsystem": {\n    "source": "iana",\n    "extensions": ["esa"]\n  },\n  "application/vnd.otps.ct-kip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oxli.countgraph": {\n    "source": "iana"\n  },\n  "application/vnd.pagerduty+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.palm": {\n    "source": "iana",\n    "extensions": ["pdb","pqa","oprc"]\n  },\n  "application/vnd.panoply": {\n    "source": "iana"\n  },\n  "application/vnd.paos.xml": {\n    "source": "iana"\n  },\n  "application/vnd.patentdive": {\n    "source": "iana"\n  },\n  "application/vnd.patientecommsdoc": {\n    "source": "iana"\n  },\n  "application/vnd.pawaafile": {\n    "source": "iana",\n    "extensions": ["paw"]\n  },\n  "application/vnd.pcos": {\n    "source": "iana"\n  },\n  "application/vnd.pg.format": {\n    "source": "iana",\n    "extensions": ["str"]\n  },\n  "application/vnd.pg.osasli": {\n    "source": "iana",\n    "extensions": ["ei6"]\n  },\n  "application/vnd.piaccess.application-licence": {\n    "source": "iana"\n  },\n  "application/vnd.picsel": {\n    "source": "iana",\n    "extensions": ["efif"]\n  },\n  "application/vnd.pmi.widget": {\n    "source": "iana",\n    "extensions": ["wg"]\n  },\n  "application/vnd.poc.group-advertisement+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.pocketlearn": {\n    "source": "iana",\n    "extensions": ["plf"]\n  },\n  "application/vnd.powerbuilder6": {\n    "source": "iana",\n    "extensions": ["pbd"]\n  },\n  "application/vnd.powerbuilder6-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75-s": {\n    "source": "iana"\n  },\n  "application/vnd.preminet": {\n    "source": "iana"\n  },\n  "application/vnd.previewsystems.box": {\n    "source": "iana",\n    "extensions": ["box"]\n  },\n  "application/vnd.proteus.magazine": {\n    "source": "iana",\n    "extensions": ["mgz"]\n  },\n  "application/vnd.psfs": {\n    "source": "iana"\n  },\n  "application/vnd.publishare-delta-tree": {\n    "source": "iana",\n    "extensions": ["qps"]\n  },\n  "application/vnd.pvi.ptid1": {\n    "source": "iana",\n    "extensions": ["ptid"]\n  },\n  "application/vnd.pwg-multiplexed": {\n    "source": "iana"\n  },\n  "application/vnd.pwg-xhtml-print+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.qualcomm.brew-app-res": {\n    "source": "iana"\n  },\n  "application/vnd.quarantainenet": {\n    "source": "iana"\n  },\n  "application/vnd.quark.quarkxpress": {\n    "source": "iana",\n    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]\n  },\n  "application/vnd.quobject-quoxdocument": {\n    "source": "iana"\n  },\n  "application/vnd.radisys.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-stream+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-base+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-detect+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-group+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-speech+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-transform+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rainstor.data": {\n    "source": "iana"\n  },\n  "application/vnd.rapid": {\n    "source": "iana"\n  },\n  "application/vnd.rar": {\n    "source": "iana",\n    "extensions": ["rar"]\n  },\n  "application/vnd.realvnc.bed": {\n    "source": "iana",\n    "extensions": ["bed"]\n  },\n  "application/vnd.recordare.musicxml": {\n    "source": "iana",\n    "extensions": ["mxl"]\n  },\n  "application/vnd.recordare.musicxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musicxml"]\n  },\n  "application/vnd.renlearn.rlprint": {\n    "source": "iana"\n  },\n  "application/vnd.restful+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rig.cryptonote": {\n    "source": "iana",\n    "extensions": ["cryptonote"]\n  },\n  "application/vnd.rim.cod": {\n    "source": "apache",\n    "extensions": ["cod"]\n  },\n  "application/vnd.rn-realmedia": {\n    "source": "apache",\n    "extensions": ["rm"]\n  },\n  "application/vnd.rn-realmedia-vbr": {\n    "source": "apache",\n    "extensions": ["rmvb"]\n  },\n  "application/vnd.route66.link66+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["link66"]\n  },\n  "application/vnd.rs-274x": {\n    "source": "iana"\n  },\n  "application/vnd.ruckus.download": {\n    "source": "iana"\n  },\n  "application/vnd.s3sms": {\n    "source": "iana"\n  },\n  "application/vnd.sailingtracker.track": {\n    "source": "iana",\n    "extensions": ["st"]\n  },\n  "application/vnd.sar": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.cid": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.mid2": {\n    "source": "iana"\n  },\n  "application/vnd.scribus": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.3df": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.csf": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.doc": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.eml": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.mht": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.net": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.ppt": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.tiff": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.xls": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.html": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.pdf": {\n    "source": "iana"\n  },\n  "application/vnd.seemail": {\n    "source": "iana",\n    "extensions": ["see"]\n  },\n  "application/vnd.seis+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.sema": {\n    "source": "iana",\n    "extensions": ["sema"]\n  },\n  "application/vnd.semd": {\n    "source": "iana",\n    "extensions": ["semd"]\n  },\n  "application/vnd.semf": {\n    "source": "iana",\n    "extensions": ["semf"]\n  },\n  "application/vnd.shade-save-file": {\n    "source": "iana"\n  },\n  "application/vnd.shana.informed.formdata": {\n    "source": "iana",\n    "extensions": ["ifm"]\n  },\n  "application/vnd.shana.informed.formtemplate": {\n    "source": "iana",\n    "extensions": ["itp"]\n  },\n  "application/vnd.shana.informed.interchange": {\n    "source": "iana",\n    "extensions": ["iif"]\n  },\n  "application/vnd.shana.informed.package": {\n    "source": "iana",\n    "extensions": ["ipk"]\n  },\n  "application/vnd.shootproof+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shopkick+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shp": {\n    "source": "iana"\n  },\n  "application/vnd.shx": {\n    "source": "iana"\n  },\n  "application/vnd.sigrok.session": {\n    "source": "iana"\n  },\n  "application/vnd.simtech-mindmapper": {\n    "source": "iana",\n    "extensions": ["twd","twds"]\n  },\n  "application/vnd.siren+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.smaf": {\n    "source": "iana",\n    "extensions": ["mmf"]\n  },\n  "application/vnd.smart.notebook": {\n    "source": "iana"\n  },\n  "application/vnd.smart.teacher": {\n    "source": "iana",\n    "extensions": ["teacher"]\n  },\n  "application/vnd.snesdev-page-table": {\n    "source": "iana"\n  },\n  "application/vnd.software602.filler.form+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fo"]\n  },\n  "application/vnd.software602.filler.form-xml-zip": {\n    "source": "iana"\n  },\n  "application/vnd.solent.sdkm+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sdkm","sdkd"]\n  },\n  "application/vnd.spotfire.dxp": {\n    "source": "iana",\n    "extensions": ["dxp"]\n  },\n  "application/vnd.spotfire.sfs": {\n    "source": "iana",\n    "extensions": ["sfs"]\n  },\n  "application/vnd.sqlite3": {\n    "source": "iana"\n  },\n  "application/vnd.sss-cod": {\n    "source": "iana"\n  },\n  "application/vnd.sss-dtf": {\n    "source": "iana"\n  },\n  "application/vnd.sss-ntf": {\n    "source": "iana"\n  },\n  "application/vnd.stardivision.calc": {\n    "source": "apache",\n    "extensions": ["sdc"]\n  },\n  "application/vnd.stardivision.draw": {\n    "source": "apache",\n    "extensions": ["sda"]\n  },\n  "application/vnd.stardivision.impress": {\n    "source": "apache",\n    "extensions": ["sdd"]\n  },\n  "application/vnd.stardivision.math": {\n    "source": "apache",\n    "extensions": ["smf"]\n  },\n  "application/vnd.stardivision.writer": {\n    "source": "apache",\n    "extensions": ["sdw","vor"]\n  },\n  "application/vnd.stardivision.writer-global": {\n    "source": "apache",\n    "extensions": ["sgl"]\n  },\n  "application/vnd.stepmania.package": {\n    "source": "iana",\n    "extensions": ["smzip"]\n  },\n  "application/vnd.stepmania.stepchart": {\n    "source": "iana",\n    "extensions": ["sm"]\n  },\n  "application/vnd.street-stream": {\n    "source": "iana"\n  },\n  "application/vnd.sun.wadl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wadl"]\n  },\n  "application/vnd.sun.xml.calc": {\n    "source": "apache",\n    "extensions": ["sxc"]\n  },\n  "application/vnd.sun.xml.calc.template": {\n    "source": "apache",\n    "extensions": ["stc"]\n  },\n  "application/vnd.sun.xml.draw": {\n    "source": "apache",\n    "extensions": ["sxd"]\n  },\n  "application/vnd.sun.xml.draw.template": {\n    "source": "apache",\n    "extensions": ["std"]\n  },\n  "application/vnd.sun.xml.impress": {\n    "source": "apache",\n    "extensions": ["sxi"]\n  },\n  "application/vnd.sun.xml.impress.template": {\n    "source": "apache",\n    "extensions": ["sti"]\n  },\n  "application/vnd.sun.xml.math": {\n    "source": "apache",\n    "extensions": ["sxm"]\n  },\n  "application/vnd.sun.xml.writer": {\n    "source": "apache",\n    "extensions": ["sxw"]\n  },\n  "application/vnd.sun.xml.writer.global": {\n    "source": "apache",\n    "extensions": ["sxg"]\n  },\n  "application/vnd.sun.xml.writer.template": {\n    "source": "apache",\n    "extensions": ["stw"]\n  },\n  "application/vnd.sus-calendar": {\n    "source": "iana",\n    "extensions": ["sus","susp"]\n  },\n  "application/vnd.svd": {\n    "source": "iana",\n    "extensions": ["svd"]\n  },\n  "application/vnd.swiftview-ics": {\n    "source": "iana"\n  },\n  "application/vnd.sycle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.symbian.install": {\n    "source": "apache",\n    "extensions": ["sis","sisx"]\n  },\n  "application/vnd.syncml+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xsm"]\n  },\n  "application/vnd.syncml.dm+wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["bdm"]\n  },\n  "application/vnd.syncml.dm+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xdm"]\n  },\n  "application/vnd.syncml.dm.notification": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["ddf"]\n  },\n  "application/vnd.syncml.dmtnds+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmtnds+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.syncml.ds.notification": {\n    "source": "iana"\n  },\n  "application/vnd.tableschema+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tao.intent-module-archive": {\n    "source": "iana",\n    "extensions": ["tao"]\n  },\n  "application/vnd.tcpdump.pcap": {\n    "source": "iana",\n    "extensions": ["pcap","cap","dmp"]\n  },\n  "application/vnd.think-cell.ppttc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tmd.mediaflex.api+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tml": {\n    "source": "iana"\n  },\n  "application/vnd.tmobile-livetv": {\n    "source": "iana",\n    "extensions": ["tmo"]\n  },\n  "application/vnd.tri.onesource": {\n    "source": "iana"\n  },\n  "application/vnd.trid.tpt": {\n    "source": "iana",\n    "extensions": ["tpt"]\n  },\n  "application/vnd.triscape.mxs": {\n    "source": "iana",\n    "extensions": ["mxs"]\n  },\n  "application/vnd.trueapp": {\n    "source": "iana",\n    "extensions": ["tra"]\n  },\n  "application/vnd.truedoc": {\n    "source": "iana"\n  },\n  "application/vnd.ubisoft.webplayer": {\n    "source": "iana"\n  },\n  "application/vnd.ufdl": {\n    "source": "iana",\n    "extensions": ["ufd","ufdl"]\n  },\n  "application/vnd.uiq.theme": {\n    "source": "iana",\n    "extensions": ["utz"]\n  },\n  "application/vnd.umajin": {\n    "source": "iana",\n    "extensions": ["umj"]\n  },\n  "application/vnd.unity": {\n    "source": "iana",\n    "extensions": ["unityweb"]\n  },\n  "application/vnd.uoml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uoml"]\n  },\n  "application/vnd.uplanet.alert": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.alert-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.signal": {\n    "source": "iana"\n  },\n  "application/vnd.uri-map": {\n    "source": "iana"\n  },\n  "application/vnd.valve.source.material": {\n    "source": "iana"\n  },\n  "application/vnd.vcx": {\n    "source": "iana",\n    "extensions": ["vcx"]\n  },\n  "application/vnd.vd-study": {\n    "source": "iana"\n  },\n  "application/vnd.vectorworks": {\n    "source": "iana"\n  },\n  "application/vnd.vel+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.verimatrix.vcas": {\n    "source": "iana"\n  },\n  "application/vnd.veryant.thin": {\n    "source": "iana"\n  },\n  "application/vnd.ves.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.vidsoft.vidconference": {\n    "source": "iana"\n  },\n  "application/vnd.visio": {\n    "source": "iana",\n    "extensions": ["vsd","vst","vss","vsw"]\n  },\n  "application/vnd.visionary": {\n    "source": "iana",\n    "extensions": ["vis"]\n  },\n  "application/vnd.vividence.scriptfile": {\n    "source": "iana"\n  },\n  "application/vnd.vsf": {\n    "source": "iana",\n    "extensions": ["vsf"]\n  },\n  "application/vnd.wap.sic": {\n    "source": "iana"\n  },\n  "application/vnd.wap.slc": {\n    "source": "iana"\n  },\n  "application/vnd.wap.wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["wbxml"]\n  },\n  "application/vnd.wap.wmlc": {\n    "source": "iana",\n    "extensions": ["wmlc"]\n  },\n  "application/vnd.wap.wmlscriptc": {\n    "source": "iana",\n    "extensions": ["wmlsc"]\n  },\n  "application/vnd.webturbo": {\n    "source": "iana",\n    "extensions": ["wtb"]\n  },\n  "application/vnd.wfa.dpp": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.p2p": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.wsc": {\n    "source": "iana"\n  },\n  "application/vnd.windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.wmc": {\n    "source": "iana"\n  },\n  "application/vnd.wmf.bootstrap": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica.package": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.player": {\n    "source": "iana",\n    "extensions": ["nbp"]\n  },\n  "application/vnd.wordperfect": {\n    "source": "iana",\n    "extensions": ["wpd"]\n  },\n  "application/vnd.wqd": {\n    "source": "iana",\n    "extensions": ["wqd"]\n  },\n  "application/vnd.wrq-hp3000-labelled": {\n    "source": "iana"\n  },\n  "application/vnd.wt.stf": {\n    "source": "iana",\n    "extensions": ["stf"]\n  },\n  "application/vnd.wv.csp+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.wv.csp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.wv.ssp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xacml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xara": {\n    "source": "iana",\n    "extensions": ["xar"]\n  },\n  "application/vnd.xfdl": {\n    "source": "iana",\n    "extensions": ["xfdl"]\n  },\n  "application/vnd.xfdl.webform": {\n    "source": "iana"\n  },\n  "application/vnd.xmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xmpie.cpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.dpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.plan": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.ppkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.xlim": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.hv-dic": {\n    "source": "iana",\n    "extensions": ["hvd"]\n  },\n  "application/vnd.yamaha.hv-script": {\n    "source": "iana",\n    "extensions": ["hvs"]\n  },\n  "application/vnd.yamaha.hv-voice": {\n    "source": "iana",\n    "extensions": ["hvp"]\n  },\n  "application/vnd.yamaha.openscoreformat": {\n    "source": "iana",\n    "extensions": ["osf"]\n  },\n  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osfpvg"]\n  },\n  "application/vnd.yamaha.remote-setup": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.smaf-audio": {\n    "source": "iana",\n    "extensions": ["saf"]\n  },\n  "application/vnd.yamaha.smaf-phrase": {\n    "source": "iana",\n    "extensions": ["spf"]\n  },\n  "application/vnd.yamaha.through-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.tunnel-udpencap": {\n    "source": "iana"\n  },\n  "application/vnd.yaoweme": {\n    "source": "iana"\n  },\n  "application/vnd.yellowriver-custom-menu": {\n    "source": "iana",\n    "extensions": ["cmp"]\n  },\n  "application/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "application/vnd.zul": {\n    "source": "iana",\n    "extensions": ["zir","zirz"]\n  },\n  "application/vnd.zzazz.deck+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zaz"]\n  },\n  "application/voicexml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vxml"]\n  },\n  "application/voucher-cms+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vq-rtcpxr": {\n    "source": "iana"\n  },\n  "application/wasm": {\n    "compressible": true,\n    "extensions": ["wasm"]\n  },\n  "application/watcherinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/webpush-options+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/whoispp-query": {\n    "source": "iana"\n  },\n  "application/whoispp-response": {\n    "source": "iana"\n  },\n  "application/widget": {\n    "source": "iana",\n    "extensions": ["wgt"]\n  },\n  "application/winhlp": {\n    "source": "apache",\n    "extensions": ["hlp"]\n  },\n  "application/wita": {\n    "source": "iana"\n  },\n  "application/wordperfect5.1": {\n    "source": "iana"\n  },\n  "application/wsdl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wsdl"]\n  },\n  "application/wspolicy+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wspolicy"]\n  },\n  "application/x-7z-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["7z"]\n  },\n  "application/x-abiword": {\n    "source": "apache",\n    "extensions": ["abw"]\n  },\n  "application/x-ace-compressed": {\n    "source": "apache",\n    "extensions": ["ace"]\n  },\n  "application/x-amf": {\n    "source": "apache"\n  },\n  "application/x-apple-diskimage": {\n    "source": "apache",\n    "extensions": ["dmg"]\n  },\n  "application/x-arj": {\n    "compressible": false,\n    "extensions": ["arj"]\n  },\n  "application/x-authorware-bin": {\n    "source": "apache",\n    "extensions": ["aab","x32","u32","vox"]\n  },\n  "application/x-authorware-map": {\n    "source": "apache",\n    "extensions": ["aam"]\n  },\n  "application/x-authorware-seg": {\n    "source": "apache",\n    "extensions": ["aas"]\n  },\n  "application/x-bcpio": {\n    "source": "apache",\n    "extensions": ["bcpio"]\n  },\n  "application/x-bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/x-bittorrent": {\n    "source": "apache",\n    "extensions": ["torrent"]\n  },\n  "application/x-blorb": {\n    "source": "apache",\n    "extensions": ["blb","blorb"]\n  },\n  "application/x-bzip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz"]\n  },\n  "application/x-bzip2": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz2","boz"]\n  },\n  "application/x-cbr": {\n    "source": "apache",\n    "extensions": ["cbr","cba","cbt","cbz","cb7"]\n  },\n  "application/x-cdlink": {\n    "source": "apache",\n    "extensions": ["vcd"]\n  },\n  "application/x-cfs-compressed": {\n    "source": "apache",\n    "extensions": ["cfs"]\n  },\n  "application/x-chat": {\n    "source": "apache",\n    "extensions": ["chat"]\n  },\n  "application/x-chess-pgn": {\n    "source": "apache",\n    "extensions": ["pgn"]\n  },\n  "application/x-chrome-extension": {\n    "extensions": ["crx"]\n  },\n  "application/x-cocoa": {\n    "source": "nginx",\n    "extensions": ["cco"]\n  },\n  "application/x-compress": {\n    "source": "apache"\n  },\n  "application/x-conference": {\n    "source": "apache",\n    "extensions": ["nsc"]\n  },\n  "application/x-cpio": {\n    "source": "apache",\n    "extensions": ["cpio"]\n  },\n  "application/x-csh": {\n    "source": "apache",\n    "extensions": ["csh"]\n  },\n  "application/x-deb": {\n    "compressible": false\n  },\n  "application/x-debian-package": {\n    "source": "apache",\n    "extensions": ["deb","udeb"]\n  },\n  "application/x-dgc-compressed": {\n    "source": "apache",\n    "extensions": ["dgc"]\n  },\n  "application/x-director": {\n    "source": "apache",\n    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]\n  },\n  "application/x-doom": {\n    "source": "apache",\n    "extensions": ["wad"]\n  },\n  "application/x-dtbncx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ncx"]\n  },\n  "application/x-dtbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dtb"]\n  },\n  "application/x-dtbresource+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["res"]\n  },\n  "application/x-dvi": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["dvi"]\n  },\n  "application/x-envoy": {\n    "source": "apache",\n    "extensions": ["evy"]\n  },\n  "application/x-eva": {\n    "source": "apache",\n    "extensions": ["eva"]\n  },\n  "application/x-font-bdf": {\n    "source": "apache",\n    "extensions": ["bdf"]\n  },\n  "application/x-font-dos": {\n    "source": "apache"\n  },\n  "application/x-font-framemaker": {\n    "source": "apache"\n  },\n  "application/x-font-ghostscript": {\n    "source": "apache",\n    "extensions": ["gsf"]\n  },\n  "application/x-font-libgrx": {\n    "source": "apache"\n  },\n  "application/x-font-linux-psf": {\n    "source": "apache",\n    "extensions": ["psf"]\n  },\n  "application/x-font-pcf": {\n    "source": "apache",\n    "extensions": ["pcf"]\n  },\n  "application/x-font-snf": {\n    "source": "apache",\n    "extensions": ["snf"]\n  },\n  "application/x-font-speedo": {\n    "source": "apache"\n  },\n  "application/x-font-sunos-news": {\n    "source": "apache"\n  },\n  "application/x-font-type1": {\n    "source": "apache",\n    "extensions": ["pfa","pfb","pfm","afm"]\n  },\n  "application/x-font-vfont": {\n    "source": "apache"\n  },\n  "application/x-freearc": {\n    "source": "apache",\n    "extensions": ["arc"]\n  },\n  "application/x-futuresplash": {\n    "source": "apache",\n    "extensions": ["spl"]\n  },\n  "application/x-gca-compressed": {\n    "source": "apache",\n    "extensions": ["gca"]\n  },\n  "application/x-glulx": {\n    "source": "apache",\n    "extensions": ["ulx"]\n  },\n  "application/x-gnumeric": {\n    "source": "apache",\n    "extensions": ["gnumeric"]\n  },\n  "application/x-gramps-xml": {\n    "source": "apache",\n    "extensions": ["gramps"]\n  },\n  "application/x-gtar": {\n    "source": "apache",\n    "extensions": ["gtar"]\n  },\n  "application/x-gzip": {\n    "source": "apache"\n  },\n  "application/x-hdf": {\n    "source": "apache",\n    "extensions": ["hdf"]\n  },\n  "application/x-httpd-php": {\n    "compressible": true,\n    "extensions": ["php"]\n  },\n  "application/x-install-instructions": {\n    "source": "apache",\n    "extensions": ["install"]\n  },\n  "application/x-iso9660-image": {\n    "source": "apache",\n    "extensions": ["iso"]\n  },\n  "application/x-java-archive-diff": {\n    "source": "nginx",\n    "extensions": ["jardiff"]\n  },\n  "application/x-java-jnlp-file": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jnlp"]\n  },\n  "application/x-javascript": {\n    "compressible": true\n  },\n  "application/x-keepass2": {\n    "extensions": ["kdbx"]\n  },\n  "application/x-latex": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["latex"]\n  },\n  "application/x-lua-bytecode": {\n    "extensions": ["luac"]\n  },\n  "application/x-lzh-compressed": {\n    "source": "apache",\n    "extensions": ["lzh","lha"]\n  },\n  "application/x-makeself": {\n    "source": "nginx",\n    "extensions": ["run"]\n  },\n  "application/x-mie": {\n    "source": "apache",\n    "extensions": ["mie"]\n  },\n  "application/x-mobipocket-ebook": {\n    "source": "apache",\n    "extensions": ["prc","mobi"]\n  },\n  "application/x-mpegurl": {\n    "compressible": false\n  },\n  "application/x-ms-application": {\n    "source": "apache",\n    "extensions": ["application"]\n  },\n  "application/x-ms-shortcut": {\n    "source": "apache",\n    "extensions": ["lnk"]\n  },\n  "application/x-ms-wmd": {\n    "source": "apache",\n    "extensions": ["wmd"]\n  },\n  "application/x-ms-wmz": {\n    "source": "apache",\n    "extensions": ["wmz"]\n  },\n  "application/x-ms-xbap": {\n    "source": "apache",\n    "extensions": ["xbap"]\n  },\n  "application/x-msaccess": {\n    "source": "apache",\n    "extensions": ["mdb"]\n  },\n  "application/x-msbinder": {\n    "source": "apache",\n    "extensions": ["obd"]\n  },\n  "application/x-mscardfile": {\n    "source": "apache",\n    "extensions": ["crd"]\n  },\n  "application/x-msclip": {\n    "source": "apache",\n    "extensions": ["clp"]\n  },\n  "application/x-msdos-program": {\n    "extensions": ["exe"]\n  },\n  "application/x-msdownload": {\n    "source": "apache",\n    "extensions": ["exe","dll","com","bat","msi"]\n  },\n  "application/x-msmediaview": {\n    "source": "apache",\n    "extensions": ["mvb","m13","m14"]\n  },\n  "application/x-msmetafile": {\n    "source": "apache",\n    "extensions": ["wmf","wmz","emf","emz"]\n  },\n  "application/x-msmoney": {\n    "source": "apache",\n    "extensions": ["mny"]\n  },\n  "application/x-mspublisher": {\n    "source": "apache",\n    "extensions": ["pub"]\n  },\n  "application/x-msschedule": {\n    "source": "apache",\n    "extensions": ["scd"]\n  },\n  "application/x-msterminal": {\n    "source": "apache",\n    "extensions": ["trm"]\n  },\n  "application/x-mswrite": {\n    "source": "apache",\n    "extensions": ["wri"]\n  },\n  "application/x-netcdf": {\n    "source": "apache",\n    "extensions": ["nc","cdf"]\n  },\n  "application/x-ns-proxy-autoconfig": {\n    "compressible": true,\n    "extensions": ["pac"]\n  },\n  "application/x-nzb": {\n    "source": "apache",\n    "extensions": ["nzb"]\n  },\n  "application/x-perl": {\n    "source": "nginx",\n    "extensions": ["pl","pm"]\n  },\n  "application/x-pilot": {\n    "source": "nginx",\n    "extensions": ["prc","pdb"]\n  },\n  "application/x-pkcs12": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["p12","pfx"]\n  },\n  "application/x-pkcs7-certificates": {\n    "source": "apache",\n    "extensions": ["p7b","spc"]\n  },\n  "application/x-pkcs7-certreqresp": {\n    "source": "apache",\n    "extensions": ["p7r"]\n  },\n  "application/x-pki-message": {\n    "source": "iana"\n  },\n  "application/x-rar-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["rar"]\n  },\n  "application/x-redhat-package-manager": {\n    "source": "nginx",\n    "extensions": ["rpm"]\n  },\n  "application/x-research-info-systems": {\n    "source": "apache",\n    "extensions": ["ris"]\n  },\n  "application/x-sea": {\n    "source": "nginx",\n    "extensions": ["sea"]\n  },\n  "application/x-sh": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["sh"]\n  },\n  "application/x-shar": {\n    "source": "apache",\n    "extensions": ["shar"]\n  },\n  "application/x-shockwave-flash": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["swf"]\n  },\n  "application/x-silverlight-app": {\n    "source": "apache",\n    "extensions": ["xap"]\n  },\n  "application/x-sql": {\n    "source": "apache",\n    "extensions": ["sql"]\n  },\n  "application/x-stuffit": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["sit"]\n  },\n  "application/x-stuffitx": {\n    "source": "apache",\n    "extensions": ["sitx"]\n  },\n  "application/x-subrip": {\n    "source": "apache",\n    "extensions": ["srt"]\n  },\n  "application/x-sv4cpio": {\n    "source": "apache",\n    "extensions": ["sv4cpio"]\n  },\n  "application/x-sv4crc": {\n    "source": "apache",\n    "extensions": ["sv4crc"]\n  },\n  "application/x-t3vm-image": {\n    "source": "apache",\n    "extensions": ["t3"]\n  },\n  "application/x-tads": {\n    "source": "apache",\n    "extensions": ["gam"]\n  },\n  "application/x-tar": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["tar"]\n  },\n  "application/x-tcl": {\n    "source": "apache",\n    "extensions": ["tcl","tk"]\n  },\n  "application/x-tex": {\n    "source": "apache",\n    "extensions": ["tex"]\n  },\n  "application/x-tex-tfm": {\n    "source": "apache",\n    "extensions": ["tfm"]\n  },\n  "application/x-texinfo": {\n    "source": "apache",\n    "extensions": ["texinfo","texi"]\n  },\n  "application/x-tgif": {\n    "source": "apache",\n    "extensions": ["obj"]\n  },\n  "application/x-ustar": {\n    "source": "apache",\n    "extensions": ["ustar"]\n  },\n  "application/x-virtualbox-hdd": {\n    "compressible": true,\n    "extensions": ["hdd"]\n  },\n  "application/x-virtualbox-ova": {\n    "compressible": true,\n    "extensions": ["ova"]\n  },\n  "application/x-virtualbox-ovf": {\n    "compressible": true,\n    "extensions": ["ovf"]\n  },\n  "application/x-virtualbox-vbox": {\n    "compressible": true,\n    "extensions": ["vbox"]\n  },\n  "application/x-virtualbox-vbox-extpack": {\n    "compressible": false,\n    "extensions": ["vbox-extpack"]\n  },\n  "application/x-virtualbox-vdi": {\n    "compressible": true,\n    "extensions": ["vdi"]\n  },\n  "application/x-virtualbox-vhd": {\n    "compressible": true,\n    "extensions": ["vhd"]\n  },\n  "application/x-virtualbox-vmdk": {\n    "compressible": true,\n    "extensions": ["vmdk"]\n  },\n  "application/x-wais-source": {\n    "source": "apache",\n    "extensions": ["src"]\n  },\n  "application/x-web-app-manifest+json": {\n    "compressible": true,\n    "extensions": ["webapp"]\n  },\n  "application/x-www-form-urlencoded": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/x-x509-ca-cert": {\n    "source": "iana",\n    "extensions": ["der","crt","pem"]\n  },\n  "application/x-x509-ca-ra-cert": {\n    "source": "iana"\n  },\n  "application/x-x509-next-ca-cert": {\n    "source": "iana"\n  },\n  "application/x-xfig": {\n    "source": "apache",\n    "extensions": ["fig"]\n  },\n  "application/x-xliff+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/x-xpinstall": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["xpi"]\n  },\n  "application/x-xz": {\n    "source": "apache",\n    "extensions": ["xz"]\n  },\n  "application/x-zmachine": {\n    "source": "apache",\n    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]\n  },\n  "application/x400-bp": {\n    "source": "iana"\n  },\n  "application/xacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xaml+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xaml"]\n  },\n  "application/xcap-att+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xav"]\n  },\n  "application/xcap-caps+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xca"]\n  },\n  "application/xcap-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/xcap-el+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xel"]\n  },\n  "application/xcap-error+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcap-ns+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xns"]\n  },\n  "application/xcon-conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcon-conference-info-diff+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xenc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xenc"]\n  },\n  "application/xhtml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xhtml","xht"]\n  },\n  "application/xhtml-voice+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/xliff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml","xsl","xsd","rng"]\n  },\n  "application/xml-dtd": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dtd"]\n  },\n  "application/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "application/xml-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xmpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xop+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xop"]\n  },\n  "application/xproc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xpl"]\n  },\n  "application/xslt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xsl","xslt"]\n  },\n  "application/xspf+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xspf"]\n  },\n  "application/xv+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mxml","xhvml","xvml","xvm"]\n  },\n  "application/yang": {\n    "source": "iana",\n    "extensions": ["yang"]\n  },\n  "application/yang-data+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yin+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["yin"]\n  },\n  "application/zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["zip"]\n  },\n  "application/zlib": {\n    "source": "iana"\n  },\n  "application/zstd": {\n    "source": "iana"\n  },\n  "audio/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "audio/32kadpcm": {\n    "source": "iana"\n  },\n  "audio/3gpp": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["3gpp"]\n  },\n  "audio/3gpp2": {\n    "source": "iana"\n  },\n  "audio/aac": {\n    "source": "iana"\n  },\n  "audio/ac3": {\n    "source": "iana"\n  },\n  "audio/adpcm": {\n    "source": "apache",\n    "extensions": ["adp"]\n  },\n  "audio/amr": {\n    "source": "iana",\n    "extensions": ["amr"]\n  },\n  "audio/amr-wb": {\n    "source": "iana"\n  },\n  "audio/amr-wb+": {\n    "source": "iana"\n  },\n  "audio/aptx": {\n    "source": "iana"\n  },\n  "audio/asc": {\n    "source": "iana"\n  },\n  "audio/atrac-advanced-lossless": {\n    "source": "iana"\n  },\n  "audio/atrac-x": {\n    "source": "iana"\n  },\n  "audio/atrac3": {\n    "source": "iana"\n  },\n  "audio/basic": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["au","snd"]\n  },\n  "audio/bv16": {\n    "source": "iana"\n  },\n  "audio/bv32": {\n    "source": "iana"\n  },\n  "audio/clearmode": {\n    "source": "iana"\n  },\n  "audio/cn": {\n    "source": "iana"\n  },\n  "audio/dat12": {\n    "source": "iana"\n  },\n  "audio/dls": {\n    "source": "iana"\n  },\n  "audio/dsr-es201108": {\n    "source": "iana"\n  },\n  "audio/dsr-es202050": {\n    "source": "iana"\n  },\n  "audio/dsr-es202211": {\n    "source": "iana"\n  },\n  "audio/dsr-es202212": {\n    "source": "iana"\n  },\n  "audio/dv": {\n    "source": "iana"\n  },\n  "audio/dvi4": {\n    "source": "iana"\n  },\n  "audio/eac3": {\n    "source": "iana"\n  },\n  "audio/encaprtp": {\n    "source": "iana"\n  },\n  "audio/evrc": {\n    "source": "iana"\n  },\n  "audio/evrc-qcp": {\n    "source": "iana"\n  },\n  "audio/evrc0": {\n    "source": "iana"\n  },\n  "audio/evrc1": {\n    "source": "iana"\n  },\n  "audio/evrcb": {\n    "source": "iana"\n  },\n  "audio/evrcb0": {\n    "source": "iana"\n  },\n  "audio/evrcb1": {\n    "source": "iana"\n  },\n  "audio/evrcnw": {\n    "source": "iana"\n  },\n  "audio/evrcnw0": {\n    "source": "iana"\n  },\n  "audio/evrcnw1": {\n    "source": "iana"\n  },\n  "audio/evrcwb": {\n    "source": "iana"\n  },\n  "audio/evrcwb0": {\n    "source": "iana"\n  },\n  "audio/evrcwb1": {\n    "source": "iana"\n  },\n  "audio/evs": {\n    "source": "iana"\n  },\n  "audio/flexfec": {\n    "source": "iana"\n  },\n  "audio/fwdred": {\n    "source": "iana"\n  },\n  "audio/g711-0": {\n    "source": "iana"\n  },\n  "audio/g719": {\n    "source": "iana"\n  },\n  "audio/g722": {\n    "source": "iana"\n  },\n  "audio/g7221": {\n    "source": "iana"\n  },\n  "audio/g723": {\n    "source": "iana"\n  },\n  "audio/g726-16": {\n    "source": "iana"\n  },\n  "audio/g726-24": {\n    "source": "iana"\n  },\n  "audio/g726-32": {\n    "source": "iana"\n  },\n  "audio/g726-40": {\n    "source": "iana"\n  },\n  "audio/g728": {\n    "source": "iana"\n  },\n  "audio/g729": {\n    "source": "iana"\n  },\n  "audio/g7291": {\n    "source": "iana"\n  },\n  "audio/g729d": {\n    "source": "iana"\n  },\n  "audio/g729e": {\n    "source": "iana"\n  },\n  "audio/gsm": {\n    "source": "iana"\n  },\n  "audio/gsm-efr": {\n    "source": "iana"\n  },\n  "audio/gsm-hr-08": {\n    "source": "iana"\n  },\n  "audio/ilbc": {\n    "source": "iana"\n  },\n  "audio/ip-mr_v2.5": {\n    "source": "iana"\n  },\n  "audio/isac": {\n    "source": "apache"\n  },\n  "audio/l16": {\n    "source": "iana"\n  },\n  "audio/l20": {\n    "source": "iana"\n  },\n  "audio/l24": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/l8": {\n    "source": "iana"\n  },\n  "audio/lpc": {\n    "source": "iana"\n  },\n  "audio/melp": {\n    "source": "iana"\n  },\n  "audio/melp1200": {\n    "source": "iana"\n  },\n  "audio/melp2400": {\n    "source": "iana"\n  },\n  "audio/melp600": {\n    "source": "iana"\n  },\n  "audio/mhas": {\n    "source": "iana"\n  },\n  "audio/midi": {\n    "source": "apache",\n    "extensions": ["mid","midi","kar","rmi"]\n  },\n  "audio/mobile-xmf": {\n    "source": "iana",\n    "extensions": ["mxmf"]\n  },\n  "audio/mp3": {\n    "compressible": false,\n    "extensions": ["mp3"]\n  },\n  "audio/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["m4a","mp4a"]\n  },\n  "audio/mp4a-latm": {\n    "source": "iana"\n  },\n  "audio/mpa": {\n    "source": "iana"\n  },\n  "audio/mpa-robust": {\n    "source": "iana"\n  },\n  "audio/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]\n  },\n  "audio/mpeg4-generic": {\n    "source": "iana"\n  },\n  "audio/musepack": {\n    "source": "apache"\n  },\n  "audio/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["oga","ogg","spx","opus"]\n  },\n  "audio/opus": {\n    "source": "iana"\n  },\n  "audio/parityfec": {\n    "source": "iana"\n  },\n  "audio/pcma": {\n    "source": "iana"\n  },\n  "audio/pcma-wb": {\n    "source": "iana"\n  },\n  "audio/pcmu": {\n    "source": "iana"\n  },\n  "audio/pcmu-wb": {\n    "source": "iana"\n  },\n  "audio/prs.sid": {\n    "source": "iana"\n  },\n  "audio/qcelp": {\n    "source": "iana"\n  },\n  "audio/raptorfec": {\n    "source": "iana"\n  },\n  "audio/red": {\n    "source": "iana"\n  },\n  "audio/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "audio/rtp-midi": {\n    "source": "iana"\n  },\n  "audio/rtploopback": {\n    "source": "iana"\n  },\n  "audio/rtx": {\n    "source": "iana"\n  },\n  "audio/s3m": {\n    "source": "apache",\n    "extensions": ["s3m"]\n  },\n  "audio/scip": {\n    "source": "iana"\n  },\n  "audio/silk": {\n    "source": "apache",\n    "extensions": ["sil"]\n  },\n  "audio/smv": {\n    "source": "iana"\n  },\n  "audio/smv-qcp": {\n    "source": "iana"\n  },\n  "audio/smv0": {\n    "source": "iana"\n  },\n  "audio/sofa": {\n    "source": "iana"\n  },\n  "audio/sp-midi": {\n    "source": "iana"\n  },\n  "audio/speex": {\n    "source": "iana"\n  },\n  "audio/t140c": {\n    "source": "iana"\n  },\n  "audio/t38": {\n    "source": "iana"\n  },\n  "audio/telephone-event": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp_bb": {\n    "source": "iana"\n  },\n  "audio/tone": {\n    "source": "iana"\n  },\n  "audio/tsvcis": {\n    "source": "iana"\n  },\n  "audio/uemclip": {\n    "source": "iana"\n  },\n  "audio/ulpfec": {\n    "source": "iana"\n  },\n  "audio/usac": {\n    "source": "iana"\n  },\n  "audio/vdvi": {\n    "source": "iana"\n  },\n  "audio/vmr-wb": {\n    "source": "iana"\n  },\n  "audio/vnd.3gpp.iufp": {\n    "source": "iana"\n  },\n  "audio/vnd.4sb": {\n    "source": "iana"\n  },\n  "audio/vnd.audiokoz": {\n    "source": "iana"\n  },\n  "audio/vnd.celp": {\n    "source": "iana"\n  },\n  "audio/vnd.cisco.nse": {\n    "source": "iana"\n  },\n  "audio/vnd.cmles.radio-events": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.anp1": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.inf1": {\n    "source": "iana"\n  },\n  "audio/vnd.dece.audio": {\n    "source": "iana",\n    "extensions": ["uva","uvva"]\n  },\n  "audio/vnd.digital-winds": {\n    "source": "iana",\n    "extensions": ["eol"]\n  },\n  "audio/vnd.dlna.adts": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mlp": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mps": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2x": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2z": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pulse.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dra": {\n    "source": "iana",\n    "extensions": ["dra"]\n  },\n  "audio/vnd.dts": {\n    "source": "iana",\n    "extensions": ["dts"]\n  },\n  "audio/vnd.dts.hd": {\n    "source": "iana",\n    "extensions": ["dtshd"]\n  },\n  "audio/vnd.dts.uhd": {\n    "source": "iana"\n  },\n  "audio/vnd.dvb.file": {\n    "source": "iana"\n  },\n  "audio/vnd.everad.plj": {\n    "source": "iana"\n  },\n  "audio/vnd.hns.audio": {\n    "source": "iana"\n  },\n  "audio/vnd.lucent.voice": {\n    "source": "iana",\n    "extensions": ["lvp"]\n  },\n  "audio/vnd.ms-playready.media.pya": {\n    "source": "iana",\n    "extensions": ["pya"]\n  },\n  "audio/vnd.nokia.mobile-xmf": {\n    "source": "iana"\n  },\n  "audio/vnd.nortel.vbk": {\n    "source": "iana"\n  },\n  "audio/vnd.nuera.ecelp4800": {\n    "source": "iana",\n    "extensions": ["ecelp4800"]\n  },\n  "audio/vnd.nuera.ecelp7470": {\n    "source": "iana",\n    "extensions": ["ecelp7470"]\n  },\n  "audio/vnd.nuera.ecelp9600": {\n    "source": "iana",\n    "extensions": ["ecelp9600"]\n  },\n  "audio/vnd.octel.sbc": {\n    "source": "iana"\n  },\n  "audio/vnd.presonus.multitrack": {\n    "source": "iana"\n  },\n  "audio/vnd.qcelp": {\n    "source": "iana"\n  },\n  "audio/vnd.rhetorex.32kadpcm": {\n    "source": "iana"\n  },\n  "audio/vnd.rip": {\n    "source": "iana",\n    "extensions": ["rip"]\n  },\n  "audio/vnd.rn-realaudio": {\n    "compressible": false\n  },\n  "audio/vnd.sealedmedia.softseal.mpeg": {\n    "source": "iana"\n  },\n  "audio/vnd.vmx.cvsd": {\n    "source": "iana"\n  },\n  "audio/vnd.wave": {\n    "compressible": false\n  },\n  "audio/vorbis": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/vorbis-config": {\n    "source": "iana"\n  },\n  "audio/wav": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/wave": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["weba"]\n  },\n  "audio/x-aac": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["aac"]\n  },\n  "audio/x-aiff": {\n    "source": "apache",\n    "extensions": ["aif","aiff","aifc"]\n  },\n  "audio/x-caf": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["caf"]\n  },\n  "audio/x-flac": {\n    "source": "apache",\n    "extensions": ["flac"]\n  },\n  "audio/x-m4a": {\n    "source": "nginx",\n    "extensions": ["m4a"]\n  },\n  "audio/x-matroska": {\n    "source": "apache",\n    "extensions": ["mka"]\n  },\n  "audio/x-mpegurl": {\n    "source": "apache",\n    "extensions": ["m3u"]\n  },\n  "audio/x-ms-wax": {\n    "source": "apache",\n    "extensions": ["wax"]\n  },\n  "audio/x-ms-wma": {\n    "source": "apache",\n    "extensions": ["wma"]\n  },\n  "audio/x-pn-realaudio": {\n    "source": "apache",\n    "extensions": ["ram","ra"]\n  },\n  "audio/x-pn-realaudio-plugin": {\n    "source": "apache",\n    "extensions": ["rmp"]\n  },\n  "audio/x-realaudio": {\n    "source": "nginx",\n    "extensions": ["ra"]\n  },\n  "audio/x-tta": {\n    "source": "apache"\n  },\n  "audio/x-wav": {\n    "source": "apache",\n    "extensions": ["wav"]\n  },\n  "audio/xm": {\n    "source": "apache",\n    "extensions": ["xm"]\n  },\n  "chemical/x-cdx": {\n    "source": "apache",\n    "extensions": ["cdx"]\n  },\n  "chemical/x-cif": {\n    "source": "apache",\n    "extensions": ["cif"]\n  },\n  "chemical/x-cmdf": {\n    "source": "apache",\n    "extensions": ["cmdf"]\n  },\n  "chemical/x-cml": {\n    "source": "apache",\n    "extensions": ["cml"]\n  },\n  "chemical/x-csml": {\n    "source": "apache",\n    "extensions": ["csml"]\n  },\n  "chemical/x-pdb": {\n    "source": "apache"\n  },\n  "chemical/x-xyz": {\n    "source": "apache",\n    "extensions": ["xyz"]\n  },\n  "font/collection": {\n    "source": "iana",\n    "extensions": ["ttc"]\n  },\n  "font/otf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["otf"]\n  },\n  "font/sfnt": {\n    "source": "iana"\n  },\n  "font/ttf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttf"]\n  },\n  "font/woff": {\n    "source": "iana",\n    "extensions": ["woff"]\n  },\n  "font/woff2": {\n    "source": "iana",\n    "extensions": ["woff2"]\n  },\n  "image/aces": {\n    "source": "iana",\n    "extensions": ["exr"]\n  },\n  "image/apng": {\n    "compressible": false,\n    "extensions": ["apng"]\n  },\n  "image/avci": {\n    "source": "iana"\n  },\n  "image/avcs": {\n    "source": "iana"\n  },\n  "image/avif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["avif"]\n  },\n  "image/bmp": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/cgm": {\n    "source": "iana",\n    "extensions": ["cgm"]\n  },\n  "image/dicom-rle": {\n    "source": "iana",\n    "extensions": ["drle"]\n  },\n  "image/emf": {\n    "source": "iana",\n    "extensions": ["emf"]\n  },\n  "image/fits": {\n    "source": "iana",\n    "extensions": ["fits"]\n  },\n  "image/g3fax": {\n    "source": "iana",\n    "extensions": ["g3"]\n  },\n  "image/gif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gif"]\n  },\n  "image/heic": {\n    "source": "iana",\n    "extensions": ["heic"]\n  },\n  "image/heic-sequence": {\n    "source": "iana",\n    "extensions": ["heics"]\n  },\n  "image/heif": {\n    "source": "iana",\n    "extensions": ["heif"]\n  },\n  "image/heif-sequence": {\n    "source": "iana",\n    "extensions": ["heifs"]\n  },\n  "image/hej2k": {\n    "source": "iana",\n    "extensions": ["hej2"]\n  },\n  "image/hsj2": {\n    "source": "iana",\n    "extensions": ["hsj2"]\n  },\n  "image/ief": {\n    "source": "iana",\n    "extensions": ["ief"]\n  },\n  "image/jls": {\n    "source": "iana",\n    "extensions": ["jls"]\n  },\n  "image/jp2": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jp2","jpg2"]\n  },\n  "image/jpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpeg","jpg","jpe"]\n  },\n  "image/jph": {\n    "source": "iana",\n    "extensions": ["jph"]\n  },\n  "image/jphc": {\n    "source": "iana",\n    "extensions": ["jhc"]\n  },\n  "image/jpm": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpm"]\n  },\n  "image/jpx": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpx","jpf"]\n  },\n  "image/jxr": {\n    "source": "iana",\n    "extensions": ["jxr"]\n  },\n  "image/jxra": {\n    "source": "iana",\n    "extensions": ["jxra"]\n  },\n  "image/jxrs": {\n    "source": "iana",\n    "extensions": ["jxrs"]\n  },\n  "image/jxs": {\n    "source": "iana",\n    "extensions": ["jxs"]\n  },\n  "image/jxsc": {\n    "source": "iana",\n    "extensions": ["jxsc"]\n  },\n  "image/jxsi": {\n    "source": "iana",\n    "extensions": ["jxsi"]\n  },\n  "image/jxss": {\n    "source": "iana",\n    "extensions": ["jxss"]\n  },\n  "image/ktx": {\n    "source": "iana",\n    "extensions": ["ktx"]\n  },\n  "image/ktx2": {\n    "source": "iana",\n    "extensions": ["ktx2"]\n  },\n  "image/naplps": {\n    "source": "iana"\n  },\n  "image/pjpeg": {\n    "compressible": false\n  },\n  "image/png": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["png"]\n  },\n  "image/prs.btif": {\n    "source": "iana",\n    "extensions": ["btif"]\n  },\n  "image/prs.pti": {\n    "source": "iana",\n    "extensions": ["pti"]\n  },\n  "image/pwg-raster": {\n    "source": "iana"\n  },\n  "image/sgi": {\n    "source": "apache",\n    "extensions": ["sgi"]\n  },\n  "image/svg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["svg","svgz"]\n  },\n  "image/t38": {\n    "source": "iana",\n    "extensions": ["t38"]\n  },\n  "image/tiff": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["tif","tiff"]\n  },\n  "image/tiff-fx": {\n    "source": "iana",\n    "extensions": ["tfx"]\n  },\n  "image/vnd.adobe.photoshop": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["psd"]\n  },\n  "image/vnd.airzip.accelerator.azv": {\n    "source": "iana",\n    "extensions": ["azv"]\n  },\n  "image/vnd.cns.inf2": {\n    "source": "iana"\n  },\n  "image/vnd.dece.graphic": {\n    "source": "iana",\n    "extensions": ["uvi","uvvi","uvg","uvvg"]\n  },\n  "image/vnd.djvu": {\n    "source": "iana",\n    "extensions": ["djvu","djv"]\n  },\n  "image/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "image/vnd.dwg": {\n    "source": "iana",\n    "extensions": ["dwg"]\n  },\n  "image/vnd.dxf": {\n    "source": "iana",\n    "extensions": ["dxf"]\n  },\n  "image/vnd.fastbidsheet": {\n    "source": "iana",\n    "extensions": ["fbs"]\n  },\n  "image/vnd.fpx": {\n    "source": "iana",\n    "extensions": ["fpx"]\n  },\n  "image/vnd.fst": {\n    "source": "iana",\n    "extensions": ["fst"]\n  },\n  "image/vnd.fujixerox.edmics-mmr": {\n    "source": "iana",\n    "extensions": ["mmr"]\n  },\n  "image/vnd.fujixerox.edmics-rlc": {\n    "source": "iana",\n    "extensions": ["rlc"]\n  },\n  "image/vnd.globalgraphics.pgb": {\n    "source": "iana"\n  },\n  "image/vnd.microsoft.icon": {\n    "source": "iana",\n    "extensions": ["ico"]\n  },\n  "image/vnd.mix": {\n    "source": "iana"\n  },\n  "image/vnd.mozilla.apng": {\n    "source": "iana"\n  },\n  "image/vnd.ms-dds": {\n    "extensions": ["dds"]\n  },\n  "image/vnd.ms-modi": {\n    "source": "iana",\n    "extensions": ["mdi"]\n  },\n  "image/vnd.ms-photo": {\n    "source": "apache",\n    "extensions": ["wdp"]\n  },\n  "image/vnd.net-fpx": {\n    "source": "iana",\n    "extensions": ["npx"]\n  },\n  "image/vnd.pco.b16": {\n    "source": "iana",\n    "extensions": ["b16"]\n  },\n  "image/vnd.radiance": {\n    "source": "iana"\n  },\n  "image/vnd.sealed.png": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.gif": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.jpg": {\n    "source": "iana"\n  },\n  "image/vnd.svf": {\n    "source": "iana"\n  },\n  "image/vnd.tencent.tap": {\n    "source": "iana",\n    "extensions": ["tap"]\n  },\n  "image/vnd.valve.source.texture": {\n    "source": "iana",\n    "extensions": ["vtf"]\n  },\n  "image/vnd.wap.wbmp": {\n    "source": "iana",\n    "extensions": ["wbmp"]\n  },\n  "image/vnd.xiff": {\n    "source": "iana",\n    "extensions": ["xif"]\n  },\n  "image/vnd.zbrush.pcx": {\n    "source": "iana",\n    "extensions": ["pcx"]\n  },\n  "image/webp": {\n    "source": "apache",\n    "extensions": ["webp"]\n  },\n  "image/wmf": {\n    "source": "iana",\n    "extensions": ["wmf"]\n  },\n  "image/x-3ds": {\n    "source": "apache",\n    "extensions": ["3ds"]\n  },\n  "image/x-cmu-raster": {\n    "source": "apache",\n    "extensions": ["ras"]\n  },\n  "image/x-cmx": {\n    "source": "apache",\n    "extensions": ["cmx"]\n  },\n  "image/x-freehand": {\n    "source": "apache",\n    "extensions": ["fh","fhc","fh4","fh5","fh7"]\n  },\n  "image/x-icon": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ico"]\n  },\n  "image/x-jng": {\n    "source": "nginx",\n    "extensions": ["jng"]\n  },\n  "image/x-mrsid-image": {\n    "source": "apache",\n    "extensions": ["sid"]\n  },\n  "image/x-ms-bmp": {\n    "source": "nginx",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/x-pcx": {\n    "source": "apache",\n    "extensions": ["pcx"]\n  },\n  "image/x-pict": {\n    "source": "apache",\n    "extensions": ["pic","pct"]\n  },\n  "image/x-portable-anymap": {\n    "source": "apache",\n    "extensions": ["pnm"]\n  },\n  "image/x-portable-bitmap": {\n    "source": "apache",\n    "extensions": ["pbm"]\n  },\n  "image/x-portable-graymap": {\n    "source": "apache",\n    "extensions": ["pgm"]\n  },\n  "image/x-portable-pixmap": {\n    "source": "apache",\n    "extensions": ["ppm"]\n  },\n  "image/x-rgb": {\n    "source": "apache",\n    "extensions": ["rgb"]\n  },\n  "image/x-tga": {\n    "source": "apache",\n    "extensions": ["tga"]\n  },\n  "image/x-xbitmap": {\n    "source": "apache",\n    "extensions": ["xbm"]\n  },\n  "image/x-xcf": {\n    "compressible": false\n  },\n  "image/x-xpixmap": {\n    "source": "apache",\n    "extensions": ["xpm"]\n  },\n  "image/x-xwindowdump": {\n    "source": "apache",\n    "extensions": ["xwd"]\n  },\n  "message/cpim": {\n    "source": "iana"\n  },\n  "message/delivery-status": {\n    "source": "iana"\n  },\n  "message/disposition-notification": {\n    "source": "iana",\n    "extensions": [\n      "disposition-notification"\n    ]\n  },\n  "message/external-body": {\n    "source": "iana"\n  },\n  "message/feedback-report": {\n    "source": "iana"\n  },\n  "message/global": {\n    "source": "iana",\n    "extensions": ["u8msg"]\n  },\n  "message/global-delivery-status": {\n    "source": "iana",\n    "extensions": ["u8dsn"]\n  },\n  "message/global-disposition-notification": {\n    "source": "iana",\n    "extensions": ["u8mdn"]\n  },\n  "message/global-headers": {\n    "source": "iana",\n    "extensions": ["u8hdr"]\n  },\n  "message/http": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/imdn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "message/news": {\n    "source": "iana"\n  },\n  "message/partial": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/rfc822": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eml","mime"]\n  },\n  "message/s-http": {\n    "source": "iana"\n  },\n  "message/sip": {\n    "source": "iana"\n  },\n  "message/sipfrag": {\n    "source": "iana"\n  },\n  "message/tracking-status": {\n    "source": "iana"\n  },\n  "message/vnd.si.simp": {\n    "source": "iana"\n  },\n  "message/vnd.wfa.wsc": {\n    "source": "iana",\n    "extensions": ["wsc"]\n  },\n  "model/3mf": {\n    "source": "iana",\n    "extensions": ["3mf"]\n  },\n  "model/e57": {\n    "source": "iana"\n  },\n  "model/gltf+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gltf"]\n  },\n  "model/gltf-binary": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["glb"]\n  },\n  "model/iges": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["igs","iges"]\n  },\n  "model/mesh": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["msh","mesh","silo"]\n  },\n  "model/mtl": {\n    "source": "iana",\n    "extensions": ["mtl"]\n  },\n  "model/obj": {\n    "source": "iana",\n    "extensions": ["obj"]\n  },\n  "model/stl": {\n    "source": "iana",\n    "extensions": ["stl"]\n  },\n  "model/vnd.collada+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dae"]\n  },\n  "model/vnd.dwf": {\n    "source": "iana",\n    "extensions": ["dwf"]\n  },\n  "model/vnd.flatland.3dml": {\n    "source": "iana"\n  },\n  "model/vnd.gdl": {\n    "source": "iana",\n    "extensions": ["gdl"]\n  },\n  "model/vnd.gs-gdl": {\n    "source": "apache"\n  },\n  "model/vnd.gs.gdl": {\n    "source": "iana"\n  },\n  "model/vnd.gtw": {\n    "source": "iana",\n    "extensions": ["gtw"]\n  },\n  "model/vnd.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "model/vnd.mts": {\n    "source": "iana",\n    "extensions": ["mts"]\n  },\n  "model/vnd.opengex": {\n    "source": "iana",\n    "extensions": ["ogex"]\n  },\n  "model/vnd.parasolid.transmit.binary": {\n    "source": "iana",\n    "extensions": ["x_b"]\n  },\n  "model/vnd.parasolid.transmit.text": {\n    "source": "iana",\n    "extensions": ["x_t"]\n  },\n  "model/vnd.rosette.annotated-data-model": {\n    "source": "iana"\n  },\n  "model/vnd.sap.vds": {\n    "source": "iana",\n    "extensions": ["vds"]\n  },\n  "model/vnd.usdz+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["usdz"]\n  },\n  "model/vnd.valve.source.compiled-map": {\n    "source": "iana",\n    "extensions": ["bsp"]\n  },\n  "model/vnd.vtu": {\n    "source": "iana",\n    "extensions": ["vtu"]\n  },\n  "model/vrml": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["wrl","vrml"]\n  },\n  "model/x3d+binary": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3db","x3dbz"]\n  },\n  "model/x3d+fastinfoset": {\n    "source": "iana",\n    "extensions": ["x3db"]\n  },\n  "model/x3d+vrml": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3dv","x3dvz"]\n  },\n  "model/x3d+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["x3d","x3dz"]\n  },\n  "model/x3d-vrml": {\n    "source": "iana",\n    "extensions": ["x3dv"]\n  },\n  "multipart/alternative": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/appledouble": {\n    "source": "iana"\n  },\n  "multipart/byteranges": {\n    "source": "iana"\n  },\n  "multipart/digest": {\n    "source": "iana"\n  },\n  "multipart/encrypted": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/form-data": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/header-set": {\n    "source": "iana"\n  },\n  "multipart/mixed": {\n    "source": "iana"\n  },\n  "multipart/multilingual": {\n    "source": "iana"\n  },\n  "multipart/parallel": {\n    "source": "iana"\n  },\n  "multipart/related": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/report": {\n    "source": "iana"\n  },\n  "multipart/signed": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/vnd.bint.med-plus": {\n    "source": "iana"\n  },\n  "multipart/voice-message": {\n    "source": "iana"\n  },\n  "multipart/x-mixed-replace": {\n    "source": "iana"\n  },\n  "text/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "text/cache-manifest": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["appcache","manifest"]\n  },\n  "text/calendar": {\n    "source": "iana",\n    "extensions": ["ics","ifb"]\n  },\n  "text/calender": {\n    "compressible": true\n  },\n  "text/cmd": {\n    "compressible": true\n  },\n  "text/coffeescript": {\n    "extensions": ["coffee","litcoffee"]\n  },\n  "text/cql": {\n    "source": "iana"\n  },\n  "text/cql-expression": {\n    "source": "iana"\n  },\n  "text/cql-identifier": {\n    "source": "iana"\n  },\n  "text/css": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["css"]\n  },\n  "text/csv": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csv"]\n  },\n  "text/csv-schema": {\n    "source": "iana"\n  },\n  "text/directory": {\n    "source": "iana"\n  },\n  "text/dns": {\n    "source": "iana"\n  },\n  "text/ecmascript": {\n    "source": "iana"\n  },\n  "text/encaprtp": {\n    "source": "iana"\n  },\n  "text/enriched": {\n    "source": "iana"\n  },\n  "text/fhirpath": {\n    "source": "iana"\n  },\n  "text/flexfec": {\n    "source": "iana"\n  },\n  "text/fwdred": {\n    "source": "iana"\n  },\n  "text/gff3": {\n    "source": "iana"\n  },\n  "text/grammar-ref-list": {\n    "source": "iana"\n  },\n  "text/html": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["html","htm","shtml"]\n  },\n  "text/jade": {\n    "extensions": ["jade"]\n  },\n  "text/javascript": {\n    "source": "iana",\n    "compressible": true\n  },\n  "text/jcr-cnd": {\n    "source": "iana"\n  },\n  "text/jsx": {\n    "compressible": true,\n    "extensions": ["jsx"]\n  },\n  "text/less": {\n    "compressible": true,\n    "extensions": ["less"]\n  },\n  "text/markdown": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["markdown","md"]\n  },\n  "text/mathml": {\n    "source": "nginx",\n    "extensions": ["mml"]\n  },\n  "text/mdx": {\n    "compressible": true,\n    "extensions": ["mdx"]\n  },\n  "text/mizar": {\n    "source": "iana"\n  },\n  "text/n3": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["n3"]\n  },\n  "text/parameters": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/parityfec": {\n    "source": "iana"\n  },\n  "text/plain": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["txt","text","conf","def","list","log","in","ini"]\n  },\n  "text/provenance-notation": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/prs.fallenstein.rst": {\n    "source": "iana"\n  },\n  "text/prs.lines.tag": {\n    "source": "iana",\n    "extensions": ["dsc"]\n  },\n  "text/prs.prop.logic": {\n    "source": "iana"\n  },\n  "text/raptorfec": {\n    "source": "iana"\n  },\n  "text/red": {\n    "source": "iana"\n  },\n  "text/rfc822-headers": {\n    "source": "iana"\n  },\n  "text/richtext": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtx"]\n  },\n  "text/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "text/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "text/rtploopback": {\n    "source": "iana"\n  },\n  "text/rtx": {\n    "source": "iana"\n  },\n  "text/sgml": {\n    "source": "iana",\n    "extensions": ["sgml","sgm"]\n  },\n  "text/shaclc": {\n    "source": "iana"\n  },\n  "text/shex": {\n    "extensions": ["shex"]\n  },\n  "text/slim": {\n    "extensions": ["slim","slm"]\n  },\n  "text/spdx": {\n    "source": "iana",\n    "extensions": ["spdx"]\n  },\n  "text/strings": {\n    "source": "iana"\n  },\n  "text/stylus": {\n    "extensions": ["stylus","styl"]\n  },\n  "text/t140": {\n    "source": "iana"\n  },\n  "text/tab-separated-values": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tsv"]\n  },\n  "text/troff": {\n    "source": "iana",\n    "extensions": ["t","tr","roff","man","me","ms"]\n  },\n  "text/turtle": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["ttl"]\n  },\n  "text/ulpfec": {\n    "source": "iana"\n  },\n  "text/uri-list": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uri","uris","urls"]\n  },\n  "text/vcard": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vcard"]\n  },\n  "text/vnd.a": {\n    "source": "iana"\n  },\n  "text/vnd.abc": {\n    "source": "iana"\n  },\n  "text/vnd.ascii-art": {\n    "source": "iana"\n  },\n  "text/vnd.curl": {\n    "source": "iana",\n    "extensions": ["curl"]\n  },\n  "text/vnd.curl.dcurl": {\n    "source": "apache",\n    "extensions": ["dcurl"]\n  },\n  "text/vnd.curl.mcurl": {\n    "source": "apache",\n    "extensions": ["mcurl"]\n  },\n  "text/vnd.curl.scurl": {\n    "source": "apache",\n    "extensions": ["scurl"]\n  },\n  "text/vnd.debian.copyright": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.dmclientscript": {\n    "source": "iana"\n  },\n  "text/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "text/vnd.esmertec.theme-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.ficlab.flt": {\n    "source": "iana"\n  },\n  "text/vnd.fly": {\n    "source": "iana",\n    "extensions": ["fly"]\n  },\n  "text/vnd.fmi.flexstor": {\n    "source": "iana",\n    "extensions": ["flx"]\n  },\n  "text/vnd.gml": {\n    "source": "iana"\n  },\n  "text/vnd.graphviz": {\n    "source": "iana",\n    "extensions": ["gv"]\n  },\n  "text/vnd.hans": {\n    "source": "iana"\n  },\n  "text/vnd.hgl": {\n    "source": "iana"\n  },\n  "text/vnd.in3d.3dml": {\n    "source": "iana",\n    "extensions": ["3dml"]\n  },\n  "text/vnd.in3d.spot": {\n    "source": "iana",\n    "extensions": ["spot"]\n  },\n  "text/vnd.iptc.newsml": {\n    "source": "iana"\n  },\n  "text/vnd.iptc.nitf": {\n    "source": "iana"\n  },\n  "text/vnd.latex-z": {\n    "source": "iana"\n  },\n  "text/vnd.motorola.reflex": {\n    "source": "iana"\n  },\n  "text/vnd.ms-mediapackage": {\n    "source": "iana"\n  },\n  "text/vnd.net2phone.commcenter.command": {\n    "source": "iana"\n  },\n  "text/vnd.radisys.msml-basic-layout": {\n    "source": "iana"\n  },\n  "text/vnd.senx.warpscript": {\n    "source": "iana"\n  },\n  "text/vnd.si.uricatalogue": {\n    "source": "iana"\n  },\n  "text/vnd.sosi": {\n    "source": "iana"\n  },\n  "text/vnd.sun.j2me.app-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["jad"]\n  },\n  "text/vnd.trolltech.linguist": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.wap.si": {\n    "source": "iana"\n  },\n  "text/vnd.wap.sl": {\n    "source": "iana"\n  },\n  "text/vnd.wap.wml": {\n    "source": "iana",\n    "extensions": ["wml"]\n  },\n  "text/vnd.wap.wmlscript": {\n    "source": "iana",\n    "extensions": ["wmls"]\n  },\n  "text/vtt": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["vtt"]\n  },\n  "text/x-asm": {\n    "source": "apache",\n    "extensions": ["s","asm"]\n  },\n  "text/x-c": {\n    "source": "apache",\n    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]\n  },\n  "text/x-component": {\n    "source": "nginx",\n    "extensions": ["htc"]\n  },\n  "text/x-fortran": {\n    "source": "apache",\n    "extensions": ["f","for","f77","f90"]\n  },\n  "text/x-gwt-rpc": {\n    "compressible": true\n  },\n  "text/x-handlebars-template": {\n    "extensions": ["hbs"]\n  },\n  "text/x-java-source": {\n    "source": "apache",\n    "extensions": ["java"]\n  },\n  "text/x-jquery-tmpl": {\n    "compressible": true\n  },\n  "text/x-lua": {\n    "extensions": ["lua"]\n  },\n  "text/x-markdown": {\n    "compressible": true,\n    "extensions": ["mkd"]\n  },\n  "text/x-nfo": {\n    "source": "apache",\n    "extensions": ["nfo"]\n  },\n  "text/x-opml": {\n    "source": "apache",\n    "extensions": ["opml"]\n  },\n  "text/x-org": {\n    "compressible": true,\n    "extensions": ["org"]\n  },\n  "text/x-pascal": {\n    "source": "apache",\n    "extensions": ["p","pas"]\n  },\n  "text/x-processing": {\n    "compressible": true,\n    "extensions": ["pde"]\n  },\n  "text/x-sass": {\n    "extensions": ["sass"]\n  },\n  "text/x-scss": {\n    "extensions": ["scss"]\n  },\n  "text/x-setext": {\n    "source": "apache",\n    "extensions": ["etx"]\n  },\n  "text/x-sfv": {\n    "source": "apache",\n    "extensions": ["sfv"]\n  },\n  "text/x-suse-ymp": {\n    "compressible": true,\n    "extensions": ["ymp"]\n  },\n  "text/x-uuencode": {\n    "source": "apache",\n    "extensions": ["uu"]\n  },\n  "text/x-vcalendar": {\n    "source": "apache",\n    "extensions": ["vcs"]\n  },\n  "text/x-vcard": {\n    "source": "apache",\n    "extensions": ["vcf"]\n  },\n  "text/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml"]\n  },\n  "text/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "text/yaml": {\n    "extensions": ["yaml","yml"]\n  },\n  "video/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "video/3gpp": {\n    "source": "iana",\n    "extensions": ["3gp","3gpp"]\n  },\n  "video/3gpp-tt": {\n    "source": "iana"\n  },\n  "video/3gpp2": {\n    "source": "iana",\n    "extensions": ["3g2"]\n  },\n  "video/av1": {\n    "source": "iana"\n  },\n  "video/bmpeg": {\n    "source": "iana"\n  },\n  "video/bt656": {\n    "source": "iana"\n  },\n  "video/celb": {\n    "source": "iana"\n  },\n  "video/dv": {\n    "source": "iana"\n  },\n  "video/encaprtp": {\n    "source": "iana"\n  },\n  "video/ffv1": {\n    "source": "iana"\n  },\n  "video/flexfec": {\n    "source": "iana"\n  },\n  "video/h261": {\n    "source": "iana",\n    "extensions": ["h261"]\n  },\n  "video/h263": {\n    "source": "iana",\n    "extensions": ["h263"]\n  },\n  "video/h263-1998": {\n    "source": "iana"\n  },\n  "video/h263-2000": {\n    "source": "iana"\n  },\n  "video/h264": {\n    "source": "iana",\n    "extensions": ["h264"]\n  },\n  "video/h264-rcdo": {\n    "source": "iana"\n  },\n  "video/h264-svc": {\n    "source": "iana"\n  },\n  "video/h265": {\n    "source": "iana"\n  },\n  "video/iso.segment": {\n    "source": "iana",\n    "extensions": ["m4s"]\n  },\n  "video/jpeg": {\n    "source": "iana",\n    "extensions": ["jpgv"]\n  },\n  "video/jpeg2000": {\n    "source": "iana"\n  },\n  "video/jpm": {\n    "source": "apache",\n    "extensions": ["jpm","jpgm"]\n  },\n  "video/mj2": {\n    "source": "iana",\n    "extensions": ["mj2","mjp2"]\n  },\n  "video/mp1s": {\n    "source": "iana"\n  },\n  "video/mp2p": {\n    "source": "iana"\n  },\n  "video/mp2t": {\n    "source": "iana",\n    "extensions": ["ts"]\n  },\n  "video/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mp4","mp4v","mpg4"]\n  },\n  "video/mp4v-es": {\n    "source": "iana"\n  },\n  "video/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]\n  },\n  "video/mpeg4-generic": {\n    "source": "iana"\n  },\n  "video/mpv": {\n    "source": "iana"\n  },\n  "video/nv": {\n    "source": "iana"\n  },\n  "video/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogv"]\n  },\n  "video/parityfec": {\n    "source": "iana"\n  },\n  "video/pointer": {\n    "source": "iana"\n  },\n  "video/quicktime": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["qt","mov"]\n  },\n  "video/raptorfec": {\n    "source": "iana"\n  },\n  "video/raw": {\n    "source": "iana"\n  },\n  "video/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "video/rtploopback": {\n    "source": "iana"\n  },\n  "video/rtx": {\n    "source": "iana"\n  },\n  "video/scip": {\n    "source": "iana"\n  },\n  "video/smpte291": {\n    "source": "iana"\n  },\n  "video/smpte292m": {\n    "source": "iana"\n  },\n  "video/ulpfec": {\n    "source": "iana"\n  },\n  "video/vc1": {\n    "source": "iana"\n  },\n  "video/vc2": {\n    "source": "iana"\n  },\n  "video/vnd.cctv": {\n    "source": "iana"\n  },\n  "video/vnd.dece.hd": {\n    "source": "iana",\n    "extensions": ["uvh","uvvh"]\n  },\n  "video/vnd.dece.mobile": {\n    "source": "iana",\n    "extensions": ["uvm","uvvm"]\n  },\n  "video/vnd.dece.mp4": {\n    "source": "iana"\n  },\n  "video/vnd.dece.pd": {\n    "source": "iana",\n    "extensions": ["uvp","uvvp"]\n  },\n  "video/vnd.dece.sd": {\n    "source": "iana",\n    "extensions": ["uvs","uvvs"]\n  },\n  "video/vnd.dece.video": {\n    "source": "iana",\n    "extensions": ["uvv","uvvv"]\n  },\n  "video/vnd.directv.mpeg": {\n    "source": "iana"\n  },\n  "video/vnd.directv.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dlna.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dvb.file": {\n    "source": "iana",\n    "extensions": ["dvb"]\n  },\n  "video/vnd.fvt": {\n    "source": "iana",\n    "extensions": ["fvt"]\n  },\n  "video/vnd.hns.video": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsavc": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsmpeg2": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.video": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.videop": {\n    "source": "iana"\n  },\n  "video/vnd.mpegurl": {\n    "source": "iana",\n    "extensions": ["mxu","m4u"]\n  },\n  "video/vnd.ms-playready.media.pyv": {\n    "source": "iana",\n    "extensions": ["pyv"]\n  },\n  "video/vnd.nokia.interleaved-multimedia": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.mp4vr": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.videovoip": {\n    "source": "iana"\n  },\n  "video/vnd.objectvideo": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.bink": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.smacker": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg1": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg4": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.swf": {\n    "source": "iana"\n  },\n  "video/vnd.sealedmedia.softseal.mov": {\n    "source": "iana"\n  },\n  "video/vnd.uvvu.mp4": {\n    "source": "iana",\n    "extensions": ["uvu","uvvu"]\n  },\n  "video/vnd.vivo": {\n    "source": "iana",\n    "extensions": ["viv"]\n  },\n  "video/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "video/vp8": {\n    "source": "iana"\n  },\n  "video/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["webm"]\n  },\n  "video/x-f4v": {\n    "source": "apache",\n    "extensions": ["f4v"]\n  },\n  "video/x-fli": {\n    "source": "apache",\n    "extensions": ["fli"]\n  },\n  "video/x-flv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["flv"]\n  },\n  "video/x-m4v": {\n    "source": "apache",\n    "extensions": ["m4v"]\n  },\n  "video/x-matroska": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["mkv","mk3d","mks"]\n  },\n  "video/x-mng": {\n    "source": "apache",\n    "extensions": ["mng"]\n  },\n  "video/x-ms-asf": {\n    "source": "apache",\n    "extensions": ["asf","asx"]\n  },\n  "video/x-ms-vob": {\n    "source": "apache",\n    "extensions": ["vob"]\n  },\n  "video/x-ms-wm": {\n    "source": "apache",\n    "extensions": ["wm"]\n  },\n  "video/x-ms-wmv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["wmv"]\n  },\n  "video/x-ms-wmx": {\n    "source": "apache",\n    "extensions": ["wmx"]\n  },\n  "video/x-ms-wvx": {\n    "source": "apache",\n    "extensions": ["wvx"]\n  },\n  "video/x-msvideo": {\n    "source": "apache",\n    "extensions": ["avi"]\n  },\n  "video/x-sgi-movie": {\n    "source": "apache",\n    "extensions": ["movie"]\n  },\n  "video/x-smv": {\n    "source": "apache",\n    "extensions": ["smv"]\n  },\n  "x-conference/x-cooltalk": {\n    "source": "apache",\n    "extensions": ["ice"]\n  },\n  "x-shader/x-fragment": {\n    "compressible": true\n  },\n  "x-shader/x-vertex": {\n    "compressible": true\n  }\n}`);
const osType2 = (()=>{
    if (globalThis.Deno != null) {
        return Deno.build.os;
    }
    const navigator1 = globalThis.navigator;
    if (navigator1?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows3 = osType2 === "windows";
const CHAR_FORWARD_SLASH3 = 47;
function assertPath3(path3) {
    if (typeof path3 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path3)}`);
    }
}
function isPosixPathSeparator3(code8) {
    return code8 === 47;
}
function isPathSeparator3(code8) {
    return isPosixPathSeparator3(code8) || code8 === 92;
}
function isWindowsDeviceRoot3(code8) {
    return code8 >= 97 && code8 <= 122 || code8 >= 65 && code8 <= 90;
}
function normalizeString3(path3, allowAboveRoot, separator, isPathSeparator4) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code8;
    for(let i2 = 0, len = path3.length; i2 <= len; ++i2){
        if (i2 < len) code8 = path3.charCodeAt(i2);
        else if (isPathSeparator4(code8)) break;
        else code8 = CHAR_FORWARD_SLASH3;
        if (isPathSeparator4(code8)) {
            if (lastSlash === i2 - 1 || dots === 1) {
            } else if (lastSlash !== i2 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path3.slice(lastSlash + 1, i2);
                else res = path3.slice(lastSlash + 1, i2);
                lastSegmentLength = i2 - lastSlash - 1;
            }
            lastSlash = i2;
            dots = 0;
        } else if (code8 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format3(sep9, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep9 + base;
}
const WHITESPACE_ENCODINGS2 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace2(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS2[c] ?? c;
    });
}
class DenoStdInternalError3 extends Error {
    constructor(message12){
        super(message12);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg3 = "") {
    if (!expr) {
        throw new DenoStdInternalError3(msg3);
    }
}
const sep9 = "\\";
const delimiter9 = ";";
function resolve9(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1; i2--){
        let path3;
        if (i2 >= 0) {
            path3 = pathSegments[i2];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path3 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path3 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path3 === undefined || path3.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path3 = `${resolvedDevice}\\`;
            }
        }
        assertPath3(path3);
        const len = path3.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute9 = false;
        const code8 = path3.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator3(code8)) {
                isAbsolute9 = true;
                if (isPathSeparator3(path3.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path3.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator3(path3.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path3.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path3.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot3(code8)) {
                if (path3.charCodeAt(1) === 58) {
                    device = path3.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator3(path3.charCodeAt(2))) {
                            isAbsolute9 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator3(code8)) {
            rootEnd = 1;
            isAbsolute9 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path3.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute9;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString3(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator3);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute9 = false;
    const code8 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code8)) {
            isAbsolute9 = true;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path3.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path3.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path3.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot3(code8)) {
            if (path3.charCodeAt(1) === 58) {
                device = path3.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) {
                        isAbsolute9 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator3(code8)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString3(path3.slice(rootEnd), !isAbsolute9, "\\", isPathSeparator3);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute9) tail = ".";
    if (tail.length > 0 && isPathSeparator3(path3.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute9) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute9) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return false;
    const code8 = path3.charCodeAt(0);
    if (isPathSeparator3(code8)) {
        return true;
    } else if (isWindowsDeviceRoot3(code8)) {
        if (len > 2 && path3.charCodeAt(1) === 58) {
            if (isPathSeparator3(path3.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join9(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i2 = 0; i2 < pathsCount; ++i2){
        const path3 = paths[i2];
        assertPath3(path3);
        if (path3.length > 0) {
            if (joined === undefined) joined = firstPart = path3;
            else joined += `\\${path3}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert3(firstPart != null);
    if (isPathSeparator3(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator3(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator3(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator3(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize9(joined);
}
function relative9(from, to) {
    assertPath3(from);
    assertPath3(to);
    if (from === to) return "";
    const fromOrig = resolve9(from);
    const toOrig = resolve9(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 92) {
                    return toOrig.slice(toStart + i2 + 1);
                } else if (i2 === 2) {
                    return toOrig.slice(toStart + i2);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 92) {
                    lastCommonSep = i2;
                } else if (i2 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i2;
    }
    if (i2 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath9(path3) {
    if (typeof path3 !== "string") return path3;
    if (path3.length === 0) return "";
    const resolvedPath = resolve9(path3);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code8 = resolvedPath.charCodeAt(2);
                if (code8 !== 63 && code8 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot3(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path3;
}
function dirname9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code8 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code8)) {
            rootEnd = offset = 1;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path3;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code8)) {
            if (path3.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator3(code8)) {
        return path3;
    }
    for(let i2 = len - 1; i2 >= offset; --i2){
        if (isPathSeparator3(path3.charCodeAt(i2))) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path3.slice(0, end);
}
function basename9(path3, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath3(path3);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (path3.length >= 2) {
        const drive = path3.charCodeAt(0);
        if (isWindowsDeviceRoot3(drive)) {
            if (path3.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path3.length - 1; i2 >= start; --i2){
            const code8 = path3.charCodeAt(i2);
            if (isPathSeparator3(code8)) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code8 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path3.length;
        return path3.slice(start, end);
    } else {
        for(i2 = path3.length - 1; i2 >= start; --i2){
            if (isPathSeparator3(path3.charCodeAt(i2))) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path3.slice(start, end);
    }
}
function extname9(path3) {
    assertPath3(path3);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path3.length >= 2 && path3.charCodeAt(1) === 58 && isWindowsDeviceRoot3(path3.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i2 = path3.length - 1; i2 >= start; --i2){
        const code8 = path3.charCodeAt(i2);
        if (isPathSeparator3(code8)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path3.slice(startDot, end);
}
function format9(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("\\", pathObject);
}
function parse10(path3) {
    assertPath3(path3);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path3.length;
    if (len === 0) return ret1;
    let rootEnd = 0;
    let code8 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code8)) {
            rootEnd = 1;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code8)) {
            if (path3.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) {
                        if (len === 3) {
                            ret1.root = ret1.dir = path3;
                            return ret1;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret1.root = ret1.dir = path3;
                    return ret1;
                }
            }
        }
    } else if (isPathSeparator3(code8)) {
        ret1.root = ret1.dir = path3;
        return ret1;
    }
    if (rootEnd > 0) ret1.root = path3.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i2 = path3.length - 1;
    let preDotState = 0;
    for(; i2 >= rootEnd; --i2){
        code8 = path3.charCodeAt(i2);
        if (isPathSeparator3(code8)) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret1.base = ret1.name = path3.slice(startPart, end);
        }
    } else {
        ret1.name = path3.slice(startPart, startDot);
        ret1.base = path3.slice(startPart, end);
        ret1.ext = path3.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret1.dir = path3.slice(0, startPart - 1);
    } else ret1.dir = ret1.root;
    return ret1;
}
function fromFileUrl9(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path3 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path3 = `\\\\${url.hostname}${path3}`;
    }
    return path3;
}
function toFileUrl6(path3) {
    if (!isAbsolute9(path3)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path3.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod6 = function() {
    return {
        sep: sep9,
        delimiter: delimiter9,
        resolve: resolve9,
        normalize: normalize9,
        isAbsolute: isAbsolute9,
        join: join9,
        relative: relative9,
        toNamespacedPath: toNamespacedPath9,
        dirname: dirname9,
        basename: basename9,
        extname: extname9,
        format: format9,
        parse: parse10,
        fromFileUrl: fromFileUrl9,
        toFileUrl: toFileUrl6
    };
}();
const sep10 = "/";
const delimiter10 = ":";
function resolve10(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--){
        let path3;
        if (i2 >= 0) path3 = pathSegments[i2];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path3 = Deno.cwd();
        }
        assertPath3(path3);
        if (path3.length === 0) {
            continue;
        }
        resolvedPath = `${path3}/${resolvedPath}`;
        resolvedAbsolute = path3.charCodeAt(0) === CHAR_FORWARD_SLASH3;
    }
    resolvedPath = normalizeString3(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator3);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize10(path3) {
    assertPath3(path3);
    if (path3.length === 0) return ".";
    const isAbsolute10 = path3.charCodeAt(0) === 47;
    const trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
    path3 = normalizeString3(path3, !isAbsolute10, "/", isPosixPathSeparator3);
    if (path3.length === 0 && !isAbsolute10) path3 = ".";
    if (path3.length > 0 && trailingSeparator) path3 += "/";
    if (isAbsolute10) return `/${path3}`;
    return path3;
}
function isAbsolute10(path3) {
    assertPath3(path3);
    return path3.length > 0 && path3.charCodeAt(0) === 47;
}
function join10(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i2 = 0, len = paths.length; i2 < len; ++i2){
        const path3 = paths[i2];
        assertPath3(path3);
        if (path3.length > 0) {
            if (!joined) joined = path3;
            else joined += `/${path3}`;
        }
    }
    if (!joined) return ".";
    return normalize10(joined);
}
function relative10(from, to) {
    assertPath3(from);
    assertPath3(to);
    if (from === to) return "";
    from = resolve10(from);
    to = resolve10(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for(; i2 <= length; ++i2){
        if (i2 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i2) === 47) {
                    return to.slice(toStart + i2 + 1);
                } else if (i2 === 0) {
                    return to.slice(toStart + i2);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i2) === 47) {
                    lastCommonSep = i2;
                } else if (i2 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i2);
        const toCode = to.charCodeAt(toStart + i2);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i2;
    }
    let out = "";
    for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
        if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath10(path3) {
    return path3;
}
function dirname10(path3) {
    assertPath3(path3);
    if (path3.length === 0) return ".";
    const hasRoot = path3.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i2 = path3.length - 1; i2 >= 1; --i2){
        if (path3.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
                end = i2;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path3.slice(0, end);
}
function basename10(path3, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath3(path3);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext !== undefined && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i2 = path3.length - 1; i2 >= 0; --i2){
            const code8 = path3.charCodeAt(i2);
            if (code8 === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                    if (code8 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i2;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path3.length;
        return path3.slice(start, end);
    } else {
        for(i2 = path3.length - 1; i2 >= 0; --i2){
            if (path3.charCodeAt(i2) === 47) {
                if (!matchedSlash) {
                    start = i2 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i2 + 1;
            }
        }
        if (end === -1) return "";
        return path3.slice(start, end);
    }
}
function extname10(path3) {
    assertPath3(path3);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i2 = path3.length - 1; i2 >= 0; --i2){
        const code8 = path3.charCodeAt(i2);
        if (code8 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path3.slice(startDot, end);
}
function format10(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("/", pathObject);
}
function parse11(path3) {
    assertPath3(path3);
    const ret1 = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path3.length === 0) return ret1;
    const isAbsolute11 = path3.charCodeAt(0) === 47;
    let start;
    if (isAbsolute11) {
        ret1.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path3.length - 1;
    let preDotState = 0;
    for(; i2 >= start; --i2){
        const code8 = path3.charCodeAt(i2);
        if (code8 === 47) {
            if (!matchedSlash) {
                startPart = i2 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
        }
        if (code8 === 46) {
            if (startDot === -1) startDot = i2;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute11) {
                ret1.base = ret1.name = path3.slice(1, end);
            } else {
                ret1.base = ret1.name = path3.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute11) {
            ret1.name = path3.slice(1, startDot);
            ret1.base = path3.slice(1, end);
        } else {
            ret1.name = path3.slice(startPart, startDot);
            ret1.base = path3.slice(startPart, end);
        }
        ret1.ext = path3.slice(startDot, end);
    }
    if (startPart > 0) ret1.dir = path3.slice(0, startPart - 1);
    else if (isAbsolute11) ret1.dir = "/";
    return ret1;
}
function fromFileUrl10(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path3) {
    if (!isAbsolute10(path3)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(path3.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod7 = function() {
    return {
        sep: sep10,
        delimiter: delimiter10,
        resolve: resolve10,
        normalize: normalize10,
        isAbsolute: isAbsolute10,
        join: join10,
        relative: relative10,
        toNamespacedPath: toNamespacedPath10,
        dirname: dirname10,
        basename: basename10,
        extname: extname10,
        format: format10,
        parse: parse11,
        fromFileUrl: fromFileUrl10,
        toFileUrl: toFileUrl7
    };
}();
const path3 = isWindows3 ? mod6 : mod7;
const { basename: basename11 , delimiter: delimiter11 , dirname: dirname11 , extname: extname11 , format: format11 , fromFileUrl: fromFileUrl11 , isAbsolute: isAbsolute11 , join: join11 , normalize: normalize11 , parse: parse12 , relative: relative11 , resolve: resolve11 , sep: sep11 , toFileUrl: toFileUrl8 , toNamespacedPath: toNamespacedPath11 ,  } = path3;
const extensions2 = new Map();
const types4 = new Map();
function populateMaps2(extensions3, types5) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type1 of Object.keys(db2)){
        const mime = db2[type1];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions3.set(type1, exts);
        for (const ext of exts){
            const current = types5.get(ext);
            if (current) {
                const from = preference.indexOf(db2[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from > to || from === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types5.set(ext, type1);
        }
    }
}
populateMaps2(extensions2, types4);
function lookup2(path4) {
    const extension = extname11("x." + path4).toLowerCase().substr(1);
    return types4.get(extension);
}
class ContentTypeImpl {
    constructor(type1){
        this.type = type1;
        this.parameters = Object.create(null);
    }
    type;
    parameters;
}
const PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
const QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
const TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
function parse13(str3) {
    let index = str3.indexOf(";");
    const type3 = index !== -1 ? str3.substr(0, index).trim() : str3.trim();
    if (!TYPE_REGEXP.test(type3)) {
        throw new TypeError("invalid media type");
    }
    const obj = new ContentTypeImpl(type3.toLowerCase());
    if (index !== -1) {
        let key1;
        let match;
        let value7;
        PARAM_REGEXP.lastIndex = index;
        while(match = PARAM_REGEXP.exec(str3)){
            if (match.index !== index) {
                throw new TypeError("invalid parameter format");
            }
            index += match[0].length;
            key1 = match[1].toLowerCase();
            value7 = match[2];
            if (value7[0] === '"') {
                value7 = value7.substr(1, value7.length - 2).replace(QESC_REGEXP, "$1");
            }
            obj.parameters[key1] = value7;
        }
        if (index !== str3.length) {
            throw new TypeError("invalid parameter format");
        }
    }
    return obj;
}
const TYPE_REGEXP1 = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
function test(string) {
    return TYPE_REGEXP1.test(string.toLowerCase());
}
class MediaTypeImpl {
    type;
    subtype;
    suffix;
    constructor(type3, subtype, suffix){
        this.type = type3;
        this.subtype = subtype;
        this.suffix = suffix;
    }
}
function is(mediaType, types5) {
    let i2;
    const val = tryNormalizeType(mediaType);
    if (!val) {
        return false;
    }
    if (!types5 || !types5.length) {
        return val;
    }
    let type4;
    for(i2 = 0; i2 < types5.length; i2++){
        const normalized = normalize13(type4 = types5[i2]);
        if (normalized && mimeMatch(normalized, val)) {
            return type4[0] === "+" || type4.indexOf("*") !== -1 ? val : type4;
        }
    }
    return false;
}
function hasBody(header) {
    return header.get("transfer-encoding") !== null || !isNaN(parseInt(header.get("content-length") || "", 10));
}
function typeofrequest(header, types_) {
    const types5 = types_;
    if (!hasBody(header)) {
        return null;
    }
    const value7 = header.get("content-type");
    if (!value7) {
        return false;
    }
    return is(value7, types5);
}
const normalize13 = function normalize14(type4) {
    switch(type4){
        case "urlencoded":
            return "application/x-www-form-urlencoded";
        case "multipart":
            return "multipart/*";
    }
    if (type4[0] === "+") {
        return "*/*" + type4;
    }
    return type4.indexOf("/") === -1 ? lookup2(type4) : type4;
};
function mimeMatch(expected1, actual3) {
    const actualParts = actual3.split("/");
    const expectedParts = expected1.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
        return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
        return false;
    }
    return true;
}
function normalizeType(value7) {
    const type4 = parse13(value7).type;
    if (!test(type4)) {
        return null;
    }
    return type4;
}
function tryNormalizeType(value7) {
    try {
        return normalizeType(value7);
    } catch (err) {
        return null;
    }
}
const regIP4 = new RegExp("^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$");
const regIP6 = new RegExp("^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$");
function isIPv4(ip) {
    return regIP4.test(ip);
}
function isIPv6(ip) {
    return regIP6.test(ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    } else if (isIPv6(ip)) {
        return 6;
    } else {
        return 0;
    }
}
const FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header, field1) {
    if (header === "*") {
        return header;
    }
    const fields = !Array.isArray(field1) ? parse15(String(field1)) : field1;
    for(let j = 0; j < fields.length; j++){
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
            throw new TypeError(`field argument contains an invalid header name \`${fields[j]}\``);
        }
    }
    let val = header;
    const vals = parse15(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
    }
    for(let i2 = 0; i2 < fields.length; i2++){
        const fld = fields[i2].toLowerCase();
        if (vals.indexOf(fld) === -1) {
            vals.push(fld);
            val = val ? val + ", " + fields[i2] : fields[i2];
        }
    }
    return val;
}
function parse15(header) {
    let end = 0;
    const list = [];
    let start = 0;
    for(let i2 = 0, len = header.length; i2 < len; i2++){
        switch(header.charCodeAt(i2)){
            case 32:
                if (start === end) {
                    start = end = i2 + 1;
                }
                break;
            case 44:
                list.push(header.substring(start, end));
                start = end = i2 + 1;
                break;
            default:
                end = i2 + 1;
                break;
        }
    }
    list.push(header.substring(start, end));
    return list;
}
function vary(header, field1) {
    let val = header.get("vary") || "";
    if (val = append(val, field1)) {
        header.set("vary", val);
    }
}
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml(string) {
    const str3 = "" + string;
    const match = matchHtmlRegExp.exec(str3);
    if (!match) {
        return str3;
    }
    let escape;
    let html = "";
    let index = 0;
    let lastIndex = 0;
    for(index = match.index; index < str3.length; index++){
        switch(str3.charCodeAt(index)){
            case 34:
                escape = "&quot;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 39:
                escape = "&#39;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default: continue;
        }
        if (lastIndex !== index) {
            html += str3.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str3.substring(lastIndex, index) : html;
}
const ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
const UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
const UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
const encoder2 = new TextEncoder();
function encode1(input5) {
    return encoder2.encode(input5);
}
const decoder2 = new TextDecoder();
class StringReader extends Deno.Buffer {
    constructor(s){
        super(encode1(s).buffer);
    }
}
class MultiReader {
    readers;
    currentIndex = 0;
    constructor(...readers){
        this.readers = readers;
    }
    async read(p) {
        const r3 = this.readers[this.currentIndex];
        if (!r3) return null;
        const result = await r3.read(p);
        if (result === null) {
            this.currentIndex++;
            return 0;
        }
        return result;
    }
}
class LimitedReader {
    reader;
    limit;
    constructor(reader2, limit){
        this.reader = reader2;
        this.limit = limit;
    }
    async read(p) {
        if (this.limit <= 0) {
            return null;
        }
        if (p.length > this.limit) {
            p = p.subarray(0, this.limit);
        }
        const n = await this.reader.read(p);
        if (n == null) {
            return null;
        }
        this.limit -= n;
        return n;
    }
}
function copyBytes1(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
class DenoStdInternalError4 extends Error {
    constructor(message13){
        super(message13);
        this.name = "DenoStdInternalError";
    }
}
function assert4(expr, msg3 = "") {
    if (!expr) {
        throw new DenoStdInternalError4(msg3);
    }
}
const DEFAULT_BUF_SIZE2 = 4096;
const MIN_BUF_SIZE2 = 16;
const CR2 = "\r".charCodeAt(0);
const LF2 = "\n".charCodeAt(0);
class BufferFullError2 extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial3){
        super("Buffer full");
        this.partial = partial3;
    }
}
class PartialReadError2 extends Deno.errors.UnexpectedEof {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader2 {
    buf;
    rd;
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader2 ? r : new BufReader2(r, size);
    }
    constructor(rd3, size7 = 4096){
        if (size7 < 16) {
            size7 = MIN_BUF_SIZE2;
        }
        this._reset(new Uint8Array(size7), rd3);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i2 = 100; i2 > 0; i2--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert4(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr1 = await this.rd.read(p);
                const nread = rr1 ?? 0;
                assert4(nread >= 0, "negative read");
                return rr1;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert4(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copyBytes1(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError2();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                err.partial = p.subarray(0, bytesRead);
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line;
        try {
            line = await this.readSlice(LF2);
        } catch (err) {
            let { partial: partial4  } = err;
            assert4(partial4 instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError2)) {
                throw err;
            }
            if (!this.eof && partial4.byteLength > 0 && partial4[partial4.byteLength - 1] === CR2) {
                assert4(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial4 = partial4.subarray(0, partial4.byteLength - 1);
            }
            return {
                line: partial4,
                more: !this.eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF2) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR2) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s1 = 0;
        let slice;
        while(true){
            let i2 = this.buf.subarray(this.r + s1, this.w).indexOf(delim);
            if (i2 >= 0) {
                i2 += s1;
                slice = this.buf.subarray(this.r, this.r + i2 + 1);
                this.r += i2 + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError2(oldbuf);
            }
            s1 = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                err.partial = slice;
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                err.partial = this.buf.subarray(this.r, this.w);
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError2(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase2 {
    buf;
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter2 extends AbstractBufBase2 {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter2 ? writer : new BufWriter2(writer, size);
    }
    constructor(writer5, size8 = 4096){
        super();
        this.writer = writer5;
        if (size8 <= 0) {
            size8 = DEFAULT_BUF_SIZE2;
        }
        this.buf = new Uint8Array(size8);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync2 extends AbstractBufBase2 {
    writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync2 ? writer : new BufWriterSync2(writer, size);
    }
    constructor(writer6, size9 = 4096){
        super();
        this.writer = writer6;
        if (size9 <= 0) {
            size9 = DEFAULT_BUF_SIZE2;
        }
        this.buf = new Uint8Array(size9);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const recordSize = 512;
const ustar = "ustar\u000000";
const initialChecksum = 8 * 32;
async function readBlock(reader1, p) {
    let bytesRead = 0;
    while(bytesRead < p.length){
        const rr = await reader1.read(p.subarray(bytesRead));
        if (rr === null) {
            if (bytesRead === 0) {
                return null;
            } else {
                throw new PartialReadError2();
            }
        }
        bytesRead += rr;
    }
    return bytesRead;
}
class FileReader1 {
    filePath;
    file;
    constructor(filePath){
        this.filePath = filePath;
    }
    async read(p) {
        if (!this.file) {
            this.file = await Deno.open(this.filePath, {
                read: true
            });
        }
        const res = await Deno.read(this.file.rid, p);
        if (res === null) {
            Deno.close(this.file.rid);
            this.file = undefined;
        }
        return res;
    }
}
function trim(buffer) {
    const index = buffer.findIndex((v)=>v === 0
    );
    if (index < 0) return buffer;
    return buffer.subarray(0, index);
}
function clean(length) {
    const buffer = new Uint8Array(length);
    buffer.fill(0, 0, length - 1);
    return buffer;
}
function pad(num, bytes, base) {
    const numString = num.toString(base || 8);
    return "000000000000".substr(numString.length + 12 - bytes) + numString;
}
var FileTypes;
(function(FileTypes1) {
    FileTypes1[FileTypes1["file"] = 0] = "file";
    FileTypes1[FileTypes1["link"] = 1] = "link";
    FileTypes1[FileTypes1["symlink"] = 2] = "symlink";
    FileTypes1[FileTypes1["character-device"] = 3] = "character-device";
    FileTypes1[FileTypes1["block-device"] = 4] = "block-device";
    FileTypes1[FileTypes1["directory"] = 5] = "directory";
    FileTypes1[FileTypes1["fifo"] = 6] = "fifo";
    FileTypes1[FileTypes1["contiguous-file"] = 7] = "contiguous-file";
})(FileTypes || (FileTypes = {
}));
const ustarStructure = [
    {
        field: "fileName",
        length: 100
    },
    {
        field: "fileMode",
        length: 8
    },
    {
        field: "uid",
        length: 8
    },
    {
        field: "gid",
        length: 8
    },
    {
        field: "fileSize",
        length: 12
    },
    {
        field: "mtime",
        length: 12
    },
    {
        field: "checksum",
        length: 8
    },
    {
        field: "type",
        length: 1
    },
    {
        field: "linkName",
        length: 100
    },
    {
        field: "ustar",
        length: 8
    },
    {
        field: "owner",
        length: 32
    },
    {
        field: "group",
        length: 32
    },
    {
        field: "majorNumber",
        length: 8
    },
    {
        field: "minorNumber",
        length: 8
    },
    {
        field: "fileNamePrefix",
        length: 155
    },
    {
        field: "padding",
        length: 12
    }, 
];
function formatHeader(data) {
    const encoder3 = new TextEncoder(), buffer = clean(512);
    let offset = 0;
    ustarStructure.forEach(function(value7) {
        const entry = encoder3.encode(data[value7.field] || "");
        buffer.set(entry, offset);
        offset += value7.length;
    });
    return buffer;
}
function parseHeader(buffer) {
    const data = {
    };
    let offset = 0;
    ustarStructure.forEach(function(value7) {
        const arr = buffer.subarray(offset, offset + value7.length);
        data[value7.field] = arr;
        offset += value7.length;
    });
    return data;
}
class Tar {
    data;
    constructor(){
        this.data = [];
    }
    async append(fn, opts) {
        if (typeof fn !== "string") {
            throw new Error("file name not specified");
        }
        let fileName = fn;
        let fileNamePrefix;
        if (fileName.length > 100) {
            let i2 = fileName.length;
            while(i2 >= 0){
                i2 = fileName.lastIndexOf("/", i2);
                if (i2 <= 155) {
                    fileNamePrefix = fileName.substr(0, i2);
                    fileName = fileName.substr(i2 + 1);
                    break;
                }
                i2--;
            }
            const errMsg = "ustar format does not allow a long file name (length of [file name" + "prefix] + / + [file name] must be shorter than 256 bytes)";
            if (i2 < 0 || fileName.length > 100) {
                throw new Error(errMsg);
            } else {
                assert4(fileNamePrefix != null);
                if (fileNamePrefix.length > 155) {
                    throw new Error(errMsg);
                }
            }
        }
        opts = opts || {
        };
        let info;
        if (opts.filePath) {
            info = await Deno.stat(opts.filePath);
            if (info.isDirectory) {
                info.size = 0;
                opts.reader = new Deno.Buffer();
            }
        }
        const mode = opts.fileMode || info && info.mode || parseInt("777", 8) & 4095, mtime = Math.floor(opts.mtime ?? (info?.mtime ?? new Date()).valueOf() / 1000), uid = opts.uid || 0, gid = opts.gid || 0;
        if (typeof opts.owner === "string" && opts.owner.length >= 32) {
            throw new Error("ustar format does not allow owner name length >= 32 bytes");
        }
        if (typeof opts.group === "string" && opts.group.length >= 32) {
            throw new Error("ustar format does not allow group name length >= 32 bytes");
        }
        const fileSize = info?.size ?? opts.contentSize;
        assert4(fileSize != null, "fileSize must be set");
        const type4 = opts.type ? FileTypes[opts.type] : info?.isDirectory ? FileTypes.directory : FileTypes.file;
        const tarData = {
            fileName,
            fileNamePrefix,
            fileMode: pad(mode, 7),
            uid: pad(uid, 7),
            gid: pad(gid, 7),
            fileSize: pad(fileSize, 11),
            mtime: pad(mtime, 11),
            checksum: "        ",
            type: type4.toString(),
            ustar,
            owner: opts.owner || "",
            group: opts.group || "",
            filePath: opts.filePath,
            reader: opts.reader
        };
        let checksum = 0;
        const encoder3 = new TextEncoder();
        Object.keys(tarData).filter((key1)=>[
                "filePath",
                "reader"
            ].indexOf(key1) < 0
        ).forEach(function(key1) {
            checksum += encoder3.encode(tarData[key1]).reduce((p, c)=>p + c
            , 0);
        });
        tarData.checksum = pad(checksum, 6) + "\u0000 ";
        this.data.push(tarData);
    }
    getReader() {
        const readers1 = [];
        this.data.forEach((tarData)=>{
            let { reader: reader1  } = tarData;
            const { filePath: filePath1  } = tarData;
            const headerArr = formatHeader(tarData);
            readers1.push(new Deno.Buffer(headerArr));
            if (!reader1) {
                assert4(filePath1 != null);
                reader1 = new FileReader1(filePath1);
            }
            readers1.push(reader1);
            assert4(tarData.fileSize != null, "fileSize must be set");
            readers1.push(new Deno.Buffer(clean(512 - (parseInt(tarData.fileSize, 8) % 512 || 512))));
        });
        readers1.push(new Deno.Buffer(clean(512 * 2)));
        return new MultiReader(...readers1);
    }
}
class TarEntry {
    #header;
    #reader;
    #size;
    #read = 0;
    #consumed = false;
    #entrySize;
    constructor(meta1, header1, reader1){
        Object.assign(this, meta1);
        this.#header = header1;
        this.#reader = reader1;
        this.#size = this.fileSize || 0;
        const blocks1 = Math.ceil(this.#size / 512);
        this.#entrySize = blocks1 * recordSize;
    }
    get consumed() {
        return this.#consumed;
    }
    async read(p) {
        const entryBytesLeft = this.#entrySize - this.#read;
        const bufSize = Math.min(p.length, entryBytesLeft);
        if (entryBytesLeft <= 0) return null;
        const block = new Uint8Array(bufSize);
        const n = await readBlock(this.#reader, block);
        const bytesLeft = this.#size - this.#read;
        this.#read += n || 0;
        if (n === null || bytesLeft <= 0) {
            if (null) this.#consumed = true;
            return null;
        }
        const offset = bytesLeft < n ? bytesLeft : n;
        p.set(block.subarray(0, offset), 0);
        return offset < 0 ? n - Math.abs(offset) : offset;
    }
    async discard() {
        if (this.#consumed) return;
        this.#consumed = true;
        if (typeof this.#reader.seek === "function") {
            await this.#reader.seek(this.#entrySize - this.#read, Deno.SeekMode.Current);
            this.#read = this.#entrySize;
        } else {
            await Deno.readAll(this);
        }
    }
}
class Untar {
    reader;
    block;
    #entry;
    constructor(reader3){
        this.reader = reader3;
        this.block = new Uint8Array(recordSize);
    }
    #checksum = (header1)=>{
        let sum = initialChecksum;
        for(let i2 = 0; i2 < 512; i2++){
            if (i2 >= 148 && i2 < 156) {
                continue;
            }
            sum += header1[i2];
        }
        return sum;
    };
    #getHeader = async ()=>{
        await readBlock(this.reader, this.block);
        const header1 = parseHeader(this.block);
        const decoder3 = new TextDecoder();
        const checksum = this.#checksum(this.block);
        if (parseInt(decoder3.decode(header1.checksum), 8) !== checksum) {
            if (checksum === initialChecksum) {
                return null;
            }
            throw new Error("checksum error");
        }
        const magic = decoder3.decode(header1.ustar);
        if (magic.indexOf("ustar")) {
            throw new Error(`unsupported archive format: ${magic}`);
        }
        return header1;
    };
    #getMetadata = (header1)=>{
        const decoder3 = new TextDecoder();
        const meta1 = {
            fileName: decoder3.decode(trim(header1.fileName))
        };
        const fileNamePrefix = trim(header1.fileNamePrefix);
        if (fileNamePrefix.byteLength > 0) {
            meta1.fileName = decoder3.decode(fileNamePrefix) + "/" + meta1.fileName;
        }
        [
            "fileMode",
            "mtime",
            "uid",
            "gid"
        ].forEach((key1)=>{
            const arr = trim(header1[key1]);
            if (arr.byteLength > 0) {
                meta1[key1] = parseInt(decoder3.decode(arr), 8);
            }
        });
        [
            "owner",
            "group",
            "type"
        ].forEach((key1)=>{
            const arr = trim(header1[key1]);
            if (arr.byteLength > 0) {
                meta1[key1] = decoder3.decode(arr);
            }
        });
        meta1.fileSize = parseInt(decoder3.decode(header1.fileSize), 8);
        meta1.type = FileTypes[parseInt(meta1.type)] ?? meta1.type;
        return meta1;
    };
    async extract() {
        if (this.#entry && !this.#entry.consumed) {
            await this.#entry.discard();
        }
        const header1 = await this.#getHeader();
        if (header1 === null) return null;
        const meta1 = this.#getMetadata(header1);
        this.#entry = new TarEntry(meta1, header1, this.reader);
        return this.#entry;
    }
    async *[Symbol.asyncIterator]() {
        while(true){
            const entry = await this.extract();
            if (entry === null) return;
            yield entry;
        }
    }
}
let NATIVE_OS1 = "linux";
const navigator1 = globalThis.navigator;
if (globalThis.Deno != null) {
    NATIVE_OS1 = Deno.build.os;
} else if (navigator1?.appVersion?.includes?.("Win") ?? false) {
    NATIVE_OS1 = "windows";
}
function validateIntegerRange1(value7, name13, min1 = -2147483648, max1 = 2147483647) {
    if (!Number.isInteger(value7)) {
        throw new Error(`${name13} must be 'an integer' but was ${value7}`);
    }
    if (value7 < min1 || value7 > max1) {
        throw new Error(`${name13} must be >= ${min1} && <= ${max1}. Value was ${value7}`);
    }
}
class EventEmitter1 {
    static defaultMaxListeners = 10;
    static errorMonitor = Symbol("events.errorMonitor");
    maxListeners;
    _events;
    constructor(){
        this._events = new Map();
    }
    _addListener(eventName, listener, prepend) {
        this.emit("newListener", eventName, listener);
        if (this._events.has(eventName)) {
            const listeners = this._events.get(eventName);
            if (prepend) {
                listeners.unshift(listener);
            } else {
                listeners.push(listener);
            }
        } else {
            this._events.set(eventName, [
                listener
            ]);
        }
        const max1 = this.getMaxListeners();
        if (max1 > 0 && this.listenerCount(eventName) > max1) {
            const warning = new Error(`Possible EventEmitter memory leak detected.\n         ${this.listenerCount(eventName)} ${eventName.toString()} listeners.\n         Use emitter.setMaxListeners() to increase limit`);
            warning.name = "MaxListenersExceededWarning";
            console.warn(warning);
        }
        return this;
    }
    addListener(eventName, listener) {
        return this._addListener(eventName, listener, false);
    }
    emit(eventName, ...args) {
        if (this._events.has(eventName)) {
            if (eventName === "error" && this._events.get(EventEmitter1.errorMonitor)) {
                this.emit(EventEmitter1.errorMonitor, ...args);
            }
            const listeners = this._events.get(eventName).slice();
            for (const listener3 of listeners){
                try {
                    listener3.apply(this, args);
                } catch (err) {
                    this.emit("error", err);
                }
            }
            return true;
        } else if (eventName === "error") {
            if (this._events.get(EventEmitter1.errorMonitor)) {
                this.emit(EventEmitter1.errorMonitor, ...args);
            }
            const errMsg = args.length > 0 ? args[0] : Error("Unhandled error.");
            throw errMsg;
        }
        return false;
    }
    eventNames() {
        return Array.from(this._events.keys());
    }
    getMaxListeners() {
        return this.maxListeners || EventEmitter1.defaultMaxListeners;
    }
    listenerCount(eventName) {
        if (this._events.has(eventName)) {
            return this._events.get(eventName).length;
        } else {
            return 0;
        }
    }
    _listeners(target, eventName, unwrap) {
        if (!target._events.has(eventName)) {
            return [];
        }
        const eventListeners = target._events.get(eventName);
        return unwrap ? this.unwrapListeners(eventListeners) : eventListeners.slice(0);
    }
    unwrapListeners(arr) {
        const unwrappedListeners = new Array(arr.length);
        for(let i2 = 0; i2 < arr.length; i2++){
            unwrappedListeners[i2] = arr[i2]["listener"] || arr[i2];
        }
        return unwrappedListeners;
    }
    listeners(eventName) {
        return this._listeners(this, eventName, true);
    }
    rawListeners(eventName) {
        return this._listeners(this, eventName, false);
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
        const wrapped = this.onceWrap(eventName, listener);
        this.on(eventName, wrapped);
        return this;
    }
    onceWrap(eventName, listener) {
        const wrapper = function(...args2) {
            this.context.removeListener(this.eventName, this.rawListener);
            this.listener.apply(this.context, args2);
        };
        const wrapperContext = {
            eventName: eventName,
            listener: listener,
            rawListener: wrapper,
            context: this
        };
        const wrapped = wrapper.bind(wrapperContext);
        wrapperContext.rawListener = wrapped;
        wrapped.listener = listener;
        return wrapped;
    }
    prependListener(eventName, listener) {
        return this._addListener(eventName, listener, true);
    }
    prependOnceListener(eventName, listener) {
        const wrapped = this.onceWrap(eventName, listener);
        this.prependListener(eventName, wrapped);
        return this;
    }
    removeAllListeners(eventName) {
        if (this._events === undefined) {
            return this;
        }
        if (eventName) {
            if (this._events.has(eventName)) {
                const listeners = this._events.get(eventName).slice();
                this._events.delete(eventName);
                for (const listener3 of listeners){
                    this.emit("removeListener", eventName, listener3);
                }
            }
        } else {
            const eventList = this.eventNames();
            eventList.map((value7)=>{
                this.removeAllListeners(value7);
            });
        }
        return this;
    }
    removeListener(eventName, listener) {
        if (this._events.has(eventName)) {
            const arr = this._events.get(eventName);
            assert4(arr);
            let listenerIndex = -1;
            for(let i2 = arr.length - 1; i2 >= 0; i2--){
                if (arr[i2] == listener || arr[i2] && arr[i2]["listener"] == listener) {
                    listenerIndex = i2;
                    break;
                }
            }
            if (listenerIndex >= 0) {
                arr.splice(listenerIndex, 1);
                this.emit("removeListener", eventName, listener);
                if (arr.length === 0) {
                    this._events.delete(eventName);
                }
            }
        }
        return this;
    }
    setMaxListeners(n) {
        if (n !== Infinity) {
            if (n === 0) {
                n = Infinity;
            } else {
                validateIntegerRange1(n, "maxListeners", 0);
            }
        }
        this.maxListeners = n;
        return this;
    }
}
class Crc32Stream {
    bytes = [];
    poly = 3988292384;
    crc = 0 ^ -1;
    encoder = new TextEncoder();
    #crc32 = "";
    constructor(){
        this.reset();
    }
    get crc32() {
        return this.#crc32;
    }
    reset() {
        this.#crc32 = "";
        this.crc = 0 ^ -1;
        for(let n = 0; n < 256; n += 1){
            let c = n;
            for(let k = 0; k < 8; k += 1){
                if (c & 1) {
                    c = this.poly ^ c >>> 1;
                } else {
                    c = c >>> 1;
                }
            }
            this.bytes[n] = c >>> 0;
        }
    }
    append(arr) {
        if (typeof arr === "string") {
            arr = this.encoder.encode(arr);
        }
        let crc = this.crc;
        for(let i2 = 0, l = arr.length; i2 < l; i2 += 1){
            crc = crc >>> 8 ^ this.bytes[(crc ^ arr[i2]) & 255];
        }
        this.crc = crc;
        this.#crc32 = numberToHex(crc ^ -1);
        return this.#crc32;
    }
}
function numberToHex(n) {
    return (n >>> 0).toString(16);
}
const message14 = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
};
function zero(buf) {
    buf.fill(0, 0, buf.length);
}
const LITERALS = 256;
const L_CODES = 256 + 1 + 29;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const extra_lbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0, 
];
const extra_dbits = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13, 
];
const extra_blbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
];
const bl_order = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15, 
];
const static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
const static_dtree = new Array(30 * 2);
zero(static_dtree);
const _dist_code = new Array(512);
zero(_dist_code);
const _length_code = new Array(258 - 3 + 1);
zero(_length_code);
const base_length = new Array(29);
zero(base_length);
const base_dist = new Array(30);
zero(base_dist);
class StaticTreeDesc {
    static_tree;
    extra_bits;
    extra_base;
    elems;
    max_length;
    has_stree;
    constructor(static_tree, extra_bits, extra_base, elems, max_length){
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
    }
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
class TreeDesc {
    dyn_tree;
    max_code;
    stat_desc;
    constructor(dyn_tree, stat_desc){
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
    }
}
function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s1, w) {
    s1.pending_buf[s1.pending++] = w & 255;
    s1.pending_buf[s1.pending++] = w >>> 8 & 255;
}
function send_bits(s1, value7, length) {
    if (s1.bi_valid > 16 - length) {
        s1.bi_buf |= value7 << s1.bi_valid & 65535;
        put_short(s1, s1.bi_buf);
        s1.bi_buf = value7 >> Buf_size - s1.bi_valid;
        s1.bi_valid += length - Buf_size;
    } else {
        s1.bi_buf |= value7 << s1.bi_valid & 65535;
        s1.bi_valid += length;
    }
}
function send_code(s1, c, tree) {
    send_bits(s1, tree[c * 2], tree[c * 2 + 1]);
}
function bi_reverse(code8, len) {
    let res = 0;
    do {
        res |= code8 & 1;
        code8 >>>= 1;
        res <<= 1;
    }while ((--len) > 0)
    return res >>> 1;
}
function bi_flush(s1) {
    if (s1.bi_valid === 16) {
        put_short(s1, s1.bi_buf);
        s1.bi_buf = 0;
        s1.bi_valid = 0;
    } else if (s1.bi_valid >= 8) {
        s1.pending_buf[s1.pending++] = s1.bi_buf & 255;
        s1.bi_buf >>= 8;
        s1.bi_valid -= 8;
    }
}
function gen_bitlen(s1, desc) {
    let tree = desc.dyn_tree;
    let max_code = desc.max_code;
    let stree = desc.stat_desc.static_tree;
    let has_stree = desc.stat_desc.has_stree;
    let extra = desc.stat_desc.extra_bits;
    let base = desc.stat_desc.extra_base;
    let max_length1 = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for(bits = 0; bits <= 15; bits++){
        s1.bl_count[bits] = 0;
    }
    tree[s1.heap[s1.heap_max] * 2 + 1] = 0;
    for(h = s1.heap_max + 1; h < HEAP_SIZE; h++){
        n = s1.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length1) {
            bits = max_length1;
            overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) continue;
        s1.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
            xbits = extra[n - base];
        }
        f = tree[n * 2];
        s1.opt_len += f * (bits + xbits);
        if (has_stree) {
            s1.static_len += f * (stree[n * 2 + 1] + xbits);
        }
    }
    if (overflow === 0) return;
    do {
        bits = max_length1 - 1;
        while(s1.bl_count[bits] === 0)bits--;
        s1.bl_count[bits]--;
        s1.bl_count[bits + 1] += 2;
        s1.bl_count[max_length1]--;
        overflow -= 2;
    }while (overflow > 0)
    for(bits = max_length1; bits !== 0; bits--){
        n = s1.bl_count[bits];
        while(n !== 0){
            m = s1.heap[--h];
            if (m > max_code) continue;
            if (tree[m * 2 + 1] !== bits) {
                s1.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
            }
            n--;
        }
    }
}
function gen_codes(tree, max_code, bl_count) {
    let next_code = new Array(15 + 1);
    let code8 = 0;
    let bits;
    let n;
    for(bits = 1; bits <= 15; bits++){
        next_code[bits] = code8 = code8 + bl_count[bits - 1] << 1;
    }
    for(n = 0; n <= max_code; n++){
        let len = tree[n * 2 + 1];
        if (len === 0) continue;
        tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
}
function tr_static_init() {
    let n;
    let bits;
    let length;
    let code8;
    let dist;
    let bl_count = new Array(15 + 1);
    length = 0;
    for(code8 = 0; code8 < 29 - 1; code8++){
        base_length[code8] = length;
        for(n = 0; n < 1 << extra_lbits[code8]; n++){
            _length_code[length++] = code8;
        }
    }
    _length_code[length - 1] = code8;
    dist = 0;
    for(code8 = 0; code8 < 16; code8++){
        base_dist[code8] = dist;
        for(n = 0; n < 1 << extra_dbits[code8]; n++){
            _dist_code[dist++] = code8;
        }
    }
    dist >>= 7;
    for(; code8 < 30; code8++){
        base_dist[code8] = dist << 7;
        for(n = 0; n < 1 << extra_dbits[code8] - 7; n++){
            _dist_code[256 + dist++] = code8;
        }
    }
    for(bits = 0; bits <= 15; bits++){
        bl_count[bits] = 0;
    }
    n = 0;
    while(n <= 143){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    while(n <= 255){
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
    }
    while(n <= 279){
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
    }
    while(n <= 287){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for(n = 0; n < 30; n++){
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
}
function init_block(s1) {
    let n;
    for(n = 0; n < L_CODES; n++)s1.dyn_ltree[n * 2] = 0;
    for(n = 0; n < 30; n++)s1.dyn_dtree[n * 2] = 0;
    for(n = 0; n < 19; n++)s1.bl_tree[n * 2] = 0;
    s1.dyn_ltree[END_BLOCK * 2] = 1;
    s1.opt_len = s1.static_len = 0;
    s1.last_lit = s1.matches = 0;
}
function bi_windup(s1) {
    if (s1.bi_valid > 8) {
        put_short(s1, s1.bi_buf);
    } else if (s1.bi_valid > 0) {
        s1.pending_buf[s1.pending++] = s1.bi_buf;
    }
    s1.bi_buf = 0;
    s1.bi_valid = 0;
}
function copy_block(s1, buf, len, header1) {
    bi_windup(s1);
    if (header1) {
        put_short(s1, len);
        put_short(s1, ~len);
    }
    s1.pending_buf.set(s1.window.subarray(buf, buf + len), s1.pending);
    s1.pending += len;
}
function smaller(tree, n, m, depth) {
    let _n2 = n * 2;
    let _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s1, tree, k) {
    let v = s1.heap[k];
    let j = k << 1;
    while(j <= s1.heap_len){
        if (j < s1.heap_len && smaller(tree, s1.heap[j + 1], s1.heap[j], s1.depth)) {
            j++;
        }
        if (smaller(tree, v, s1.heap[j], s1.depth)) break;
        s1.heap[k] = s1.heap[j];
        k = j;
        j <<= 1;
    }
    s1.heap[k] = v;
}
function compress_block(s1, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code8;
    let extra;
    if (s1.last_lit !== 0) {
        do {
            dist = s1.pending_buf[s1.d_buf + lx * 2] << 8 | s1.pending_buf[s1.d_buf + lx * 2 + 1];
            lc = s1.pending_buf[s1.l_buf + lx];
            lx++;
            if (dist === 0) {
                send_code(s1, lc, ltree);
            } else {
                code8 = _length_code[lc];
                send_code(s1, code8 + 256 + 1, ltree);
                extra = extra_lbits[code8];
                if (extra !== 0) {
                    lc -= base_length[code8];
                    send_bits(s1, lc, extra);
                }
                dist--;
                code8 = d_code(dist);
                send_code(s1, code8, dtree);
                extra = extra_dbits[code8];
                if (extra !== 0) {
                    dist -= base_dist[code8];
                    send_bits(s1, dist, extra);
                }
            }
        }while (lx < s1.last_lit)
    }
    send_code(s1, 256, ltree);
}
function build_tree(s1, desc) {
    let tree = desc.dyn_tree;
    let stree = desc.stat_desc.static_tree;
    let has_stree = desc.stat_desc.has_stree;
    let elems1 = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s1.heap_len = 0;
    s1.heap_max = HEAP_SIZE;
    for(n = 0; n < elems1; n++){
        if (tree[n * 2] !== 0) {
            s1.heap[++s1.heap_len] = max_code = n;
            s1.depth[n] = 0;
        } else {
            tree[n * 2 + 1] = 0;
        }
    }
    while(s1.heap_len < 2){
        node = s1.heap[++s1.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s1.depth[node] = 0;
        s1.opt_len--;
        if (has_stree) {
            s1.static_len -= stree[node * 2 + 1];
        }
    }
    desc.max_code = max_code;
    for(n = s1.heap_len >> 1; n >= 1; n--)pqdownheap(s1, tree, n);
    node = elems1;
    do {
        n = s1.heap[1];
        s1.heap[1] = s1.heap[s1.heap_len--];
        pqdownheap(s1, tree, 1);
        m = s1.heap[1];
        s1.heap[--s1.heap_max] = n;
        s1.heap[--s1.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s1.depth[node] = (s1.depth[n] >= s1.depth[m] ? s1.depth[n] : s1.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s1.heap[1] = node++;
        pqdownheap(s1, tree, 1);
    }while (s1.heap_len >= 2)
    s1.heap[--s1.heap_max] = s1.heap[1];
    gen_bitlen(s1, desc);
    gen_codes(tree, max_code, s1.bl_count);
}
function scan_tree(s1, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if ((++count) < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            s1.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
            if (curlen !== prevlen) s1.bl_tree[curlen * 2]++;
            s1.bl_tree[16 * 2]++;
        } else if (count <= 10) {
            s1.bl_tree[17 * 2]++;
        } else {
            s1.bl_tree[18 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
}
function send_tree(s1, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if ((++count) < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            do {
                send_code(s1, curlen, s1.bl_tree);
            }while ((--count) !== 0)
        } else if (curlen !== 0) {
            if (curlen !== prevlen) {
                send_code(s1, curlen, s1.bl_tree);
                count--;
            }
            send_code(s1, 16, s1.bl_tree);
            send_bits(s1, count - 3, 2);
        } else if (count <= 10) {
            send_code(s1, 17, s1.bl_tree);
            send_bits(s1, count - 3, 3);
        } else {
            send_code(s1, 18, s1.bl_tree);
            send_bits(s1, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
}
function build_bl_tree(s1) {
    let max_blindex;
    scan_tree(s1, s1.dyn_ltree, s1.l_desc.max_code);
    scan_tree(s1, s1.dyn_dtree, s1.d_desc.max_code);
    build_tree(s1, s1.bl_desc);
    for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){
        if (s1.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
        }
    }
    s1.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
}
function send_all_trees(s1, lcodes, dcodes, blcodes) {
    let rank;
    send_bits(s1, lcodes - 257, 5);
    send_bits(s1, dcodes - 1, 5);
    send_bits(s1, blcodes - 4, 4);
    for(rank = 0; rank < blcodes; rank++){
        send_bits(s1, s1.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s1, s1.dyn_ltree, lcodes - 1);
    send_tree(s1, s1.dyn_dtree, dcodes - 1);
}
function detect_data_type(s1) {
    let black_mask = 4093624447;
    let n;
    for(n = 0; n <= 31; n++, black_mask >>>= 1){
        if (black_mask & 1 && s1.dyn_ltree[n * 2] !== 0) {
            return 0;
        }
    }
    if (s1.dyn_ltree[9 * 2] !== 0 || s1.dyn_ltree[10 * 2] !== 0 || s1.dyn_ltree[13 * 2] !== 0) {
        return 1;
    }
    for(n = 32; n < 256; n++){
        if (s1.dyn_ltree[n * 2] !== 0) {
            return 1;
        }
    }
    return 0;
}
let static_init_done = false;
function _tr_init(s1) {
    if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
    }
    s1.l_desc = new TreeDesc(s1.dyn_ltree, static_l_desc);
    s1.d_desc = new TreeDesc(s1.dyn_dtree, static_d_desc);
    s1.bl_desc = new TreeDesc(s1.bl_tree, static_bl_desc);
    s1.bi_buf = 0;
    s1.bi_valid = 0;
    init_block(s1);
}
function _tr_stored_block(s1, buf, stored_len, last) {
    send_bits(s1, (0 << 1) + (last ? 1 : 0), 3);
    copy_block(s1, buf, stored_len, true);
}
function _tr_align(s1) {
    send_bits(s1, 1 << 1, 3);
    send_code(s1, 256, static_ltree);
    bi_flush(s1);
}
function _tr_flush_block(s1, buf, stored_len, last) {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s1.level > 0) {
        if (s1.strm.data_type === 2) {
            s1.strm.data_type = detect_data_type(s1);
        }
        build_tree(s1, s1.l_desc);
        build_tree(s1, s1.d_desc);
        max_blindex = build_bl_tree(s1);
        opt_lenb = s1.opt_len + 3 + 7 >>> 3;
        static_lenb = s1.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
    } else {
        opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s1, buf, stored_len, last);
    } else if (s1.strategy === 4 || static_lenb === opt_lenb) {
        send_bits(s1, (1 << 1) + (last ? 1 : 0), 3);
        compress_block(s1, static_ltree, static_dtree);
    } else {
        send_bits(s1, (2 << 1) + (last ? 1 : 0), 3);
        send_all_trees(s1, s1.l_desc.max_code + 1, s1.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s1, s1.dyn_ltree, s1.dyn_dtree);
    }
    init_block(s1);
    if (last) {
        bi_windup(s1);
    }
}
function _tr_tally(s1, dist, lc) {
    s1.pending_buf[s1.d_buf + s1.last_lit * 2] = dist >>> 8 & 255;
    s1.pending_buf[s1.d_buf + s1.last_lit * 2 + 1] = dist & 255;
    s1.pending_buf[s1.l_buf + s1.last_lit] = lc & 255;
    s1.last_lit++;
    if (dist === 0) {
        s1.dyn_ltree[lc * 2]++;
    } else {
        s1.matches++;
        dist--;
        s1.dyn_ltree[(_length_code[lc] + 256 + 1) * 2]++;
        s1.dyn_dtree[d_code(dist) * 2]++;
    }
    return s1.last_lit === s1.lit_bufsize - 1;
}
function adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0;
    let s2 = adler >>> 16 & 65535 | 0;
    let n = 0;
    while(len !== 0){
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
        }while (--n)
        s1 %= 65521;
        s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
}
function makeTable() {
    let c;
    const table = [];
    const m = 3988292384;
    for(let n = 0; n < 256; n++){
        c = n;
        for(let k = 0; k < 8; k++){
            c = c & 1 ? m ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }
    return table;
}
const crcTable = makeTable();
function crc32(crc, buf, len, pos) {
    let t = crcTable;
    let end = pos + len;
    let f = 255;
    crc ^= -1;
    for(let i2 = pos; i2 < end; i2++){
        crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & f];
    }
    return crc ^ -1;
}
var STATUS;
(function(STATUS1) {
    STATUS1[STATUS1["Z_NO_FLUSH"] = 0] = "Z_NO_FLUSH";
    STATUS1[STATUS1["Z_PARTIAL_FLUSH"] = 1] = "Z_PARTIAL_FLUSH";
    STATUS1[STATUS1["Z_SYNC_FLUSH"] = 2] = "Z_SYNC_FLUSH";
    STATUS1[STATUS1["Z_FULL_FLUSH"] = 3] = "Z_FULL_FLUSH";
    STATUS1[STATUS1["Z_FINISH"] = 4] = "Z_FINISH";
    STATUS1[STATUS1["Z_BLOCK"] = 5] = "Z_BLOCK";
    STATUS1[STATUS1["Z_TREES"] = 6] = "Z_TREES";
    STATUS1[STATUS1["Z_OK"] = 0] = "Z_OK";
    STATUS1[STATUS1["Z_STREAM_END"] = 1] = "Z_STREAM_END";
    STATUS1[STATUS1["Z_NEED_DICT"] = 2] = "Z_NEED_DICT";
    STATUS1[STATUS1["Z_ERRNO"] = -1] = "Z_ERRNO";
    STATUS1[STATUS1["Z_STREAM_ERROR"] = -2] = "Z_STREAM_ERROR";
    STATUS1[STATUS1["Z_DATA_ERROR"] = -3] = "Z_DATA_ERROR";
    STATUS1[STATUS1["Z_BUF_ERROR"] = -5] = "Z_BUF_ERROR";
    STATUS1[STATUS1["Z_NO_COMPRESSION"] = 0] = "Z_NO_COMPRESSION";
    STATUS1[STATUS1["Z_BEST_SPEED"] = 1] = "Z_BEST_SPEED";
    STATUS1[STATUS1["Z_BEST_COMPRESSION"] = 9] = "Z_BEST_COMPRESSION";
    STATUS1[STATUS1["Z_DEFAULT_COMPRESSION"] = -1] = "Z_DEFAULT_COMPRESSION";
    STATUS1[STATUS1["Z_FILTERED"] = 1] = "Z_FILTERED";
    STATUS1[STATUS1["Z_HUFFMAN_ONLY"] = 2] = "Z_HUFFMAN_ONLY";
    STATUS1[STATUS1["Z_RLE"] = 3] = "Z_RLE";
    STATUS1[STATUS1["Z_FIXED"] = 4] = "Z_FIXED";
    STATUS1[STATUS1["Z_DEFAULT_STRATEGY"] = 0] = "Z_DEFAULT_STRATEGY";
    STATUS1[STATUS1["Z_BINARY"] = 0] = "Z_BINARY";
    STATUS1[STATUS1["Z_TEXT"] = 1] = "Z_TEXT";
    STATUS1[STATUS1["Z_UNKNOWN"] = 2] = "Z_UNKNOWN";
    STATUS1[STATUS1["Z_DEFLATED"] = 8] = "Z_DEFLATED";
})(STATUS || (STATUS = {
}));
const Z_STREAM_ERROR = -2;
const Z_DEFAULT_COMPRESSION = -1;
const Z_UNKNOWN = 2;
const L_CODES1 = 256 + 1 + 29;
const HEAP_SIZE1 = 2 * L_CODES1 + 1;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
function err1(strm, errorCode) {
    strm.msg = message14[errorCode];
    return errorCode;
}
function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
}
function zero1(buf) {
    buf.fill(0, 0, buf.length);
}
function flush_pending(strm) {
    let s1 = strm.state;
    let len = s1.pending;
    if (len > strm.avail_out) {
        len = strm.avail_out;
    }
    if (len === 0) return;
    strm.output.set(s1.pending_buf.subarray(s1.pending_out, s1.pending_out + len), strm.next_out);
    strm.next_out += len;
    s1.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s1.pending -= len;
    if (s1.pending === 0) {
        s1.pending_out = 0;
    }
}
function flush_block_only(s1, last) {
    _tr_flush_block(s1, s1.block_start >= 0 ? s1.block_start : -1, s1.strstart - s1.block_start, last);
    s1.block_start = s1.strstart;
    flush_pending(s1.strm);
}
function put_byte(s1, b) {
    s1.pending_buf[s1.pending++] = b;
}
function putShortMSB(s1, b) {
    s1.pending_buf[s1.pending++] = b >>> 8 & 255;
    s1.pending_buf[s1.pending++] = b & 255;
}
function read_buf(strm, buf, start, size10) {
    let len = strm.avail_in;
    if (len > size10) len = size10;
    if (len === 0) return 0;
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
}
function longest_match(s1, cur_match) {
    let chain_length = s1.max_chain_length;
    let scan = s1.strstart;
    let match;
    let len;
    let best_len = s1.prev_length;
    let nice_match = s1.nice_match;
    let limit1 = s1.strstart > s1.w_size - MIN_LOOKAHEAD ? s1.strstart - (s1.w_size - MIN_LOOKAHEAD) : 0;
    let _win = s1.window;
    let wmask = s1.w_mask;
    let prev = s1.prev;
    let strend = s1.strstart + 258;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s1.prev_length >= s1.good_match) {
        chain_length >>= 2;
    }
    if (nice_match > s1.lookahead) nice_match = s1.lookahead;
    do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
        }
        scan += 2;
        match++;
        do {
        }while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend)
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
            s1.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
                break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
        }
    }while ((cur_match = prev[cur_match & wmask]) > limit1 && (--chain_length) !== 0)
    if (best_len <= s1.lookahead) {
        return best_len;
    }
    return s1.lookahead;
}
function fill_window(s1) {
    let _w_size = s1.w_size;
    let p, n, m, more, str3;
    do {
        more = s1.window_size - s1.lookahead - s1.strstart;
        if (s1.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s1.window.set(s1.window.subarray(_w_size, _w_size + _w_size), 0);
            s1.match_start -= _w_size;
            s1.strstart -= _w_size;
            s1.block_start -= _w_size;
            n = s1.hash_size;
            p = n;
            do {
                m = s1.head[--p];
                s1.head[p] = m >= _w_size ? m - _w_size : 0;
            }while (--n)
            n = _w_size;
            p = n;
            do {
                m = s1.prev[--p];
                s1.prev[p] = m >= _w_size ? m - _w_size : 0;
            }while (--n)
            more += _w_size;
        }
        if (s1.strm.avail_in === 0) {
            break;
        }
        n = read_buf(s1.strm, s1.window, s1.strstart + s1.lookahead, more);
        s1.lookahead += n;
        if (s1.lookahead + s1.insert >= 3) {
            str3 = s1.strstart - s1.insert;
            s1.ins_h = s1.window[str3];
            s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[str3 + 1]) & s1.hash_mask;
            while(s1.insert){
                s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[str3 + MIN_MATCH - 1]) & s1.hash_mask;
                s1.prev[str3 & s1.w_mask] = s1.head[s1.ins_h];
                s1.head[s1.ins_h] = str3;
                str3++;
                s1.insert--;
                if (s1.lookahead + s1.insert < 3) {
                    break;
                }
            }
        }
    }while (s1.lookahead < MIN_LOOKAHEAD && s1.strm.avail_in !== 0)
}
function deflate_stored(s1, flush) {
    let max_block_size = 65535;
    if (max_block_size > s1.pending_buf_size - 5) {
        max_block_size = s1.pending_buf_size - 5;
    }
    for(;;){
        if (s1.lookahead <= 1) {
            fill_window(s1);
            if (s1.lookahead === 0 && flush === STATUS.Z_NO_FLUSH) {
                return 1;
            }
            if (s1.lookahead === 0) {
                break;
            }
        }
        s1.strstart += s1.lookahead;
        s1.lookahead = 0;
        let max_start = s1.block_start + max_block_size;
        if (s1.strstart === 0 || s1.strstart >= max_start) {
            s1.lookahead = s1.strstart - max_start;
            s1.strstart = max_start;
            flush_block_only(s1, false);
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        }
        if (s1.strstart - s1.block_start >= s1.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s1, false);
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s1.insert = 0;
    if (flush === STATUS.Z_FINISH) {
        flush_block_only(s1, true);
        if (s1.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s1.strstart > s1.block_start) {
        flush_block_only(s1, false);
        if (s1.strm.avail_out === 0) {
            return 1;
        }
    }
    return 1;
}
function deflate_fast(s1, flush) {
    let hash_head;
    let bflush;
    for(;;){
        if (s1.lookahead < MIN_LOOKAHEAD) {
            fill_window(s1);
            if (s1.lookahead < MIN_LOOKAHEAD && flush === STATUS.Z_NO_FLUSH) {
                return 1;
            }
            if (s1.lookahead === 0) {
                break;
            }
        }
        hash_head = 0;
        if (s1.lookahead >= 3) {
            s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[s1.strstart + MIN_MATCH - 1]) & s1.hash_mask;
            hash_head = s1.prev[s1.strstart & s1.w_mask] = s1.head[s1.ins_h];
            s1.head[s1.ins_h] = s1.strstart;
        }
        if (hash_head !== 0 && s1.strstart - hash_head <= s1.w_size - MIN_LOOKAHEAD) {
            s1.match_length = longest_match(s1, hash_head);
        }
        if (s1.match_length >= 3) {
            bflush = _tr_tally(s1, s1.strstart - s1.match_start, s1.match_length - MIN_MATCH);
            s1.lookahead -= s1.match_length;
            if (s1.match_length <= s1.max_lazy_match && s1.lookahead >= 3) {
                s1.match_length--;
                do {
                    s1.strstart++;
                    s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[s1.strstart + MIN_MATCH - 1]) & s1.hash_mask;
                    hash_head = s1.prev[s1.strstart & s1.w_mask] = s1.head[s1.ins_h];
                    s1.head[s1.ins_h] = s1.strstart;
                }while ((--s1.match_length) !== 0)
                s1.strstart++;
            } else {
                s1.strstart += s1.match_length;
                s1.match_length = 0;
                s1.ins_h = s1.window[s1.strstart];
                s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[s1.strstart + 1]) & s1.hash_mask;
            }
        } else {
            bflush = _tr_tally(s1, 0, s1.window[s1.strstart]);
            s1.lookahead--;
            s1.strstart++;
        }
        if (bflush) {
            flush_block_only(s1, false);
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s1.insert = s1.strstart < MIN_MATCH - 1 ? s1.strstart : MIN_MATCH - 1;
    if (flush === STATUS.Z_FINISH) {
        flush_block_only(s1, true);
        if (s1.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s1.last_lit) {
        flush_block_only(s1, false);
        if (s1.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
}
function deflate_slow(s1, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for(;;){
        if (s1.lookahead < MIN_LOOKAHEAD) {
            fill_window(s1);
            if (s1.lookahead < MIN_LOOKAHEAD && flush === STATUS.Z_NO_FLUSH) {
                return 1;
            }
            if (s1.lookahead === 0) break;
        }
        hash_head = 0;
        if (s1.lookahead >= 3) {
            s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[s1.strstart + MIN_MATCH - 1]) & s1.hash_mask;
            hash_head = s1.prev[s1.strstart & s1.w_mask] = s1.head[s1.ins_h];
            s1.head[s1.ins_h] = s1.strstart;
        }
        s1.prev_length = s1.match_length;
        s1.prev_match = s1.match_start;
        s1.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s1.prev_length < s1.max_lazy_match && s1.strstart - hash_head <= s1.w_size - MIN_LOOKAHEAD) {
            s1.match_length = longest_match(s1, hash_head);
            if (s1.match_length <= 5 && (s1.strategy === 1 || s1.match_length === 3 && s1.strstart - s1.match_start > 4096)) {
                s1.match_length = MIN_MATCH - 1;
            }
        }
        if (s1.prev_length >= 3 && s1.match_length <= s1.prev_length) {
            max_insert = s1.strstart + s1.lookahead - MIN_MATCH;
            bflush = _tr_tally(s1, s1.strstart - 1 - s1.prev_match, s1.prev_length - MIN_MATCH);
            s1.lookahead -= s1.prev_length - 1;
            s1.prev_length -= 2;
            do {
                if ((++s1.strstart) <= max_insert) {
                    s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[s1.strstart + MIN_MATCH - 1]) & s1.hash_mask;
                    hash_head = s1.prev[s1.strstart & s1.w_mask] = s1.head[s1.ins_h];
                    s1.head[s1.ins_h] = s1.strstart;
                }
            }while ((--s1.prev_length) !== 0)
            s1.match_available = 0;
            s1.match_length = MIN_MATCH - 1;
            s1.strstart++;
            if (bflush) {
                flush_block_only(s1, false);
                if (s1.strm.avail_out === 0) {
                    return 1;
                }
            }
        } else if (s1.match_available) {
            bflush = _tr_tally(s1, 0, s1.window[s1.strstart - 1]);
            if (bflush) {
                flush_block_only(s1, false);
            }
            s1.strstart++;
            s1.lookahead--;
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        } else {
            s1.match_available = 1;
            s1.strstart++;
            s1.lookahead--;
        }
    }
    if (s1.match_available) {
        bflush = _tr_tally(s1, 0, s1.window[s1.strstart - 1]);
        s1.match_available = 0;
    }
    s1.insert = s1.strstart < MIN_MATCH - 1 ? s1.strstart : MIN_MATCH - 1;
    if (flush === STATUS.Z_FINISH) {
        flush_block_only(s1, true);
        if (s1.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s1.last_lit) {
        flush_block_only(s1, false);
        if (s1.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
}
function deflate_rle(s1, flush) {
    let bflush;
    let prev;
    let scan, strend;
    let _win = s1.window;
    for(;;){
        if (s1.lookahead <= 258) {
            fill_window(s1);
            if (s1.lookahead <= 258 && flush === STATUS.Z_NO_FLUSH) {
                return 1;
            }
            if (s1.lookahead === 0) break;
        }
        s1.match_length = 0;
        if (s1.lookahead >= 3 && s1.strstart > 0) {
            scan = s1.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s1.strstart + MAX_MATCH;
                do {
                }while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend)
                s1.match_length = MAX_MATCH - (strend - scan);
                if (s1.match_length > s1.lookahead) {
                    s1.match_length = s1.lookahead;
                }
            }
        }
        if (s1.match_length >= 3) {
            bflush = _tr_tally(s1, 1, s1.match_length - MIN_MATCH);
            s1.lookahead -= s1.match_length;
            s1.strstart += s1.match_length;
            s1.match_length = 0;
        } else {
            bflush = _tr_tally(s1, 0, s1.window[s1.strstart]);
            s1.lookahead--;
            s1.strstart++;
        }
        if (bflush) {
            flush_block_only(s1, false);
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s1.insert = 0;
    if (flush === STATUS.Z_FINISH) {
        flush_block_only(s1, true);
        if (s1.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s1.last_lit) {
        flush_block_only(s1, false);
        if (s1.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
}
function deflate_huff(s1, flush) {
    let bflush;
    for(;;){
        if (s1.lookahead === 0) {
            fill_window(s1);
            if (s1.lookahead === 0) {
                if (flush === STATUS.Z_NO_FLUSH) {
                    return 1;
                }
                break;
            }
        }
        s1.match_length = 0;
        bflush = _tr_tally(s1, 0, s1.window[s1.strstart]);
        s1.lookahead--;
        s1.strstart++;
        if (bflush) {
            flush_block_only(s1, false);
            if (s1.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s1.insert = 0;
    if (flush === STATUS.Z_FINISH) {
        flush_block_only(s1, true);
        if (s1.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s1.last_lit) {
        flush_block_only(s1, false);
        if (s1.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
}
class Config {
    good_length;
    max_lazy;
    nice_length;
    max_chain;
    func;
    constructor(good_length, max_lazy, nice_length, max_chain, func){
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }
}
let configuration_table;
configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
];
function lm_init(s1) {
    s1.window_size = 2 * s1.w_size;
    zero1(s1.head);
    s1.max_lazy_match = configuration_table[s1.level].max_lazy;
    s1.good_match = configuration_table[s1.level].good_length;
    s1.nice_match = configuration_table[s1.level].nice_length;
    s1.max_chain_length = configuration_table[s1.level].max_chain;
    s1.strstart = 0;
    s1.block_start = 0;
    s1.lookahead = 0;
    s1.insert = 0;
    s1.match_length = s1.prev_length = MIN_MATCH - 1;
    s1.match_available = 0;
    s1.ins_h = 0;
}
class DeflateState {
    strm = null;
    status = 0;
    pending_buf = null;
    pending_buf_size = 0;
    pending_out = 0;
    pending = 0;
    wrap = 0;
    gzhead = null;
    gzindex = 0;
    method = 8;
    last_flush = -1;
    w_size = 0;
    w_bits = 0;
    w_mask = 0;
    window = null;
    window_size = 0;
    prev = null;
    head = null;
    ins_h = 0;
    hash_size = 0;
    hash_bits = 0;
    hash_mask = 0;
    hash_shift = 0;
    block_start = 0;
    match_length = 0;
    prev_match = 0;
    match_available = 0;
    strstart = 0;
    match_start = 0;
    lookahead = 0;
    prev_length = 0;
    max_chain_length = 0;
    max_lazy_match = 0;
    level = 0;
    strategy = 0;
    good_match = 0;
    nice_match = 0;
    dyn_ltree = new Uint16Array(HEAP_SIZE1 * 2);
    dyn_dtree = new Uint16Array((2 * 30 + 1) * 2);
    bl_tree = new Uint16Array((2 * 19 + 1) * 2);
    l_desc = null;
    d_desc = null;
    bl_desc = null;
    bl_count = new Uint16Array(15 + 1);
    heap = new Uint16Array(2 * L_CODES1 + 1);
    heap_len = 0;
    heap_max = 0;
    depth = new Uint16Array(2 * L_CODES1 + 1);
    l_buf = 0;
    lit_bufsize = 0;
    last_lit = 0;
    d_buf = 0;
    opt_len = 0;
    static_len = 0;
    matches = 0;
    insert = 0;
    bi_buf = 0;
    bi_valid = 0;
    constructor(){
        zero1(this.dyn_ltree);
        zero1(this.dyn_dtree);
        zero1(this.bl_tree);
        zero1(this.heap);
        zero1(this.depth);
    }
}
function deflateResetKeep(strm) {
    let s1;
    if (!strm || !strm.state) {
        return err1(strm, STATUS.Z_STREAM_ERROR.toString());
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s1 = strm.state;
    s1.pending = 0;
    s1.pending_out = 0;
    if (s1.wrap < 0) {
        s1.wrap = -s1.wrap;
    }
    s1.status = s1.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s1.wrap === 2 ? 0 : 1;
    s1.last_flush = STATUS.Z_NO_FLUSH;
    _tr_init(s1);
    return 0;
}
function deflateReset(strm) {
    let ret1 = deflateResetKeep(strm);
    if (ret1 === 0) {
        lm_init(strm.state);
    }
    return ret1;
}
function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) return Z_STREAM_ERROR;
    if (strm.state.wrap !== 2) return Z_STREAM_ERROR;
    strm.state.gzhead = head;
    return 0;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
        return STATUS.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
    }
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > 9 || method !== 8 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4) {
        return err1(strm, STATUS.Z_STREAM_ERROR.toString());
    }
    if (windowBits === 8) {
        windowBits = 9;
    }
    let s1 = new DeflateState();
    strm.state = s1;
    s1.strm = strm;
    s1.wrap = wrap;
    s1.gzhead = null;
    s1.w_bits = windowBits;
    s1.w_size = 1 << s1.w_bits;
    s1.w_mask = s1.w_size - 1;
    s1.hash_bits = memLevel + 7;
    s1.hash_size = 1 << s1.hash_bits;
    s1.hash_mask = s1.hash_size - 1;
    s1.hash_shift = ~~((s1.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s1.window = new Uint8Array(s1.w_size * 2);
    s1.head = new Uint16Array(s1.hash_size);
    s1.prev = new Uint16Array(s1.w_size);
    s1.lit_bufsize = 1 << memLevel + 6;
    s1.pending_buf_size = s1.lit_bufsize * 4;
    s1.pending_buf = new Uint8Array(s1.pending_buf_size);
    s1.d_buf = 1 * s1.lit_bufsize;
    s1.l_buf = (1 + 2) * s1.lit_bufsize;
    s1.level = level;
    s1.strategy = strategy;
    s1.method = method;
    return deflateReset(strm);
}
function deflate1(strm, flush) {
    let old_flush, s1;
    let beg, val;
    if (!strm || !strm.state || flush > STATUS.Z_BLOCK || flush < 0) {
        return strm ? err1(strm, STATUS.Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s1 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s1.status === 666 && flush !== STATUS.Z_FINISH) {
        return err1(strm, strm.avail_out === 0 ? STATUS.Z_BUF_ERROR : STATUS.Z_STREAM_ERROR);
    }
    s1.strm = strm;
    old_flush = s1.last_flush;
    s1.last_flush = flush;
    if (s1.status === 42) {
        if (s1.wrap === 2) {
            strm.adler = 0;
            put_byte(s1, 31);
            put_byte(s1, 139);
            put_byte(s1, 8);
            if (!s1.gzhead) {
                put_byte(s1, 0);
                put_byte(s1, 0);
                put_byte(s1, 0);
                put_byte(s1, 0);
                put_byte(s1, 0);
                put_byte(s1, s1.level === 9 ? 2 : s1.strategy >= 2 || s1.level < 2 ? 4 : 0);
                put_byte(s1, 3);
                s1.status = BUSY_STATE;
            } else {
                put_byte(s1, (s1.gzhead.text ? 1 : 0) + (s1.gzhead.hcrc ? 2 : 0) + (!s1.gzhead.extra ? 0 : 4) + (!s1.gzhead.name ? 0 : 8) + (!s1.gzhead.comment ? 0 : 16));
                put_byte(s1, s1.gzhead.time & 255);
                put_byte(s1, s1.gzhead.time >> 8 & 255);
                put_byte(s1, s1.gzhead.time >> 16 & 255);
                put_byte(s1, s1.gzhead.time >> 24 & 255);
                put_byte(s1, s1.level === 9 ? 2 : s1.strategy >= 2 || s1.level < 2 ? 4 : 0);
                put_byte(s1, s1.gzhead.os & 255);
                if (s1.gzhead.extra && s1.gzhead.extra.length) {
                    put_byte(s1, s1.gzhead.extra.length & 255);
                    put_byte(s1, s1.gzhead.extra.length >> 8 & 255);
                }
                if (s1.gzhead.hcrc) {
                    strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending, 0);
                }
                s1.gzindex = 0;
                s1.status = EXTRA_STATE;
            }
        } else {
            let header1 = 8 + (s1.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s1.strategy >= 2 || s1.level < 2) {
                level_flags = 0;
            } else if (s1.level < 6) {
                level_flags = 1;
            } else if (s1.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header1 |= level_flags << 6;
            if (s1.strstart !== 0) header1 |= PRESET_DICT;
            header1 += 31 - header1 % 31;
            s1.status = BUSY_STATE;
            putShortMSB(s1, header1);
            if (s1.strstart !== 0) {
                putShortMSB(s1, strm.adler >>> 16);
                putShortMSB(s1, strm.adler & 65535);
            }
            strm.adler = 1;
        }
    }
    if (s1.status === 69) {
        if (s1.gzhead.extra) {
            beg = s1.pending;
            while(s1.gzindex < (s1.gzhead.extra.length & 65535)){
                if (s1.pending === s1.pending_buf_size) {
                    if (s1.gzhead.hcrc && s1.pending > beg) {
                        strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s1.pending;
                    if (s1.pending === s1.pending_buf_size) {
                        break;
                    }
                }
                put_byte(s1, s1.gzhead.extra[s1.gzindex] & 255);
                s1.gzindex++;
            }
            if (s1.gzhead.hcrc && s1.pending > beg) {
                strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
            }
            if (s1.gzindex === s1.gzhead.extra.length) {
                s1.gzindex = 0;
                s1.status = NAME_STATE;
            }
        } else {
            s1.status = NAME_STATE;
        }
    }
    if (s1.status === 73) {
        if (s1.gzhead.name) {
            beg = s1.pending;
            do {
                if (s1.pending === s1.pending_buf_size) {
                    if (s1.gzhead.hcrc && s1.pending > beg) {
                        strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s1.pending;
                    if (s1.pending === s1.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s1.gzindex < s1.gzhead.name.length) {
                    val = s1.gzhead.name.charCodeAt(s1.gzindex++) & 255;
                } else {
                    val = 0;
                }
                put_byte(s1, val);
            }while (val !== 0)
            if (s1.gzhead.hcrc && s1.pending > beg) {
                strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
            }
            if (val === 0) {
                s1.gzindex = 0;
                s1.status = COMMENT_STATE;
            }
        } else {
            s1.status = COMMENT_STATE;
        }
    }
    if (s1.status === 91) {
        if (s1.gzhead.comment) {
            beg = s1.pending;
            do {
                if (s1.pending === s1.pending_buf_size) {
                    if (s1.gzhead.hcrc && s1.pending > beg) {
                        strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s1.pending;
                    if (s1.pending === s1.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s1.gzindex < s1.gzhead.comment.length) {
                    val = s1.gzhead.comment.charCodeAt(s1.gzindex++) & 255;
                } else {
                    val = 0;
                }
                put_byte(s1, val);
            }while (val !== 0)
            if (s1.gzhead.hcrc && s1.pending > beg) {
                strm.adler = crc32(strm.adler, s1.pending_buf, s1.pending - beg, beg);
            }
            if (val === 0) {
                s1.status = HCRC_STATE;
            }
        } else {
            s1.status = HCRC_STATE;
        }
    }
    if (s1.status === 103) {
        if (s1.gzhead.hcrc) {
            if (s1.pending + 2 > s1.pending_buf_size) {
                flush_pending(strm);
            }
            if (s1.pending + 2 <= s1.pending_buf_size) {
                put_byte(s1, strm.adler & 255);
                put_byte(s1, strm.adler >> 8 & 255);
                strm.adler = 0;
                s1.status = BUSY_STATE;
            }
        } else {
            s1.status = BUSY_STATE;
        }
    }
    if (s1.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
            s1.last_flush = -1;
            return 0;
        }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== STATUS.Z_FINISH) {
        return err1(strm, STATUS.Z_BUF_ERROR);
    }
    if (s1.status === 666 && strm.avail_in !== 0) {
        return err1(strm, STATUS.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s1.lookahead !== 0 || flush !== STATUS.Z_NO_FLUSH && s1.status !== 666) {
        let bstate = s1.strategy === 2 ? deflate_huff(s1, flush) : s1.strategy === 3 ? deflate_rle(s1, flush) : configuration_table[s1.level].func(s1, flush);
        if (bstate === 3 || bstate === 4) {
            s1.status = FINISH_STATE;
        }
        if (bstate === 1 || bstate === 3) {
            if (strm.avail_out === 0) {
                s1.last_flush = -1;
            }
            return STATUS.Z_OK;
        }
        if (bstate === 2) {
            if (flush === STATUS.Z_PARTIAL_FLUSH) {
                _tr_align(s1);
            } else if (flush !== STATUS.Z_BLOCK) {
                _tr_stored_block(s1, 0, 0, false);
                if (flush === STATUS.Z_FULL_FLUSH) {
                    zero1(s1.head);
                    if (s1.lookahead === 0) {
                        s1.strstart = 0;
                        s1.block_start = 0;
                        s1.insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s1.last_flush = -1;
                return STATUS.Z_OK;
            }
        }
    }
    if (flush !== STATUS.Z_FINISH) return STATUS.Z_OK;
    if (s1.wrap <= 0) return STATUS.Z_STREAM_END;
    if (s1.wrap === 2) {
        put_byte(s1, strm.adler & 255);
        put_byte(s1, strm.adler >> 8 & 255);
        put_byte(s1, strm.adler >> 16 & 255);
        put_byte(s1, strm.adler >> 24 & 255);
        put_byte(s1, strm.total_in & 255);
        put_byte(s1, strm.total_in >> 8 & 255);
        put_byte(s1, strm.total_in >> 16 & 255);
        put_byte(s1, strm.total_in >> 24 & 255);
    } else {
        putShortMSB(s1, strm.adler >>> 16);
        putShortMSB(s1, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s1.wrap > 0) s1.wrap = -s1.wrap;
    return s1.pending !== 0 ? 0 : 1;
}
function deflateEnd(strm) {
    let status;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== 42 && status !== 69 && status !== 73 && status !== 91 && status !== 103 && status !== 113 && status !== 666) {
        return err1(strm, STATUS.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === 113 ? err1(strm, STATUS.Z_DATA_ERROR) : 0;
}
function deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    let s1;
    let str3, n;
    let wrap;
    let avail;
    let next;
    let input5;
    let tmpDict;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
    }
    s1 = strm.state;
    wrap = s1.wrap;
    if (wrap === 2 || wrap === 1 && s1.status !== 42 || s1.lookahead) {
        return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s1.wrap = 0;
    if (dictLength >= s1.w_size) {
        if (wrap === 0) {
            zero1(s1.head);
            s1.strstart = 0;
            s1.block_start = 0;
            s1.insert = 0;
        }
        tmpDict = new Uint8Array(s1.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s1.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s1.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input5 = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s1);
    while(s1.lookahead >= 3){
        str3 = s1.strstart;
        n = s1.lookahead - (MIN_MATCH - 1);
        do {
            s1.ins_h = (s1.ins_h << s1.hash_shift ^ s1.window[str3 + MIN_MATCH - 1]) & s1.hash_mask;
            s1.prev[str3 & s1.w_mask] = s1.head[s1.ins_h];
            s1.head[s1.ins_h] = str3;
            str3++;
        }while (--n)
        s1.strstart = str3;
        s1.lookahead = MIN_MATCH - 1;
        fill_window(s1);
    }
    s1.strstart += s1.lookahead;
    s1.block_start = s1.strstart;
    s1.insert = s1.lookahead;
    s1.lookahead = 0;
    s1.match_length = s1.prev_length = MIN_MATCH - 1;
    s1.match_available = 0;
    strm.next_in = next;
    strm.input = input5;
    strm.avail_in = avail;
    s1.wrap = wrap;
    return 0;
}
function concatUint8Array(arr) {
    const length = arr.reduce((pre, next)=>pre + next.length
    , 0);
    const result = new Uint8Array(length);
    let offset = 0;
    for (const v of arr){
        result.set(v, offset);
        offset += v.length;
    }
    return result;
}
class ZStream {
    input = null;
    next_in = 0;
    avail_in = 0;
    total_in = 0;
    output = null;
    next_out = 0;
    avail_out = 0;
    total_out = 0;
    msg = "";
    state = null;
    data_type = 2;
    adler = 0;
}
class Deflate {
    err = 0;
    msg = "";
    ended = false;
    strm;
    _dict_set = false;
    options;
    constructor(options1 = {
    }){
        this.options = Object.assign({
            level: STATUS.Z_DEFAULT_COMPRESSION,
            method: STATUS.Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: STATUS.Z_DEFAULT_STRATEGY,
            to: ""
        }, options1);
        const opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
        }
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status2 = deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status2 !== STATUS.Z_OK) {
            throw new Error(message14[status2]);
        }
        if (opt.header) {
            deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
            status2 = deflateSetDictionary(this.strm, opt.dictionary);
            if (status2 !== STATUS.Z_OK) {
                throw new Error(message14[status2]);
            }
            this._dict_set = true;
        }
    }
    push(data, mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const chunks = [];
        let status1;
        if (this.ended) {
            throw new Error("can not call after ended");
        }
        const _mode = mode === ~~mode ? mode : mode === true ? STATUS.Z_FINISH : STATUS.Z_NO_FLUSH;
        strm.input = data;
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status1 = deflate1(strm, _mode);
            if (status1 !== STATUS.Z_STREAM_END && status1 !== STATUS.Z_OK) {
                this.ended = true;
                throw new Error(this.strm.msg);
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === STATUS.Z_FINISH || _mode === STATUS.Z_SYNC_FLUSH)) {
                chunks.push(strm.output.subarray(0, strm.next_out));
            }
        }while ((strm.avail_in > 0 || strm.avail_out === 0) && status1 !== STATUS.Z_STREAM_END)
        if (_mode === STATUS.Z_FINISH) {
            status1 = deflateEnd(this.strm);
            this.ended = true;
            if (status1 !== STATUS.Z_OK) throw new Error(this.strm.msg);
        }
        if (_mode === STATUS.Z_SYNC_FLUSH) {
            strm.avail_out = 0;
        }
        return concatUint8Array(chunks);
    }
}
const BAD = 30;
const TYPE = 12;
function inflate_fast(strm, start) {
    let state;
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input5, output;
    state = strm.state;
    _in = strm.next_in;
    input5 = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
        if (bits < 15) {
            hold += input5[_in++] << bits;
            bits += 8;
            hold += input5[_in++] << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for(;;){
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
                output[_out++] = here & 65535;
            } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                    if (bits < op) {
                        hold += input5[_in++] << bits;
                        bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                }
                if (bits < 15) {
                    hold += input5[_in++] << bits;
                    bits += 8;
                    hold += input5[_in++] << bits;
                    bits += 8;
                }
                here = dcode[hold & dmask];
                dodist: for(;;){
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                            hold += input5[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                                hold += input5[_in++] << bits;
                                bits += 8;
                            }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                                if (state.sane) {
                                    strm.msg = "invalid distance too far back";
                                    state.mode = BAD;
                                    break top;
                                }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = 0;
                                    if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op)
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                            } else {
                                from += wnext - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            }
                            while(len > 2){
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                            }
                            if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) {
                                    output[_out++] = from_source[from++];
                                }
                            }
                        } else {
                            from = _out - dist;
                            do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                            }while (len > 2)
                            if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) {
                                    output[_out++] = output[from++];
                                }
                            }
                        }
                    } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                    } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                    }
                    break;
                }
            } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
            } else if (op & 32) {
                state.mode = TYPE;
                break top;
            } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
            }
            break;
        }
    }while (_in < last && _out < end)
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
}
const MAXBITS = 15;
const lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0, 
];
const lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78, 
];
const dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0, 
];
const dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64, 
];
function inflate_table(type4, lens, lens_index, codes, table, table_index, work, opts) {
    let bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min1 = 0, max1 = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base = null;
    let base_index = 0;
    let end;
    let count = new Uint16Array(15 + 1);
    let offs = new Uint16Array(15 + 1);
    let extra = null;
    let extra_index = 0;
    let here_bits, here_op, here_val;
    for(len = 0; len <= 15; len++){
        count[len] = 0;
    }
    for(sym = 0; sym < codes; sym++){
        count[lens[lens_index + sym]]++;
    }
    root = bits;
    for(max1 = MAXBITS; max1 >= 1; max1--){
        if (count[max1] !== 0) break;
    }
    if (root > max1) {
        root = max1;
    }
    if (max1 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
    }
    for(min1 = 1; min1 < max1; min1++){
        if (count[min1] !== 0) break;
    }
    if (root < min1) {
        root = min1;
    }
    left = 1;
    for(len = 1; len <= 15; len++){
        left <<= 1;
        left -= count[len];
        if (left < 0) {
            return -1;
        }
    }
    if (left > 0 && (type4 === 0 || max1 !== 1)) {
        return -1;
    }
    offs[1] = 0;
    for(len = 1; len < 15; len++){
        offs[len + 1] = offs[len] + count[len];
    }
    for(sym = 0; sym < codes; sym++){
        if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
        }
    }
    if (type4 === 0) {
        base = extra = work;
        end = 19;
    } else if (type4 === 1) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
    } else {
        base = dbase;
        extra = dext;
        end = -1;
    }
    huff = 0;
    sym = 0;
    len = min1;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type4 === 1 && used > 852 || type4 === 2 && used > 592) {
        return 1;
    }
    for(;;){
        here_bits = len - drop;
        if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
        } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
        } else {
            here_op = 32 + 64;
            here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min1 = fill;
        do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        }while (fill !== 0)
        incr = 1 << len - 1;
        while(huff & incr){
            incr >>= 1;
        }
        if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
        } else {
            huff = 0;
        }
        sym++;
        if ((--count[len]) === 0) {
            if (len === max1) break;
            len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
                drop = root;
            }
            next += min1;
            curr = len - drop;
            left = 1 << curr;
            while(curr + drop < max1){
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }
            used += 1 << curr;
            if (type4 === 1 && used > 852 || type4 === 2 && used > 592) {
                return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
}
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_STREAM_ERROR1 = -2;
const Z_DATA_ERROR = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR = -5;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA1 = 6;
const NAME = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE1 = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD1 = 30;
const MEM = 31;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
class InflateState {
    mode = 0;
    last = false;
    wrap = 0;
    havedict = false;
    flags = 0;
    dmax = 0;
    check = 0;
    total = 0;
    head = null;
    wbits = 0;
    wsize = 0;
    whave = 0;
    wnext = 0;
    window = null;
    hold = 0;
    bits = 0;
    length = 0;
    offset = 0;
    extra = 0;
    lencode = null;
    distcode = null;
    lenbits = 0;
    distbits = 0;
    ncode = 0;
    nlen = 0;
    ndist = 0;
    have = 0;
    next = null;
    lens = new Uint16Array(320);
    work = new Uint16Array(288);
    lendyn = null;
    distdyn = null;
    sane = 0;
    back = 0;
    was = 0;
}
function inflateResetKeep(strm) {
    let state;
    if (!strm || !strm.state) return Z_STREAM_ERROR1;
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
        strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Uint32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Uint32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return 0;
}
function inflateReset(strm) {
    let state;
    if (!strm || !strm.state) return Z_STREAM_ERROR1;
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
    let wrap;
    let state;
    if (!strm || !strm.state) return Z_STREAM_ERROR1;
    state = strm.state;
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
            windowBits &= 15;
        }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
    let ret1;
    let state;
    if (!strm) return Z_STREAM_ERROR1;
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret1 = inflateReset2(strm, windowBits);
    if (ret1 !== 0) {
        strm.state = null;
    }
    return ret1;
}
let virgin = true;
let lenfix, distfix;
function fixedtables(state) {
    if (virgin) {
        let sym;
        lenfix = new Uint32Array(512);
        distfix = new Uint32Array(32);
        sym = 0;
        while(sym < 144)state.lens[sym++] = 8;
        while(sym < 256)state.lens[sym++] = 9;
        while(sym < 280)state.lens[sym++] = 7;
        while(sym < 288)state.lens[sym++] = 8;
        inflate_table(1, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
        });
        sym = 0;
        while(sym < 32)state.lens[sym++] = 5;
        inflate_table(2, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
        });
        virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
}
function updatewindow(strm, src, end, copy1) {
    let dist;
    let state = strm.state;
    if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
    }
    if (copy1 >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
    } else {
        dist = state.wsize - state.wnext;
        if (dist > copy1) {
            dist = copy1;
        }
        state.window.set(src.subarray(end - copy1, end - copy1 + dist), state.wnext);
        copy1 -= dist;
        if (copy1) {
            state.window.set(src.subarray(end - copy1, end), 0);
            state.wnext = copy1;
            state.whave = state.wsize;
        } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) state.wnext = 0;
            if (state.whave < state.wsize) state.whave += dist;
        }
    }
    return 0;
}
function inflate1(strm, flush) {
    let state;
    let input5, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy1;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret1;
    let hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = [
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR1;
    }
    state = strm.state;
    if (state.mode === 12) state.mode = TYPEDO;
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input5 = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret1 = Z_OK;
    inf_leave: for(;;){
        switch(state.mode){
            case 1:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                state.flags = 0;
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD1;
                    break;
                }
                if ((hold & 15) !== 8) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD1;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD1;
                    break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE1;
                hold = 0;
                bits = 0;
                break;
            case 2:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== 8) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD1;
                    break;
                }
                if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD1;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
            case 3:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
            case 4:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
            case 5:
                if (state.flags & 1024) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA1;
            case 6:
                if (state.flags & 1024) {
                    copy1 = state.length;
                    if (copy1 > have) copy1 = have;
                    if (copy1) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Array(state.head.extra_len);
                            }
                            state.head.extra.set(input5.subarray(next, next + copy1), len);
                        }
                        if (state.flags & 512) {
                            state.check = crc32(state.check, input5, copy1, next);
                        }
                        have -= copy1;
                        next += copy1;
                        state.length -= copy1;
                    }
                    if (state.length) break inf_leave;
                }
                state.length = 0;
                state.mode = NAME;
            case 7:
                if (state.flags & 2048) {
                    if (have === 0) break inf_leave;
                    copy1 = 0;
                    do {
                        len = input5[next + copy1++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    }while (len && copy1 < have)
                    if (state.flags & 512) {
                        state.check = crc32(state.check, input5, copy1, next);
                    }
                    have -= copy1;
                    next += copy1;
                    if (len) break inf_leave;
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
            case 8:
                if (state.flags & 4096) {
                    if (have === 0) break inf_leave;
                    copy1 = 0;
                    do {
                        len = input5[next + copy1++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    }while (len && copy1 < have)
                    if (state.flags & 512) {
                        state.check = crc32(state.check, input5, copy1, next);
                    }
                    have -= copy1;
                    next += copy1;
                    if (len) break inf_leave;
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;
            case 9:
                if (state.flags & 512) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD1;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE1;
                break;
            case 10:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
            case 11:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return 2;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE1;
            case 12:
                if (flush === 5 || flush === 6) break inf_leave;
            case 13:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while(bits < 3){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch(hold & 3){
                    case 0:
                        state.mode = STORED;
                        break;
                    case 1:
                        fixedtables(state);
                        state.mode = LEN_;
                        if (flush === 6) {
                            hold >>>= 2;
                            bits -= 2;
                            break inf_leave;
                        }
                        break;
                    case 2:
                        state.mode = TABLE;
                        break;
                    case 3:
                        strm.msg = "invalid block type";
                        state.mode = BAD1;
                }
                hold >>>= 2;
                bits -= 2;
                break;
            case 14:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD1;
                    break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === 6) break inf_leave;
            case 15:
                state.mode = COPY;
            case 16:
                copy1 = state.length;
                if (copy1) {
                    if (copy1 > have) copy1 = have;
                    if (copy1 > left) copy1 = left;
                    if (copy1 === 0) break inf_leave;
                    output.set(input5.subarray(next, next + copy1), put);
                    have -= copy1;
                    next += copy1;
                    left -= copy1;
                    put += copy1;
                    state.length -= copy1;
                    break;
                }
                state.mode = TYPE1;
                break;
            case 17:
                while(bits < 14){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD1;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;
            case 18:
                while(state.have < state.ncode){
                    while(bits < 3){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                }
                while(state.have < 19){
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret1 = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret1) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD1;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;
            case 19:
                while(state.have < state.nlen + state.ndist){
                    for(;;){
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input5[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD1;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy1 = 3 + (hold & 3);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input5[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy1 = 3 + (hold & 7);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input5[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy1 = 11 + (hold & 127);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy1 > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD1;
                            break;
                        }
                        while(copy1--){
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === 30) break;
                if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD1;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret1 = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret1) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD1;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret1 = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret1) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD1;
                    break;
                }
                state.mode = LEN_;
                if (flush === 6) break inf_leave;
            case 20:
                state.mode = LEN;
            case 21:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input5 = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === 12) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for(;;){
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE1;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD1;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
            case 22:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
            case 23:
                for(;;){
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input5[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD1;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
            case 24:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD1;
                    break;
                }
                state.mode = MATCH;
            case 25:
                if (left === 0) break inf_leave;
                copy1 = _out - left;
                if (state.offset > copy1) {
                    copy1 = state.offset - copy1;
                    if (copy1 > state.whave) {
                        if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD1;
                            break;
                        }
                    }
                    if (copy1 > state.wnext) {
                        copy1 -= state.wnext;
                        from = state.wsize - copy1;
                    } else {
                        from = state.wnext - copy1;
                    }
                    if (copy1 > state.length) copy1 = state.length;
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy1 = state.length;
                }
                if (copy1 > left) copy1 = left;
                left -= copy1;
                state.length -= copy1;
                do {
                    output[put++] = from_source[from++];
                }while (--copy1)
                if (state.length === 0) state.mode = LEN;
                break;
            case 26:
                if (left === 0) break inf_leave;
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
            case 27:
                if (state.wrap) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold |= input5[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD1;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;
            case 28:
                if (state.wrap && state.flags) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input5[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD1;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;
            case 29:
                ret1 = Z_STREAM_END;
                break inf_leave;
            case 30:
                ret1 = Z_DATA_ERROR;
                break inf_leave;
            case 31:
                return Z_MEM_ERROR;
            case 32:
            default:
                return Z_STREAM_ERROR1;
        }
    }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < 30 && (state.mode < 27 || flush !== 4)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
        }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === 4) && ret1 === 0) {
        ret1 = Z_BUF_ERROR;
    }
    return ret1;
}
function inflateEnd(strm) {
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR1;
    }
    let state = strm.state;
    if (state.window) {
        state.window = null;
    }
    strm.state = null;
    return 0;
}
function inflateGetHeader(strm, head) {
    let state;
    if (!strm || !strm.state) return Z_STREAM_ERROR1;
    state = strm.state;
    if ((state.wrap & 2) === 0) return Z_STREAM_ERROR1;
    state.head = head;
    head.done = false;
    return 0;
}
function inflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    let state;
    let dictid;
    let ret1;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== 11) {
        return Z_STREAM_ERROR1;
    }
    if (state.mode === 11) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
            return Z_DATA_ERROR;
        }
    }
    ret1 = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret1) {
        state.mode = MEM;
        return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return 0;
}
class GZheader {
    text = 0;
    time = 0;
    xflags = 0;
    os = 0;
    extra = null;
    extra_len = 0;
    name = "";
    comment = "";
    hcrc = 0;
    done = false;
}
class Inflate {
    err = 0;
    msg = "";
    ended = false;
    strm;
    options;
    header;
    constructor(options2){
        this.options = {
            chunkSize: 16384,
            windowBits: 0,
            to: "",
            ...options2
        };
        const opt1 = this.options;
        if (opt1.raw && opt1.windowBits >= 0 && opt1.windowBits < 16) {
            opt1.windowBits = -opt1.windowBits;
            if (opt1.windowBits === 0) opt1.windowBits = -15;
        }
        if (opt1.windowBits >= 0 && opt1.windowBits < 16 && !(options2 && options2.windowBits)) {
            opt1.windowBits += 32;
        }
        if (opt1.windowBits > 15 && opt1.windowBits < 48) {
            if ((opt1.windowBits & 15) === 0) {
                opt1.windowBits |= 15;
            }
        }
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status1 = inflateInit2(this.strm, opt1.windowBits);
        if (status1 !== STATUS.Z_OK) {
            throw new Error(message14[status1]);
        }
        this.header = new GZheader();
        inflateGetHeader(this.strm, this.header);
        if (opt1.dictionary) {
            if (opt1.raw) {
                status1 = inflateSetDictionary(this.strm, opt1.dictionary);
                if (status1 !== STATUS.Z_OK) {
                    throw new Error(message14[status1]);
                }
            }
        }
    }
    push(data, mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        const chunks = [];
        let status2;
        var allowBufError = false;
        if (this.ended) {
            throw new Error("can not call after ended");
        }
        let _mode = mode === ~~mode ? mode : mode === true ? STATUS.Z_FINISH : STATUS.Z_NO_FLUSH;
        strm.input = data;
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status2 = inflate1(strm, STATUS.Z_NO_FLUSH);
            if (status2 === STATUS.Z_NEED_DICT && dictionary) {
                status2 = inflateSetDictionary(this.strm, dictionary);
            }
            if (status2 === STATUS.Z_BUF_ERROR && allowBufError === true) {
                status2 = STATUS.Z_OK;
                allowBufError = false;
            }
            if (status2 !== STATUS.Z_STREAM_END && status2 !== STATUS.Z_OK) {
                this.ended = true;
                throw new Error(this.strm.msg);
            }
            if (strm.next_out) {
                if (strm.avail_out === 0 || status2 === STATUS.Z_STREAM_END || strm.avail_in === 0 && (_mode === STATUS.Z_FINISH || _mode === STATUS.Z_SYNC_FLUSH)) {
                    chunks.push(strm.output.subarray(0, strm.next_out));
                }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true;
            }
        }while ((strm.avail_in > 0 || strm.avail_out === 0) && status2 !== STATUS.Z_STREAM_END)
        if (status2 === STATUS.Z_STREAM_END) {
            _mode = STATUS.Z_FINISH;
        }
        if (_mode === STATUS.Z_FINISH) {
            status2 = inflateEnd(this.strm);
            this.ended = true;
            if (status2 !== STATUS.Z_OK) throw new Error(this.strm.msg);
        }
        if (_mode === STATUS.Z_SYNC_FLUSH) {
            strm.avail_out = 0;
        }
        return concatUint8Array(chunks);
    }
}
const compressionMethods = {
    "deflate": 8
};
const possibleFlags = {
    "FTEXT": 1,
    "FHCRC": 2,
    "FEXTRA": 4,
    "FNAME": 8,
    "FCOMMENT": 16
};
const os2 = {
    "darwin": 3,
    "linux": 3,
    "windows": 0
};
const osCode = os2[Deno.build.os] ?? 255;
function putByte(n, arr) {
    arr.push(n & 255);
}
function putShort(n, arr) {
    arr.push(n & 255);
    arr.push(n >>> 8);
}
function putLong(n, arr) {
    putShort(n & 65535, arr);
    putShort(n >>> 16, arr);
}
function putString(s1, arr) {
    for(let i2 = 0, len = s1.length; i2 < len; i2 += 1){
        putByte(s1.charCodeAt(i2), arr);
    }
}
function readByte(arr) {
    return arr.shift();
}
function readShort(arr) {
    return arr.shift() | arr.shift() << 8;
}
function readLong(arr) {
    let n1 = readShort(arr);
    let n2 = readShort(arr);
    if (n2 > 32768) {
        n2 -= 32768;
        return (n2 << 16 | n1) + 32768 * Math.pow(2, 16);
    }
    return n2 << 16 | n1;
}
function readString(arr) {
    const charArr = [];
    while(arr[0] !== 0){
        charArr.push(String.fromCharCode(arr.shift()));
    }
    arr.shift();
    return charArr.join("");
}
function readBytes(arr, n) {
    const ret1 = [];
    for(let i2 = 0; i2 < n; i2 += 1){
        ret1.push(arr.shift());
    }
    return ret1;
}
function getHeader(options3 = {
}) {
    let flags = 0;
    let level = options3.level ?? 6;
    const out = [];
    putByte(31, out);
    putByte(139, out);
    putByte(compressionMethods["deflate"], out);
    if (options3.name) {
        flags |= possibleFlags["FNAME"];
    }
    putByte(flags, out);
    putLong(options3.timestamp ?? Math.floor(Date.now() / 1000), out);
    if (level === 1) {
        putByte(4, out);
    } else if (level === 9) {
        putByte(2, out);
    } else {
        putByte(0, out);
    }
    putByte(osCode, out);
    if (options3.name) {
        putString(options3.name.substring(options3.name.lastIndexOf("/") + 1), out);
        putByte(0, out);
    }
    return new Uint8Array(out);
}
function checkHeader(arr) {
    if (readByte(arr) !== 31 || readByte(arr) !== 139) {
        throw "Not a GZIP file";
    }
    if (readByte(arr) !== 8) {
        throw "Unsupported compression method";
    }
    let flags = readByte(arr);
    readLong(arr);
    readByte(arr);
    readByte(arr);
    if (flags & possibleFlags["FEXTRA"]) {
        let t = readShort(arr);
        readBytes(arr, t);
    }
    if (flags & possibleFlags["FNAME"]) {
        readString(arr);
    }
    if (flags & possibleFlags["FCOMMENT"]) {
        readString(arr);
    }
    if (flags & possibleFlags["FHCRC"]) {
        readShort(arr);
    }
}
function checkTail(arr) {
    const tail = arr.splice(arr.length - 8);
    let crc321 = readLong(tail) >>> 0;
    let size10 = readLong(tail);
    return {
        crc32: crc321,
        size: size10
    };
}
class Writer extends EventEmitter1 {
    writer;
    bytesWritten = 0;
    path;
    chuncks = [];
    onceSize;
    chuncksBytes = 0;
    crc32Stream = new Crc32Stream();
    deflate = new Deflate({
        raw: true
    });
    constructor(path5, options3){
        super();
        this.path = path5;
        this.onceSize = options3?.onceSize ?? 1024 * 1024;
    }
    async setup(name, timestamp) {
        this.writer = await Deno.open(this.path, {
            write: true,
            create: true,
            truncate: true
        });
        const headers3 = getHeader({
            timestamp,
            name
        });
        await Deno.write(this.writer.rid, headers3);
    }
    async write(p) {
        const readed = p.byteLength;
        const copy1 = new Uint8Array(p);
        this.chuncks.push(copy1);
        this.chuncksBytes += readed;
        this.bytesWritten += readed;
        this.crc32Stream.append(copy1);
        if (readed < 16384) {
            const buf = concatUint8Array(this.chuncks);
            const compressed = this.deflate.push(buf, true);
            await Deno.writeAll(this.writer, compressed);
            const tail = this.getTail();
            await Deno.write(this.writer.rid, tail);
        } else if (this.chuncksBytes >= this.onceSize) {
            const buf = concatUint8Array(this.chuncks);
            const compressed = this.deflate.push(buf, false);
            await Deno.writeAll(this.writer, compressed);
            this.chuncks.length = 0;
            this.chuncksBytes = 0;
            this.emit("bytesWritten", this.bytesWritten);
        }
        return readed;
    }
    close() {
        this.emit("bytesWritten", this.bytesWritten);
        Deno.close(this.writer.rid);
    }
    getTail() {
        const arr = [];
        putLong(parseInt(this.crc32Stream.crc32, 16), arr);
        putLong(this.bytesWritten, arr);
        return new Uint8Array(arr);
    }
}
class Writer1 extends EventEmitter1 {
    writer;
    bytesWritten = 0;
    path;
    chuncks = [];
    onceSize;
    chuncksBytes = 0;
    isCheckHeader = false;
    writtenSize = 0;
    crc32Stream = new Crc32Stream();
    inflate = new Inflate({
        raw: true
    });
    constructor(path6, options4){
        super();
        this.path = path6;
        this.onceSize = options4?.onceSize ?? 1024 * 1024;
    }
    async setup() {
        this.writer = await Deno.open(this.path, {
            write: true,
            create: true,
            truncate: true
        });
    }
    async write(p) {
        const readed = p.byteLength;
        this.chuncksBytes += readed;
        this.bytesWritten += readed;
        const arr = Array.from(p);
        if (!this.isCheckHeader) {
            this.isCheckHeader = true;
            checkHeader(arr);
        }
        if (readed < 16384) {
            const { size: size10 , crc32: crc321  } = checkTail(arr);
            this.chuncks.push(new Uint8Array(arr));
            const buf = concatUint8Array(this.chuncks);
            const decompressed = this.inflate.push(buf, true);
            this.writtenSize += decompressed.byteLength;
            await Deno.writeAll(this.writer, decompressed);
            this.crc32Stream.append(decompressed);
            if (crc321 !== parseInt(this.crc32Stream.crc32, 16)) {
                throw "Checksum does not match";
            }
            if (size10 !== this.writtenSize) {
                throw "Size of decompressed file not correct";
            }
            return readed;
        }
        this.chuncks.push(new Uint8Array(arr));
        if (this.chuncksBytes >= this.onceSize) {
            const buf = concatUint8Array(this.chuncks);
            const decompressed = this.inflate.push(buf, false);
            this.writtenSize += decompressed.byteLength;
            await Deno.writeAll(this.writer, decompressed);
            this.crc32Stream.append(decompressed);
            this.chuncks.length = 0;
            this.chuncksBytes = 0;
            this.emit("bytesWritten", this.bytesWritten);
        }
        return readed;
    }
    close() {
        this.emit("bytesWritten", this.bytesWritten);
        Deno.close(this.writer.rid);
    }
}
class GzipStream extends EventEmitter1 {
    constructor(){
        super();
    }
    async compress(src, dest) {
        const stat = await Deno.stat(src);
        const size10 = stat.size;
        const reader4 = await Deno.open(src, {
            read: true
        });
        const writer7 = new Writer(dest, {
            onceSize: size10 > 50 * 1024 * 1024 ? 1024 * 1024 : 512 * 1024
        });
        await writer7.setup(src, stat.mtime ? Math.round(stat.mtime.getTime() / 1000) : 0);
        writer7.on("bytesWritten", (bytesWritten)=>{
            const progress = (100 * bytesWritten / size10).toFixed(2) + "%";
            this.emit("progress", progress);
        });
        await Deno.copy(reader4, writer7, {
            bufSize: 1024 * 1024
        });
        writer7.close();
        reader4.close();
    }
    async uncompress(src, dest) {
        const size10 = (await Deno.stat(src)).size;
        const reader4 = await Deno.open(src, {
            read: true
        });
        const writer7 = new Writer1(dest, {
            onceSize: size10 > 50 * 1024 * 1024 ? 1024 * 1024 : 512 * 1024
        });
        await writer7.setup();
        writer7.on("bytesWritten", (bytesWritten)=>{
            const progress = (100 * bytesWritten / size10).toFixed(2) + "%";
            this.emit("progress", progress);
        });
        await Deno.copy(reader4, writer7, {
            bufSize: 1024 * 1024
        });
        writer7.close();
        reader4.close();
    }
}
var v = Object.create, d = Object.defineProperty, l = Object.getPrototypeOf, m = Object.prototype.hasOwnProperty, c = Object.getOwnPropertyNames, h = Object.getOwnPropertyDescriptor;
var N = (t)=>d(t, "__esModule", {
        value: !0
    })
;
var y19 = (t, r3)=>()=>(r3 || t((r3 = {
            exports: {
            }
        }).exports, r3), r3.exports)
;
var g = (t, r3, i2)=>{
    if (r3 && typeof r3 == "object" || typeof r3 == "function") for (let e of c(r3))!m.call(t, e) && e !== "default" && d(t, e, {
        get: ()=>r3[e]
        ,
        enumerable: !(i2 = h(r3, e)) || i2.enumerable
    });
    return t;
}, I = (t)=>g(N(d(t != null ? v(l(t)) : {
    }, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default
        ,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t)
;
var x87 = y19((P, p)=>{
    "use strict";
    p.exports = b;
    function b(t, r3, i2) {
        if (typeof r3 != "string") throw new TypeError("argument str must be a string");
        var e = r3.indexOf("=");
        if (e === -1) return -2;
        var o = r3.slice(e + 1).split(","), n = [];
        n.type = r3.slice(0, e);
        for(var s1 = 0; s1 < o.length; s1++){
            var u = o[s1].split("-"), f = parseInt(u[0], 10), a = parseInt(u[1], 10);
            isNaN(f) ? (f = t - a, a = t - 1) : isNaN(a) && (a = t - 1), a > t - 1 && (a = t - 1), !(isNaN(f) || isNaN(a) || f > a || f < 0) && n.push({
                start: f,
                end: a
            });
        }
        return n.length < 1 ? -1 : i2 && i2.combine ? R(n) : n;
    }
    function R(t) {
        for(var r3 = t.map(w).sort(E), i2 = 0, e = 1; e < r3.length; e++){
            var o = r3[e], n = r3[i2];
            o.start > n.end + 1 ? r3[++i2] = o : o.end > n.end && (n.end = o.end, n.index = Math.min(n.index, o.index));
        }
        r3.length = i2 + 1;
        var s1 = r3.sort(W).map(B);
        return s1.type = t.type, s1;
    }
    function w(t, r3) {
        return {
            start: t.start,
            end: t.end,
            index: r3
        };
    }
    function B(t) {
        return {
            start: t.start,
            end: t.end
        };
    }
    function W(t, r3) {
        return t.index - r3.index;
    }
    function E(t, r3) {
        return t.start - r3.start;
    }
});
var M = I(x87());
var export_default = M.default;
var Z = Object.create, A2 = Object.defineProperty, ee = Object.getPrototypeOf, re = Object.prototype.hasOwnProperty, te = Object.getOwnPropertyNames, ne = Object.getOwnPropertyDescriptor;
var ie = (n)=>A2(n, "__esModule", {
        value: !0
    })
;
var O = (n, e)=>()=>(e || n((e = {
            exports: {
            }
        }).exports, e), e.exports)
;
var ae = (n, e, r3)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of te(e))!re.call(n, t) && t !== "default" && A2(n, t, {
        get: ()=>e[t]
        ,
        enumerable: !(r3 = ne(e, t)) || r3.enumerable
    });
    return n;
}, R = (n)=>ae(ie(A2(n != null ? Z(ee(n)) : {
    }, "default", n && n.__esModule && "default" in n ? {
        get: ()=>n.default
        ,
        enumerable: !0
    } : {
        value: n,
        enumerable: !0
    })), n)
;
var N1 = O((qe, q)=>{
    "use strict";
    var C = Object.prototype.hasOwnProperty, b = Array.isArray, v1 = function() {
        for(var n = [], e = 0; e < 256; ++e)n.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return n;
    }(), fe = function(e) {
        for(; e.length > 1;){
            var r3 = e.pop(), t = r3.obj[r3.prop];
            if (b(t)) {
                for(var a = [], f = 0; f < t.length; ++f)typeof t[f] != "undefined" && a.push(t[f]);
                r3.obj[r3.prop] = a;
            }
        }
    }, V = function(e, r4) {
        for(var t = r4 && r4.plainObjects ? Object.create(null) : {
        }, a = 0; a < e.length; ++a)typeof e[a] != "undefined" && (t[a] = e[a]);
        return t;
    }, le = function n(e, r4, t) {
        if (!r4) return e;
        if (typeof r4 != "object") {
            if (b(e)) e.push(r4);
            else if (e && typeof e == "object") (t && (t.plainObjects || t.allowPrototypes) || !C.call(Object.prototype, r4)) && (e[r4] = !0);
            else return [
                e,
                r4
            ];
            return e;
        }
        if (!e || typeof e != "object") return [
            e
        ].concat(r4);
        var a = e;
        return b(e) && !b(r4) && (a = V(e, t)), b(e) && b(r4) ? (r4.forEach(function(f, l1) {
            if (C.call(e, l1)) {
                var i2 = e[l1];
                i2 && typeof i2 == "object" && f && typeof f == "object" ? e[l1] = n(i2, f, t) : e.push(f);
            } else e[l1] = f;
        }), e) : Object.keys(r4).reduce(function(f, l1) {
            var i3 = r4[l1];
            return C.call(f, l1) ? f[l1] = n(f[l1], i3, t) : f[l1] = i3, f;
        }, a);
    }, ue = function(e, r4) {
        return Object.keys(r4).reduce(function(t, a) {
            return t[a] = r4[a], t;
        }, e);
    }, oe = function(n1, e, r4) {
        var t = n1.replace(/\+/g, " ");
        if (r4 === "iso-8859-1") return t.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(t);
        } catch (a) {
            return t;
        }
    }, ce = function(e, r4, t) {
        if (e.length === 0) return e;
        var a = e;
        if (typeof e == "symbol" ? a = Symbol.prototype.toString.call(e) : typeof e != "string" && (a = String(e)), t === "iso-8859-1") return escape(a).replace(/%u[0-9a-f]{4}/gi, function(u) {
            return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
        });
        for(var f = "", l1 = 0; l1 < a.length; ++l1){
            var i3 = a.charCodeAt(l1);
            if (i3 === 45 || i3 === 46 || i3 === 95 || i3 === 126 || i3 >= 48 && i3 <= 57 || i3 >= 65 && i3 <= 90 || i3 >= 97 && i3 <= 122) {
                f += a.charAt(l1);
                continue;
            }
            if (i3 < 128) {
                f = f + v1[i3];
                continue;
            }
            if (i3 < 2048) {
                f = f + (v1[192 | i3 >> 6] + v1[128 | i3 & 63]);
                continue;
            }
            if (i3 < 55296 || i3 >= 57344) {
                f = f + (v1[224 | i3 >> 12] + v1[128 | i3 >> 6 & 63] + v1[128 | i3 & 63]);
                continue;
            }
            l1 += 1, i3 = 65536 + ((i3 & 1023) << 10 | a.charCodeAt(l1) & 1023), f += v1[240 | i3 >> 18] + v1[128 | i3 >> 12 & 63] + v1[128 | i3 >> 6 & 63] + v1[128 | i3 & 63];
        }
        return f;
    }, se = function(e) {
        for(var r4 = [
            {
                obj: {
                    o: e
                },
                prop: "o"
            }
        ], t = [], a = 0; a < r4.length; ++a)for(var f = r4[a], l1 = f.obj[f.prop], i4 = Object.keys(l1), u = 0; u < i4.length; ++u){
            var c1 = i4[u], s1 = l1[c1];
            typeof s1 == "object" && s1 !== null && t.indexOf(s1) === -1 && (r4.push({
                obj: l1,
                prop: c1
            }), t.push(s1));
        }
        return fe(r4), e;
    }, de = function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]";
    }, ye = function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
    }, pe = function(e, r4) {
        return [].concat(e, r4);
    }, me = function(e, r4) {
        if (b(e)) {
            for(var t = [], a = 0; a < e.length; a += 1)t.push(r4(e[a]));
            return t;
        }
        return r4(e);
    };
    q.exports = {
        arrayToObject: V,
        assign: ue,
        combine: pe,
        compact: se,
        decode: oe,
        encode: ce,
        isBuffer: ye,
        isRegExp: de,
        maybeMap: me,
        merge: le
    };
});
var Q = O((Ve, I1)=>{
    "use strict";
    var he = String.prototype.replace, ve = /%20/g, be = N1(), k = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    };
    I1.exports = be.assign({
        default: k.RFC3986,
        formatters: {
            RFC1738: function(n) {
                return he.call(n, ve, "+");
            },
            RFC3986: function(n) {
                return String(n);
            }
        }
    }, k);
});
var $ = O((Ie, M1)=>{
    "use strict";
    var T = N1(), j = Q(), ge = Object.prototype.hasOwnProperty, U = {
        brackets: function(e) {
            return e + "[]";
        },
        comma: "comma",
        indices: function(e, r4) {
            return e + "[" + r4 + "]";
        },
        repeat: function(e) {
            return e;
        }
    }, g1 = Array.isArray, xe = Array.prototype.push, K = function(n, e) {
        xe.apply(n, g1(e) ? e : [
            e
        ]);
    }, Oe = Date.prototype.toISOString, _ = j.default, y20 = {
        addQueryPrefix: !1,
        allowDots: !1,
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encoder: T.encode,
        encodeValuesOnly: !1,
        format: _,
        formatter: j.formatters[_],
        indices: !1,
        serializeDate: function(e) {
            return Oe.call(e);
        },
        skipNulls: !1,
        strictNullHandling: !1
    }, je = function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
    }, we = function n(e, r4, t, a, f, l1, i4, u, c2, s2, p, m1, h1) {
        var o = e;
        if (typeof i4 == "function" ? o = i4(r4, o) : o instanceof Date ? o = s2(o) : t === "comma" && g1(o) && (o = T.maybeMap(o, function(D) {
            return D instanceof Date ? s2(D) : D;
        }).join(",")), o === null) {
            if (a) return l1 && !m1 ? l1(r4, y20.encoder, h1, "key") : r4;
            o = "";
        }
        if (je(o) || T.isBuffer(o)) {
            if (l1) {
                var E = m1 ? r4 : l1(r4, y20.encoder, h1, "key");
                return [
                    p(E) + "=" + p(l1(o, y20.encoder, h1, "value"))
                ];
            }
            return [
                p(r4) + "=" + p(String(o))
            ];
        }
        var F = [];
        if (typeof o == "undefined") return F;
        var w;
        if (g1(i4)) w = i4;
        else {
            var z = Object.keys(o);
            w = u ? z.sort(u) : z;
        }
        for(var P = 0; P < w.length; ++P){
            var S = w[P], B = o[S];
            if (!(f && B === null)) {
                var Y = g1(o) ? typeof t == "function" ? t(r4, S) : r4 : r4 + (c2 ? "." + S : "[" + S + "]");
                K(F, n(B, Y, t, a, f, l1, i4, u, c2, s2, p, m1, h1));
            }
        }
        return F;
    }, Se = function(e) {
        if (!e) return y20;
        if (e.encoder !== null && e.encoder !== void 0 && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var r4 = e.charset || y20.charset;
        if (typeof e.charset != "undefined" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var t = j.default;
        if (typeof e.format != "undefined") {
            if (!ge.call(j.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            t = e.format;
        }
        var a = j.formatters[t], f = y20.filter;
        return (typeof e.filter == "function" || g1(e.filter)) && (f = e.filter), {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : y20.addQueryPrefix,
            allowDots: typeof e.allowDots == "undefined" ? y20.allowDots : !!e.allowDots,
            charset: r4,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : y20.charsetSentinel,
            delimiter: typeof e.delimiter == "undefined" ? y20.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : y20.encode,
            encoder: typeof e.encoder == "function" ? e.encoder : y20.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : y20.encodeValuesOnly,
            filter: f,
            formatter: a,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : y20.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : y20.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : y20.strictNullHandling
        };
    };
    M1.exports = function(n1, e) {
        var r4 = n1, t = Se(e), a, f;
        typeof t.filter == "function" ? (f = t.filter, r4 = f("", r4)) : g1(t.filter) && (f = t.filter, a = f);
        var l1 = [];
        if (typeof r4 != "object" || r4 === null) return "";
        var i4;
        e && e.arrayFormat in U ? i4 = e.arrayFormat : e && "indices" in e ? i4 = e.indices ? "indices" : "repeat" : i4 = "indices";
        var u = U[i4];
        a || (a = Object.keys(r4)), t.sort && a.sort(t.sort);
        for(var c2 = 0; c2 < a.length; ++c2){
            var s2 = a[c2];
            t.skipNulls && r4[s2] === null || K(l1, we(r4[s2], s2, u, t.strictNullHandling, t.skipNulls, t.encode ? t.encoder : null, t.filter, t.sort, t.allowDots, t.serializeDate, t.formatter, t.encodeValuesOnly, t.charset));
        }
        var p = l1.join(t.delimiter), m1 = t.addQueryPrefix === !0 ? "?" : "";
        return t.charsetSentinel && (t.charset === "iso-8859-1" ? m1 += "utf8=%26%2310003%3B&" : m1 += "utf8=%E2%9C%93&"), p.length > 0 ? m1 + p : "";
    };
});
var J = O((ke, G)=>{
    "use strict";
    var x88 = N1(), L = Object.prototype.hasOwnProperty, Ne = Array.isArray, d1 = {
        allowDots: !1,
        allowPrototypes: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decoder: x88.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1000,
        parseArrays: !0,
        plainObjects: !1,
        strictNullHandling: !1
    }, Ee = function(n) {
        return n.replace(/&#(\d+);/g, function(e, r4) {
            return String.fromCharCode(parseInt(r4, 10));
        });
    }, W = function(n, e) {
        return n && typeof n == "string" && e.comma && n.indexOf(",") > -1 ? n.split(",") : n;
    }, Fe = "utf8=%26%2310003%3B", Pe = "utf8=%E2%9C%93", De = function(e, r4) {
        var t = {
        }, a = r4.ignoreQueryPrefix ? e.replace(/^\?/, "") : e, f = r4.parameterLimit === Infinity ? void 0 : r4.parameterLimit, l1 = a.split(r4.delimiter, f), i4 = -1, u, c2 = r4.charset;
        if (r4.charsetSentinel) for(u = 0; u < l1.length; ++u)l1[u].indexOf("utf8=") === 0 && (l1[u] === Pe ? c2 = "utf-8" : l1[u] === Fe && (c2 = "iso-8859-1"), i4 = u, u = l1.length);
        for(u = 0; u < l1.length; ++u)if (u !== i4) {
            var s3 = l1[u], p = s3.indexOf("]="), m1 = p === -1 ? s3.indexOf("=") : p + 1, h1, o;
            m1 === -1 ? (h1 = r4.decoder(s3, d1.decoder, c2, "key"), o = r4.strictNullHandling ? null : "") : (h1 = r4.decoder(s3.slice(0, m1), d1.decoder, c2, "key"), o = x88.maybeMap(W(s3.slice(m1 + 1), r4), function(E) {
                return r4.decoder(E, d1.decoder, c2, "value");
            })), o && r4.interpretNumericEntities && c2 === "iso-8859-1" && (o = Ee(o)), s3.indexOf("[]=") > -1 && (o = Ne(o) ? [
                o
            ] : o), L.call(t, h1) ? t[h1] = x88.combine(t[h1], o) : t[h1] = o;
        }
        return t;
    }, Ae = function(n, e, r4, t) {
        for(var a = t ? e : W(e, r4), f = n.length - 1; f >= 0; --f){
            var l1, i4 = n[f];
            if (i4 === "[]" && r4.parseArrays) l1 = [].concat(a);
            else {
                l1 = r4.plainObjects ? Object.create(null) : {
                };
                var u = i4.charAt(0) === "[" && i4.charAt(i4.length - 1) === "]" ? i4.slice(1, -1) : i4, c2 = parseInt(u, 10);
                !r4.parseArrays && u === "" ? l1 = {
                    0: a
                } : !isNaN(c2) && i4 !== u && String(c2) === u && c2 >= 0 && r4.parseArrays && c2 <= r4.arrayLimit ? (l1 = [], l1[c2] = a) : l1[u] = a;
            }
            a = l1;
        }
        return a;
    }, Ce = function(e, r4, t, a) {
        if (!!e) {
            var f = t.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, l2 = /(\[[^[\]]*])/, i5 = /(\[[^[\]]*])/g, u = t.depth > 0 && l2.exec(f), c3 = u ? f.slice(0, u.index) : f, s4 = [];
            if (c3) {
                if (!t.plainObjects && L.call(Object.prototype, c3) && !t.allowPrototypes) return;
                s4.push(c3);
            }
            for(var p = 0; t.depth > 0 && (u = i5.exec(f)) !== null && p < t.depth;){
                if (p += 1, !t.plainObjects && L.call(Object.prototype, u[1].slice(1, -1)) && !t.allowPrototypes) return;
                s4.push(u[1]);
            }
            return u && s4.push("[" + f.slice(u.index) + "]"), Ae(s4, r4, t, a);
        }
    }, Qe = function(e) {
        if (!e) return d1;
        if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset != "undefined" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r4 = typeof e.charset == "undefined" ? d1.charset : e.charset;
        return {
            allowDots: typeof e.allowDots == "undefined" ? d1.allowDots : !!e.allowDots,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : d1.allowPrototypes,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : d1.arrayLimit,
            charset: r4,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : d1.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : d1.comma,
            decoder: typeof e.decoder == "function" ? e.decoder : d1.decoder,
            delimiter: typeof e.delimiter == "string" || x88.isRegExp(e.delimiter) ? e.delimiter : d1.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : d1.depth,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : d1.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : d1.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : d1.plainObjects,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : d1.strictNullHandling
        };
    };
    G.exports = function(n, e) {
        var r4 = Qe(e);
        if (n === "" || n === null || typeof n == "undefined") return r4.plainObjects ? Object.create(null) : {
        };
        for(var t = typeof n == "string" ? De(n, r4) : n, a = r4.plainObjects ? Object.create(null) : {
        }, f = Object.keys(t), l3 = 0; l3 < f.length; ++l3){
            var i6 = f[l3], u = Ce(i6, t[i6], r4, typeof n == "string");
            a = x88.merge(a, u, r4);
        }
        return x88.compact(a);
    };
});
var H = O((Me, X)=>{
    "use strict";
    var Te = $(), Le = J(), He = Q();
    X.exports = {
        formats: He,
        parse: Le,
        stringify: Te
    };
});
var Be = R(H());
var export_default1 = Be.default;
var z = Object.create, P = Object.defineProperty, C = Object.getPrototypeOf, M1 = Object.prototype.hasOwnProperty, A1 = Object.getOwnPropertyNames, S1 = Object.getOwnPropertyDescriptor;
var O1 = (u)=>P(u, "__esModule", {
        value: !0
    })
;
var D = (u, a)=>()=>(a || u((a = {
            exports: {
            }
        }).exports, a), a.exports)
;
var j = (u, a, p)=>{
    if (a && typeof a == "object" || typeof a == "function") for (let c4 of A1(a))!M1.call(u, c4) && c4 !== "default" && P(u, c4, {
        get: ()=>a[c4]
        ,
        enumerable: !(p = S1(a, c4)) || p.enumerable
    });
    return u;
}, b = (u)=>j(O1(P(u != null ? z(C(u)) : {
    }, "default", u && u.__esModule && "default" in u ? {
        get: ()=>u.default
        ,
        enumerable: !0
    } : {
        value: u,
        enumerable: !0
    })), u)
;
var x89 = D((E, w)=>{
    (function(u) {
        "use strict";
        let a = "(0?\\d+|0x[a-f0-9]+)", p = {
            fourOctet: new RegExp(`^${a}\\.${a}\\.${a}\\.${a}$`, "i"),
            threeOctet: new RegExp(`^${a}\\.${a}\\.${a}$`, "i"),
            twoOctet: new RegExp(`^${a}\\.${a}$`, "i"),
            longValue: new RegExp(`^${a}$`, "i")
        }, c4 = new RegExp("^0[0-7]+$", "i"), R1 = new RegExp("^0x[a-f0-9]+$", "i"), d2 = "%[0-9a-z]{1,}", I1 = "(?:[0-9a-f]+::?)+", h2 = {
            zoneIndex: new RegExp(d2, "i"),
            native: new RegExp(`^(::)?(${I1})?([0-9a-f]+)?(::)?(${d2})?$`, "i"),
            deprecatedTransitional: new RegExp(`^(?:::)(${a}\\.${a}\\.${a}\\.${a}(${d2})?)$`, "i"),
            transitional: new RegExp(`^((?:${I1})|(?:::)(?:${I1})?)${a}\\.${a}\\.${a}\\.${a}(${d2})?$`, "i")
        };
        function y21(t, e) {
            if (t.indexOf("::") !== t.lastIndexOf("::")) return null;
            let n = 0, r4 = -1, i7 = (t.match(h2.zoneIndex) || [])[0], o, f;
            for(i7 && (i7 = i7.substring(1), t = t.replace(/%.+$/, "")); (r4 = t.indexOf(":", r4 + 1)) >= 0;)n++;
            if (t.substr(0, 2) === "::" && n--, t.substr(-2, 2) === "::" && n--, n > e) return null;
            for(f = e - n, o = ":"; f--;)o += "0:";
            return t = t.replace("::", o), t[0] === ":" && (t = t.slice(1)), t[t.length - 1] === ":" && (t = t.slice(0, -1)), e = (function() {
                let $1 = t.split(":"), g2 = [];
                for(let v2 = 0; v2 < $1.length; v2++)g2.push(parseInt($1[v2], 16));
                return g2;
            })(), {
                parts: e,
                zoneId: i7
            };
        }
        function m2(t, e, n, r4) {
            if (t.length !== e.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
            let i7 = 0, o;
            for(; r4 > 0;){
                if (o = n - r4, o < 0 && (o = 0), t[i7] >> o != e[i7] >> o) return !1;
                r4 -= n, i7 += 1;
            }
            return !0;
        }
        function l3(t) {
            if (R1.test(t)) return parseInt(t, 16);
            if (t[0] === "0" && !isNaN(parseInt(t[1], 10))) {
                if (c4.test(t)) return parseInt(t, 8);
                throw new Error(`ipaddr: cannot parse ${t} as octal`);
            }
            return parseInt(t, 10);
        }
        function k(t, e) {
            for(; t.length < e;)t = `0${t}`;
            return t;
        }
        let s5 = {
        };
        s5.IPv4 = (function() {
            function t(e) {
                if (e.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
                let n, r4;
                for(n = 0; n < e.length; n++)if (r4 = e[n], !(0 <= r4 && r4 <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                this.octets = e;
            }
            return t.prototype.SpecialRanges = {
                unspecified: [
                    [
                        new t([
                            0,
                            0,
                            0,
                            0
                        ]),
                        8
                    ]
                ],
                broadcast: [
                    [
                        new t([
                            255,
                            255,
                            255,
                            255
                        ]),
                        32
                    ]
                ],
                multicast: [
                    [
                        new t([
                            224,
                            0,
                            0,
                            0
                        ]),
                        4
                    ]
                ],
                linkLocal: [
                    [
                        new t([
                            169,
                            254,
                            0,
                            0
                        ]),
                        16
                    ]
                ],
                loopback: [
                    [
                        new t([
                            127,
                            0,
                            0,
                            0
                        ]),
                        8
                    ]
                ],
                carrierGradeNat: [
                    [
                        new t([
                            100,
                            64,
                            0,
                            0
                        ]),
                        10
                    ]
                ],
                private: [
                    [
                        new t([
                            10,
                            0,
                            0,
                            0
                        ]),
                        8
                    ],
                    [
                        new t([
                            172,
                            16,
                            0,
                            0
                        ]),
                        12
                    ],
                    [
                        new t([
                            192,
                            168,
                            0,
                            0
                        ]),
                        16
                    ]
                ],
                reserved: [
                    [
                        new t([
                            192,
                            0,
                            0,
                            0
                        ]),
                        24
                    ],
                    [
                        new t([
                            192,
                            0,
                            2,
                            0
                        ]),
                        24
                    ],
                    [
                        new t([
                            192,
                            88,
                            99,
                            0
                        ]),
                        24
                    ],
                    [
                        new t([
                            198,
                            51,
                            100,
                            0
                        ]),
                        24
                    ],
                    [
                        new t([
                            203,
                            0,
                            113,
                            0
                        ]),
                        24
                    ],
                    [
                        new t([
                            240,
                            0,
                            0,
                            0
                        ]),
                        4
                    ]
                ]
            }, t.prototype.kind = function() {
                return "ipv4";
            }, t.prototype.match = function(e, n) {
                let r4;
                if (n === void 0 && (r4 = e, e = r4[0], n = r4[1]), e.kind() !== "ipv4") throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                return m2(this.octets, e.octets, 8, n);
            }, t.prototype.prefixLengthFromSubnetMask = function() {
                let e = 0, n = !1, r4 = {
                    0: 8,
                    128: 7,
                    192: 6,
                    224: 5,
                    240: 4,
                    248: 3,
                    252: 2,
                    254: 1,
                    255: 0
                }, i7, o, f;
                for(i7 = 3; i7 >= 0; i7 -= 1)if (o = this.octets[i7], o in r4) {
                    if (f = r4[o], n && f !== 0) return null;
                    f !== 8 && (n = !0), e += f;
                } else return null;
                return 32 - e;
            }, t.prototype.range = function() {
                return s5.subnetMatch(this, this.SpecialRanges);
            }, t.prototype.toByteArray = function() {
                return this.octets.slice(0);
            }, t.prototype.toIPv4MappedAddress = function() {
                return s5.IPv6.parse(`::ffff:${this.toString()}`);
            }, t.prototype.toNormalizedString = function() {
                return this.toString();
            }, t.prototype.toString = function() {
                return this.octets.join(".");
            }, t;
        })(), s5.IPv4.broadcastAddressFromCIDR = function(t) {
            try {
                let e = this.parseCIDR(t), n = e[0].toByteArray(), r4 = this.subnetMaskFromPrefixLength(e[1]).toByteArray(), i7 = [], o = 0;
                for(; o < 4;)i7.push(parseInt(n[o], 10) | parseInt(r4[o], 10) ^ 255), o++;
                return new this(i7);
            } catch (e1) {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
            }
        }, s5.IPv4.isIPv4 = function(t) {
            return this.parser(t) !== null;
        }, s5.IPv4.isValid = function(t) {
            try {
                return new this(this.parser(t)), !0;
            } catch (e) {
                return !1;
            }
        }, s5.IPv4.isValidFourPartDecimal = function(t) {
            return !!(s5.IPv4.isValid(t) && t.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
        }, s5.IPv4.networkAddressFromCIDR = function(t) {
            let e, n, r4, i7, o;
            try {
                for(e = this.parseCIDR(t), r4 = e[0].toByteArray(), o = this.subnetMaskFromPrefixLength(e[1]).toByteArray(), i7 = [], n = 0; n < 4;)i7.push(parseInt(r4[n], 10) & parseInt(o[n], 10)), n++;
                return new this(i7);
            } catch (f) {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
            }
        }, s5.IPv4.parse = function(t) {
            let e = this.parser(t);
            if (e === null) throw new Error("ipaddr: string is not formatted like an IPv4 Address");
            return new this(e);
        }, s5.IPv4.parseCIDR = function(t) {
            let e;
            if (e = t.match(/^(.+)\/(\d+)$/)) {
                let n = parseInt(e[2]);
                if (n >= 0 && n <= 32) {
                    let r4 = [
                        this.parse(e[1]),
                        n
                    ];
                    return Object.defineProperty(r4, "toString", {
                        value: function() {
                            return this.join("/");
                        }
                    }), r4;
                }
            }
            throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
        }, s5.IPv4.parser = function(t) {
            let e, n, r4;
            if (e = t.match(p.fourOctet)) return (function() {
                let i7 = e.slice(1, 6), o = [];
                for(let f = 0; f < i7.length; f++)n = i7[f], o.push(l3(n));
                return o;
            })();
            if (e = t.match(p.longValue)) {
                if (r4 = l3(e[1]), r4 > 4294967295 || r4 < 0) throw new Error("ipaddr: address outside defined range");
                return (function() {
                    let i7 = [], o;
                    for(o = 0; o <= 24; o += 8)i7.push(r4 >> o & 255);
                    return i7;
                })().reverse();
            } else return (e = t.match(p.twoOctet)) ? (function() {
                let i7 = e.slice(1, 4), o = [];
                if (r4 = l3(i7[1]), r4 > 16777215 || r4 < 0) throw new Error("ipaddr: address outside defined range");
                return o.push(l3(i7[0])), o.push(r4 >> 16 & 255), o.push(r4 >> 8 & 255), o.push(r4 & 255), o;
            })() : (e = t.match(p.threeOctet)) ? (function() {
                let i7 = e.slice(1, 5), o = [];
                if (r4 = l3(i7[2]), r4 > 65535 || r4 < 0) throw new Error("ipaddr: address outside defined range");
                return o.push(l3(i7[0])), o.push(l3(i7[1])), o.push(r4 >> 8 & 255), o.push(r4 & 255), o;
            })() : null;
        }, s5.IPv4.subnetMaskFromPrefixLength = function(t) {
            if (t = parseInt(t), t < 0 || t > 32) throw new Error("ipaddr: invalid IPv4 prefix length");
            let e = [
                0,
                0,
                0,
                0
            ], n = 0, r4 = Math.floor(t / 8);
            for(; n < r4;)e[n] = 255, n++;
            return r4 < 4 && (e[r4] = Math.pow(2, t % 8) - 1 << 8 - t % 8), new this(e);
        }, s5.IPv6 = (function() {
            function t(e, n) {
                let r4, i7;
                if (e.length === 16) for(this.parts = [], r4 = 0; r4 <= 14; r4 += 2)this.parts.push(e[r4] << 8 | e[r4 + 1]);
                else if (e.length === 8) this.parts = e;
                else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                for(r4 = 0; r4 < this.parts.length; r4++)if (i7 = this.parts[r4], !(0 <= i7 && i7 <= 65535)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                n && (this.zoneId = n);
            }
            return t.prototype.SpecialRanges = {
                unspecified: [
                    new t([
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    128
                ],
                linkLocal: [
                    new t([
                        65152,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    10
                ],
                multicast: [
                    new t([
                        65280,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    8
                ],
                loopback: [
                    new t([
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ]),
                    128
                ],
                uniqueLocal: [
                    new t([
                        64512,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    7
                ],
                ipv4Mapped: [
                    new t([
                        0,
                        0,
                        0,
                        0,
                        0,
                        65535,
                        0,
                        0
                    ]),
                    96
                ],
                rfc6145: [
                    new t([
                        0,
                        0,
                        0,
                        0,
                        65535,
                        0,
                        0,
                        0
                    ]),
                    96
                ],
                rfc6052: [
                    new t([
                        100,
                        65435,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    96
                ],
                "6to4": [
                    new t([
                        8194,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    16
                ],
                teredo: [
                    new t([
                        8193,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    32
                ],
                reserved: [
                    [
                        new t([
                            8193,
                            3512,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        32
                    ]
                ]
            }, t.prototype.isIPv4MappedAddress = function() {
                return this.range() === "ipv4Mapped";
            }, t.prototype.kind = function() {
                return "ipv6";
            }, t.prototype.match = function(e, n) {
                let r4;
                if (n === void 0 && (r4 = e, e = r4[0], n = r4[1]), e.kind() !== "ipv6") throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                return m2(this.parts, e.parts, 16, n);
            }, t.prototype.prefixLengthFromSubnetMask = function() {
                let e = 0, n = !1, r4 = {
                    0: 16,
                    32768: 15,
                    49152: 14,
                    57344: 13,
                    61440: 12,
                    63488: 11,
                    64512: 10,
                    65024: 9,
                    65280: 8,
                    65408: 7,
                    65472: 6,
                    65504: 5,
                    65520: 4,
                    65528: 3,
                    65532: 2,
                    65534: 1,
                    65535: 0
                }, i7, o;
                for(let f = 7; f >= 0; f -= 1)if (i7 = this.parts[f], i7 in r4) {
                    if (o = r4[i7], n && o !== 0) return null;
                    o !== 16 && (n = !0), e += o;
                } else return null;
                return 128 - e;
            }, t.prototype.range = function() {
                return s5.subnetMatch(this, this.SpecialRanges);
            }, t.prototype.toByteArray = function() {
                let e, n = [], r4 = this.parts;
                for(let i7 = 0; i7 < r4.length; i7++)e = r4[i7], n.push(e >> 8), n.push(e & 255);
                return n;
            }, t.prototype.toFixedLengthString = function() {
                let e = (function() {
                    let r4 = [];
                    for(let i7 = 0; i7 < this.parts.length; i7++)r4.push(k(this.parts[i7].toString(16), 4));
                    return r4;
                }).call(this).join(":"), n = "";
                return this.zoneId && (n = `%${this.zoneId}`), e + n;
            }, t.prototype.toIPv4Address = function() {
                if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                let e = this.parts.slice(-2), n = e[0], r4 = e[1];
                return new s5.IPv4([
                    n >> 8,
                    n & 255,
                    r4 >> 8,
                    r4 & 255
                ]);
            }, t.prototype.toNormalizedString = function() {
                let e = (function() {
                    let r4 = [];
                    for(let i7 = 0; i7 < this.parts.length; i7++)r4.push(this.parts[i7].toString(16));
                    return r4;
                }).call(this).join(":"), n = "";
                return this.zoneId && (n = `%${this.zoneId}`), e + n;
            }, t.prototype.toRFC5952String = function() {
                let e = /((^|:)(0(:|$)){2,})/g, n = this.toNormalizedString(), r4 = 0, i7 = -1, o;
                for(; o = e.exec(n);)o[0].length > i7 && (r4 = o.index, i7 = o[0].length);
                return i7 < 0 ? n : `${n.substring(0, r4)}::${n.substring(r4 + i7)}`;
            }, t.prototype.toString = function() {
                return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
            }, t;
        })(), s5.IPv6.isIPv6 = function(t) {
            return this.parser(t) !== null;
        }, s5.IPv6.isValid = function(t) {
            if (typeof t == "string" && t.indexOf(":") === -1) return !1;
            try {
                let e = this.parser(t);
                return new this(e.parts, e.zoneId), !0;
            } catch (e1) {
                return !1;
            }
        }, s5.IPv6.parse = function(t) {
            let e = this.parser(t);
            if (e.parts === null) throw new Error("ipaddr: string is not formatted like an IPv6 Address");
            return new this(e.parts, e.zoneId);
        }, s5.IPv6.parseCIDR = function(t) {
            let e, n, r4;
            if ((n = t.match(/^(.+)\/(\d+)$/)) && (e = parseInt(n[2]), e >= 0 && e <= 128)) return r4 = [
                this.parse(n[1]),
                e
            ], Object.defineProperty(r4, "toString", {
                value: function() {
                    return this.join("/");
                }
            }), r4;
            throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
        }, s5.IPv6.parser = function(t) {
            let e, n, r4, i7, o, f;
            if (r4 = t.match(h2.deprecatedTransitional)) return this.parser(`::ffff:${r4[1]}`);
            if (h2.native.test(t)) return y21(t, 8);
            if ((r4 = t.match(h2.transitional)) && (f = r4[6] || "", e = y21(r4[1].slice(0, -1) + f, 6), e.parts)) {
                for(o = [
                    parseInt(r4[2]),
                    parseInt(r4[3]),
                    parseInt(r4[4]),
                    parseInt(r4[5])
                ], n = 0; n < o.length; n++)if (i7 = o[n], !(0 <= i7 && i7 <= 255)) return null;
                return e.parts.push(o[0] << 8 | o[1]), e.parts.push(o[2] << 8 | o[3]), {
                    parts: e.parts,
                    zoneId: e.zoneId
                };
            }
            return null;
        }, s5.fromByteArray = function(t) {
            let e = t.length;
            if (e === 4) return new s5.IPv4(t);
            if (e === 16) return new s5.IPv6(t);
            throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }, s5.isValid = function(t) {
            return s5.IPv6.isValid(t) || s5.IPv4.isValid(t);
        }, s5.parse = function(t) {
            if (s5.IPv6.isValid(t)) return s5.IPv6.parse(t);
            if (s5.IPv4.isValid(t)) return s5.IPv4.parse(t);
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }, s5.parseCIDR = function(t) {
            try {
                return s5.IPv6.parseCIDR(t);
            } catch (e) {
                try {
                    return s5.IPv4.parseCIDR(t);
                } catch (n) {
                    throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                }
            }
        }, s5.process = function(t) {
            let e = this.parse(t);
            return e.kind() === "ipv6" && e.isIPv4MappedAddress() ? e.toIPv4Address() : e;
        }, s5.subnetMatch = function(t, e, n) {
            let r4, i7, o, f;
            n == null && (n = "unicast");
            for(i7 in e)if (Object.prototype.hasOwnProperty.call(e, i7)) {
                for(o = e[i7], o[0] && !(o[0] instanceof Array) && (o = [
                    o
                ]), r4 = 0; r4 < o.length; r4++)if (f = o[r4], t.kind() === f[0].kind() && t.match.apply(t, f)) return i7;
            }
            return n;
        }, typeof w != "undefined" && w.exports ? w.exports = s5 : u.ipaddr = s5;
    })(E);
});
var F1 = b(x89());
var export_default2 = F1.default;
var m2 = Object.create, o = Object.defineProperty, y21 = Object.getPrototypeOf, l3 = Object.prototype.hasOwnProperty, v2 = Object.getOwnPropertyNames, w = Object.getOwnPropertyDescriptor;
var g2 = (e)=>o(e, "__esModule", {
        value: !0
    })
;
var p = (e, r4)=>()=>(r4 || e((r4 = {
            exports: {
            }
        }).exports, r4), r4.exports)
;
var M2 = (e, r4, s5)=>{
    if (r4 && typeof r4 == "object" || typeof r4 == "function") for (let a of v2(r4))!l3.call(e, a) && a !== "default" && o(e, a, {
        get: ()=>r4[a]
        ,
        enumerable: !(s5 = w(r4, a)) || s5.enumerable
    });
    return e;
}, b1 = (e)=>M2(g2(o(e != null ? m2(y21(e)) : {
    }, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default
        ,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e)
;
var f = p((E, d2)=>{
    var t = 1000, c4 = t * 60, u = c4 * 60, n = u * 24, k = n * 7, x90 = n * 365.25;
    d2.exports = function(e, r4) {
        r4 = r4 || {
        };
        var s5 = typeof e;
        if (s5 === "string" && e.length > 0) return S2(e);
        if (s5 === "number" && isFinite(e)) return r4.long ? F2(e) : A3(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };
    function S2(e) {
        if (e = String(e), !(e.length > 100)) {
            var r4 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
            if (!!r4) {
                var s5 = parseFloat(r4[1]), a = (r4[2] || "ms").toLowerCase();
                switch(a){
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return s5 * x90;
                    case "weeks":
                    case "week":
                    case "w":
                        return s5 * k;
                    case "days":
                    case "day":
                    case "d":
                        return s5 * n;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return s5 * u;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return s5 * c4;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return s5 * t;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return s5;
                    default:
                        return;
                }
            }
        }
    }
    function A3(e) {
        var r5 = Math.abs(e);
        return r5 >= n ? Math.round(e / n) + "d" : r5 >= u ? Math.round(e / u) + "h" : r5 >= c4 ? Math.round(e / c4) + "m" : r5 >= t ? Math.round(e / t) + "s" : e + "ms";
    }
    function F2(e) {
        var r5 = Math.abs(e);
        return r5 >= n ? i8(e, r5, n, "day") : r5 >= u ? i8(e, r5, u, "hour") : r5 >= c4 ? i8(e, r5, c4, "minute") : r5 >= t ? i8(e, r5, t, "second") : e + " ms";
    }
    function i8(e, r5, s6, a) {
        var h2 = r5 >= s6 * 1.5;
        return Math.round(e / s6) + " " + a + (h2 ? "s" : "");
    }
});
var L = b1(f());
var export_default3 = L.default;
const methods = [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect", 
];
const MATCHING_GROUP_REGEXP = /\((?!\?)/g;
function pathToRegexp(path7, keys, options5) {
    options5 = options5 || {
    };
    keys = keys || [];
    const strict = options5.strict;
    const end = options5.end !== false;
    const flags = options5.sensitive ? "" : "i";
    let extraOffset = 0;
    const keysOffset = keys.length;
    let i8 = 0;
    let name13 = 0;
    let m3;
    if (path7 instanceof RegExp) {
        while(m3 = MATCHING_GROUP_REGEXP.exec(path7.source)){
            keys.push({
                name: name13++,
                optional: false,
                offset: m3.index
            });
        }
        return path7;
    }
    if (Array.isArray(path7)) {
        path7 = path7.map(function(value7) {
            return pathToRegexp(value7, keys, options5).source;
        });
        return new RegExp("(?:" + path7.join("|") + ")", flags);
    }
    path7 = ("^" + path7 + (strict ? "" : path7[path7.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format12, key1, capture, star, optional, offset) {
        slash = slash || "";
        format12 = format12 || "";
        capture = capture || "([^\\/" + format12 + "]+?)";
        optional = optional || "";
        keys.push({
            name: key1,
            optional: !!optional,
            offset: offset + extraOffset
        });
        const result = "" + (optional ? "" : slash) + "(?:" + format12 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format12 + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
    }).replace(/\*/g, function(star, index) {
        let len = keys.length;
        while((len--) > keysOffset && keys[len].offset > index){
            keys[len].offset += 3;
        }
        return "(.*)";
    });
    while(m3 = MATCHING_GROUP_REGEXP.exec(path7)){
        let escapeCount = 0;
        let index = m3.index;
        while(path7.charAt(--index) === "\\"){
            escapeCount++;
        }
        if (escapeCount % 2 === 1) {
            continue;
        }
        if (keysOffset + i8 === keys.length || keys[keysOffset + i8].offset > m3.index) {
            keys.splice(keysOffset + i8, 0, {
                name: name13++,
                optional: false,
                offset: m3.index
            });
        }
        i8++;
    }
    path7 += end ? "$" : path7[path7.length - 1] === "/" ? "" : "(?=\\/|$)";
    return new RegExp(path7, flags);
}
const Layer = function Layer1(path7, options5 = {
}, fn) {
    if (!(this instanceof Layer1)) {
        return new Layer1(path7, options5, fn);
    }
    this.handle = fn;
    this.name = fn.name || "<anonymous>";
    this.params = undefined;
    this.path = undefined;
    this.regexp = pathToRegexp(path7, this.keys = [], options5);
    this.regexp.fast_star = path7 === "*";
    this.regexp.fast_slash = path7 === "/" && options5.end === false;
};
Layer.prototype.handle_error = async function handle_error(error1, req, res, next) {
    let fn = this.handle;
    if (fn.length !== 4) {
        return next(error1);
    }
    try {
        await fn(error1, req, res, next);
    } catch (err2) {
        next(err2);
    }
};
Layer.prototype.handle_request = async function handle(req, res, next) {
    let fn = this.handle;
    if (fn.length > 3) {
        return next();
    }
    try {
        await fn(req, res, next);
    } catch (err2) {
        next(err2);
    }
};
Layer.prototype.match = function match(path7) {
    let match;
    if (path7 != null) {
        if (this.regexp.fast_slash) {
            this.params = {
            };
            this.path = "";
            return true;
        }
        if (this.regexp.fast_star) {
            this.params = {
                "0": decode_param(path7)
            };
            this.path = path7;
            return true;
        }
        match = this.regexp.exec(path7);
    }
    if (!match) {
        this.params = undefined;
        this.path = undefined;
        return false;
    }
    this.params = {
    };
    this.path = match[0];
    let keys = this.keys;
    let params = this.params;
    for(let i8 = 1; i8 < match.length; i8++){
        let key1 = keys[i8 - 1];
        let prop2 = key1.name;
        let val = decode_param(match[i8]);
        if (val !== undefined || !Object.prototype.hasOwnProperty.call(params, prop2)) {
            params[prop2] = val;
        }
    }
    return true;
};
function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
        return val;
    }
    try {
        return decodeURIComponent(val);
    } catch (err2) {
        if (err2 instanceof URIError) {
            err2.message = "Failed to decode param '" + val + "'";
            err2.status = 400;
        }
        throw err2;
    }
}
const Route = function Route1(path7) {
    this.path = path7;
    this.stack = [];
    this.methods = {
    };
};
Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
        return true;
    }
    let name13 = method.toLowerCase();
    if (name13 === "head" && !this.methods["head"]) {
        name13 = "get";
    }
    return Boolean(this.methods[name13]);
};
Route.prototype._options = function _options() {
    let methods1 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
        methods1.push("head");
    }
    for(let i8 = 0; i8 < methods1.length; i8++){
        methods1[i8] = methods1[i8].toUpperCase();
    }
    return methods1;
};
Route.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    let stack = this.stack;
    if (stack.length === 0) {
        return done();
    }
    let method = req.method.toLowerCase();
    if (method === "head" && !this.methods["head"]) {
        method = "get";
    }
    req.route = this;
    next();
    function next(err2) {
        if (err2 && err2 === "route") {
            return done();
        }
        if (err2 && err2 === "router") {
            return done(err2);
        }
        let layer = stack[idx++];
        if (!layer) {
            return done(err2);
        }
        if (layer.method && layer.method !== method) {
            return next(err2);
        }
        if (err2) {
            layer.handle_error(err2, req, res, next);
        } else {
            layer.handle_request(req, res, next);
        }
    }
};
Route.prototype.all = function all() {
    let handles = Array.prototype.slice.call(arguments).flat(1);
    for(let i8 = 0; i8 < handles.length; i8++){
        let handle1 = handles[i8];
        if (typeof handle1 !== "function") {
            let type4 = Object.prototype.toString.call(handle1);
            let msg4 = "Route.all() requires a callback function but got a " + type4;
            throw new TypeError(msg4);
        }
        let layer = Layer("/", {
        }, handle1);
        layer.method = undefined;
        this.methods._all = true;
        this.stack.push(layer);
    }
    return this;
};
methods.forEach(function(method) {
    Route.prototype[method] = function() {
        let handles = Array.prototype.slice.call(arguments).flat(1);
        for(let i8 = 0; i8 < handles.length; i8++){
            let handle1 = handles[i8];
            if (typeof handle1 !== "function") {
                let type4 = Object.prototype.toString.call(handle1);
                let msg4 = "Route." + method + "() requires a callback function but got a " + type4;
                throw new Error(msg4);
            }
            let layer = Layer("/", {
            }, handle1);
            layer.method = method;
            this.methods[method] = true;
            this.stack.push(layer);
        }
        return this;
    };
});
function merge(a, b2) {
    if (a && b2) {
        for(let key1 in b2){
            a[key1] = b2[key1];
        }
    }
    return a;
}
function parseUrl(req) {
    const url = req.url;
    if (url === undefined) {
        return undefined;
    }
    let parsed = req._parsedUrl;
    if (fresh(url, parsed)) {
        return parsed;
    }
    parsed = fastParse(url);
    parsed._raw = url;
    return req._parsedUrl = parsed;
}
function fastParse(str3) {
    if (typeof str3 !== "string" || str3.charCodeAt(0) !== 47) {
        try {
            return new URL(str3);
        } catch (_) {
        }
    }
    let pathname = str3;
    let query = null;
    let search = null;
    for(let i8 = 1; i8 < str3.length; i8++){
        switch(str3.charCodeAt(i8)){
            case 63:
                if (search === null) {
                    pathname = str3.substring(0, i8);
                    query = str3.substring(i8 + 1);
                    search = str3.substring(i8);
                }
                break;
            case 9:
            case 10:
            case 12:
            case 13:
            case 32:
            case 35:
            case 160:
            case 65279:
                return new URL(str3);
        }
    }
    const url = {
    };
    url.path = str3 || null;
    url.href = str3 || null;
    url.pathname = pathname || null;
    url.query = query || null;
    url.search = search || null;
    url.searchParams = new URLSearchParams(search || "");
    return url;
}
function fresh(url, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && parsedUrl._raw === url;
}
const objectRegExp = /^\[object (\S+)\]$/;
const setPrototypeOf = Object.setPrototypeOf;
const Router = function(options5 = {
}) {
    function router(req, res, next) {
        router.handle(req, res, next);
    }
    setPrototypeOf(router, Router);
    router.params = {
    };
    router._params = [];
    router.caseSensitive = options5.caseSensitive;
    router.mergeParams = options5.mergeParams;
    router.strict = options5.strict;
    router.stack = [];
    return router;
};
Router.param = function param(name13, fn) {
    var params = this._params;
    var len = params.length;
    var ret1;
    if (typeof name13 !== "string") {
        throw new Error("invalid param() call for " + name13 + ", value must be a string");
    }
    for(var i8 = 0; i8 < len; ++i8){
        if (ret1 = params[i8](name13, fn)) {
            fn = ret1;
        }
    }
    if ("function" !== typeof fn) {
        throw new Error("invalid param() call for " + name13 + ", got " + fn);
    }
    (this.params[name13] = this.params[name13] || []).push(fn);
    return this;
};
Router.handle = function handle1(req, res, out = ()=>{
}) {
    const self = this;
    let idx = 0;
    let protohost = getProtohost(req.url) || "";
    let removed = "";
    let slashAdded = false;
    let paramcalled = {
    };
    let options5 = [];
    let stack = self.stack;
    let parentParams = req.params;
    let parentUrl = req.baseUrl || "";
    let done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
        done = wrap(done, function(old, err2) {
            if (err2 || options5.length === 0) {
                return old(err2);
            }
            sendOptionsResponse(res, options5, old);
        });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err2) {
        let layerError = err2 === "route" ? null : err2;
        if (slashAdded) {
            req.url = req.url.substr(1);
            slashAdded = false;
        }
        if (removed.length !== 0) {
            req.baseUrl = parentUrl;
            req.url = protohost + removed + req.url.substr(protohost.length);
            removed = "";
        }
        if (layerError === "router") {
            setImmediate(done, null);
            return;
        }
        if (idx >= stack.length) {
            setImmediate(done, layerError);
            return;
        }
        let path7 = (parseUrl(req) || {
        }).pathname;
        if (path7 == null) {
            return done(layerError);
        }
        let layer;
        let match1;
        let route;
        while(match1 !== true && idx < stack.length){
            layer = stack[idx++];
            match1 = matchLayer(layer, path7);
            route = layer.route;
            if (typeof match1 !== "boolean") {
                layerError = layerError || match1;
            }
            if (match1 !== true) {
                continue;
            }
            if (!route) {
                continue;
            }
            if (layerError) {
                match1 = false;
                continue;
            }
            let method = req.method;
            let has_method = route._handles_method(method);
            if (!has_method && method === "OPTIONS") {
                appendMethods(options5, route._options());
            }
            if (!has_method && method !== "HEAD") {
                match1 = false;
                continue;
            }
        }
        if (match1 !== true) {
            return done(layerError);
        }
        if (route) {
            req.route = route;
        }
        req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        let layerPath = layer.path;
        self.process_params(layer, paramcalled, req, res, function(err3) {
            if (err3) {
                return next(layerError || err3);
            }
            if (route) {
                return layer.handle_request(req, res, next);
            }
            trim_prefix(layer, layerError, layerPath, path7);
        });
    }
    function trim_prefix(layer, layerError, layerPath, path7) {
        if (layerPath.length !== 0) {
            let c5 = path7[layerPath.length];
            if (c5 && c5 !== "/" && c5 !== ".") {
                return next(layerError);
            }
            removed = layerPath;
            req.url = protohost + req.url.substr(protohost.length + removed.length);
            if (!protohost && req.url[0] !== "/") {
                req.url = "/" + req.url;
                slashAdded = true;
            }
            req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
        }
        if (layerError) {
            layer.handle_error(layerError, req, res, next);
        } else {
            layer.handle_request(req, res, next);
        }
    }
};
Router.process_params = function process_params(layer, called, req, res, done) {
    let params = this.params;
    let keys = layer.keys;
    if (!keys || keys.length === 0) {
        return done();
    }
    let i8 = 0;
    let name13;
    let paramIndex = 0;
    let key1;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    function param1(err2) {
        if (err2) {
            return done(err2);
        }
        if (i8 >= keys.length) {
            return done();
        }
        paramIndex = 0;
        key1 = keys[i8++];
        name13 = key1.name;
        paramVal = req.params[name13];
        paramCallbacks = params[name13];
        paramCalled = called[name13];
        if (paramVal === undefined || !paramCallbacks) {
            return param1();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
            req.params[name13] = paramCalled.value;
            return param1(paramCalled.error);
        }
        called[name13] = paramCalled = {
            error: null,
            match: paramVal,
            value: paramVal
        };
        paramCallback();
    }
    function paramCallback(err2) {
        let fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key1.name];
        if (err2) {
            paramCalled.error = err2;
            param1(err2);
            return;
        }
        if (!fn) return param1();
        try {
            fn(req, res, paramCallback, paramVal, key1.name);
        } catch (e) {
            paramCallback(e);
        }
    }
    param1();
};
Router.use = function use(fn) {
    let offset = 0;
    let path7 = "/";
    if (typeof fn !== "function") {
        let arg = fn;
        while(Array.isArray(arg) && arg.length !== 0){
            arg = arg[0];
        }
        if (typeof arg !== "function") {
            offset = 1;
            path7 = fn;
        }
    }
    let callbacks = Array.prototype.slice.call(arguments, offset).flat(1);
    if (callbacks.length === 0) {
        throw new TypeError("Router.use() requires a middleware function");
    }
    for(let i8 = 0; i8 < callbacks.length; i8++){
        let fn1 = callbacks[i8];
        if (typeof fn1 !== "function") {
            throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn1));
        }
        let layer = new Layer(path7, {
            sensitive: this.caseSensitive,
            strict: false,
            end: false
        }, fn1);
        layer.route = undefined;
        this.stack.push(layer);
    }
    return this;
};
Router.route = function route(path7) {
    let route = new Route(path7);
    let layer = new Layer(path7, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
    }, route.dispatch.bind(route));
    layer.route = route;
    this.stack.push(layer);
    return route;
};
methods.concat("all").forEach(function(method) {
    Router[method] = function(path7) {
        let route1 = this.route(path7);
        route1[method].apply(route1, Array.prototype.slice.call(arguments, 1));
        return this;
    };
});
function appendMethods(list, addition) {
    for(let i8 = 0; i8 < addition.length; i8++){
        let method = addition[i8];
        if (list.indexOf(method) === -1) {
            list.push(method);
        }
    }
}
function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
        return undefined;
    }
    let searchIndex = url.indexOf("?");
    let pathLength = searchIndex !== -1 ? searchIndex : url.length;
    let fqdnIndex = url.substr(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substr(0, url.indexOf("/", 3 + fqdnIndex)) : undefined;
}
function gettype(obj) {
    let type4 = typeof obj;
    if (type4 !== "object") {
        return type4;
    }
    return Object.prototype.toString.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer, path7) {
    try {
        return layer.match(path7);
    } catch (err2) {
        return err2;
    }
}
function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
        return params;
    }
    let obj = merge({
    }, parent);
    if (!(0 in params) || !(0 in parent)) {
        return merge(obj, params);
    }
    let i8 = 0;
    let o1 = 0;
    while(i8 in params){
        i8++;
    }
    while(o1 in parent){
        o1++;
    }
    for(i8--; i8 >= 0; i8--){
        params[i8 + o1] = params[i8];
        if (i8 < o1) {
            delete params[i8];
        }
    }
    return merge(obj, params);
}
function restore(fn, obj) {
    let props = new Array(arguments.length - 2);
    let vals = new Array(arguments.length - 2);
    for(let i8 = 0; i8 < props.length; i8++){
        props[i8] = arguments[i8 + 2];
        vals[i8] = obj[props[i8]];
    }
    return function() {
        for(let i9 = 0; i9 < props.length; i9++){
            obj[props[i9]] = vals[i9];
        }
        return fn.apply(this, arguments);
    };
}
function sendOptionsResponse(res, options5, next) {
    try {
        let body = options5.join(",");
        res.set("Allow", body);
        res.send(body);
    } catch (err2) {
        next(err2);
    }
}
function wrap(old, fn) {
    return function proxy() {
        let args2 = new Array(arguments.length + 1);
        args2[0] = old;
        for(let i8 = 0, len = arguments.length; i8 < len; i8++){
            args2[i8 + 1] = arguments[i8];
        }
        fn.apply(this, args2);
    };
}
const create = Object.create;
const setPrototypeOf1 = Object.setPrototypeOf;
const init = function(app) {
    return function opineInit(req, res, next) {
        if (app.enabled("x-powered-by")) res.set("X-Powered-By", "Opine");
        req.res = res;
        res.req = req;
        req.next = next;
        setPrototypeOf1(req, app.request);
        setPrototypeOf1(res, app.response);
        res.app = app.response.app;
        res.locals = res.locals || create(null);
        next();
    };
};
const query = function(options5) {
    let opts = merge({
    }, options5);
    let queryParse = export_default1.parse;
    if (typeof options5 === "function") {
        queryParse = options5;
        opts = undefined;
    }
    if (opts !== undefined && opts.allowPrototypes === undefined) {
        opts.allowPrototypes = true;
    }
    return function opineQuery(req, _res, next) {
        if (!req.query) {
            const value7 = parseUrl(req)?.query;
            req.query = queryParse(value7, opts);
        }
        next();
    };
};
const BODY_KEY = "body";
const PARSED_BODY_KEY = "parsedBody";
const RAW_BODY_KEY = "raw";
const requestProxy = (req)=>new Proxy(req, {
        get: (target, prop2)=>{
            let value7;
            if (prop2 === BODY_KEY) {
                value7 = target[PARSED_BODY_KEY] ?? target[BODY_KEY];
            } else if (prop2 === RAW_BODY_KEY) {
                value7 = target[BODY_KEY];
            } else {
                value7 = target[prop2];
            }
            if (prop2 === "respond") {
                return value7.bind(target);
            }
            return value7;
        },
        set: (target, prop2, value7, receiver)=>{
            if (prop2 === BODY_KEY) {
                return Reflect.set(target, PARSED_BODY_KEY, value7, receiver);
            }
            return Reflect.set(target, prop2, value7, receiver);
        }
    })
;
const DOUBLE_SPACE_REGEXP = /\x20{2}/g;
const NEWLINE_REGEXP = /\n/g;
function createHtmlDocument(message15) {
    const body = escapeHtml(message15).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return "<!DOCTYPE html>\n" + '<html lang="en">\n' + "<head>\n" + '<meta charset="utf-8">\n' + "<title>Error</title>\n" + "</head>\n" + "<body>\n" + "<pre>" + body + "</pre>\n" + "</body>\n" + "</html>\n";
}
function finalHandler(req, res) {
    return function(err2) {
        let headers3;
        let msg4;
        let status2;
        if (err2) {
            status2 = getErrorStatusCode(err2);
            if (status2 === undefined) {
                status2 = getResponseStatusCode(res);
            } else {
                headers3 = getErrorHeaders(err2);
            }
            msg4 = getErrorMessage(err2, status2);
        } else {
            status2 = 404;
            msg4 = "Cannot " + req.method + " " + getResourceName(req);
        }
        send(req, res, status2, headers3, msg4);
    };
}
function getErrorHeaders(err2) {
    if (!err2.headers || typeof err2.headers !== "object") {
        return undefined;
    }
    const headers3 = Object.create(null);
    const keys = Object.keys(err2.headers);
    for(let i8 = 0; i8 < keys.length; i8++){
        const key1 = keys[i8];
        headers3[key1] = err2.headers[key1];
    }
    return headers3;
}
function getErrorMessage(err2, status2) {
    let msg4 = err2.stack;
    if (!msg4 && typeof err2.toString === "function") {
        msg4 = err2.toString();
    }
    return msg4 || STATUS_TEXT.get(status2);
}
function getErrorStatusCode(err2) {
    if (typeof err2.status === "number" && err2.status >= 400 && err2.status < 600) {
        return err2.status;
    }
    return undefined;
}
function getResourceName(req) {
    try {
        return parseUrl(req).pathname;
    } catch (e) {
        return "resource";
    }
}
function getResponseStatusCode(res) {
    let status2 = res.status;
    if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
        status2 = 500;
    }
    return status2;
}
function send(req, res, status2, headers3, message15) {
    const body = createHtmlDocument(message15);
    res.status = status2;
    res.statusMessage = STATUS_TEXT.get(status2);
    setHeaders(res, headers3);
    res.set("Content-Security-Policy", "default-src 'none'");
    res.set("X-Content-Type-Options", "nosniff");
    res.set("Content-Type", "text/html; charset=utf-8");
    if (req.method !== "HEAD") {
        res.body = body;
    }
    if (!res.written) {
        req.respond(res);
    }
}
function setHeaders(res, headers3) {
    if (!headers3) {
        return;
    }
    const keys = Object.keys(headers3);
    for(let i8 = 0; i8 < keys.length; i8++){
        const key1 = keys[i8];
        res.set(key1, headers3[key1]);
    }
}
const encoder4 = new TextEncoder();
const decoder3 = new TextDecoder();
function entitytag(entity) {
    if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    if (entity instanceof Uint8Array) {
        entity = decoder3.decode(entity);
    }
    const sha1 = new Sha1();
    sha1.update(entity);
    sha1.digest();
    const hash = sha1.toString().substring(0, 27);
    const len = typeof entity === "string" ? encoder4.encode(entity).byteLength : entity.byteLength;
    return `"${len.toString(16)}-${hash}"`;
}
function isstats(obj) {
    return obj && typeof obj === "object" && "atime" in obj && "mtime" in obj && "birthtime" in obj && "size" in obj && typeof obj.size === "number";
}
function stattag(stat) {
    const mtime = new Date(stat.mtime).getTime().toString(16);
    const size10 = stat.size.toString(16);
    return '"' + size10 + "-" + mtime + '"';
}
function etag(entity, options5) {
    if (entity == null) {
        throw new TypeError("argument entity is required");
    }
    let entityObj = entity;
    if (typeof entity === "string") {
        try {
            entityObj = JSON.parse(entity);
        } catch (_) {
        }
    }
    const isStats = isstats(entityObj);
    const weak = options5 && typeof options5.weak === "boolean" ? options5.weak : isStats;
    if (!isStats && typeof entity !== "string" && !(entity instanceof Uint8Array)) {
        throw new TypeError("argument entity must be string, Uint8Array, or Deno.FileInfo");
    }
    const tag = isStats ? stattag(entityObj) : entitytag(entity);
    return weak ? `W/${tag}` : tag;
}
function createETagGenerator(options5) {
    return function generateETag(body) {
        return etag(body, options5);
    };
}
const etag1 = createETagGenerator({
    weak: false
});
const wetag = createETagGenerator({
    weak: true
});
const compileETag = function(value7) {
    let fn;
    if (typeof value7 === "function") {
        return value7;
    }
    switch(value7){
        case true:
            fn = wetag;
            break;
        case false: break;
        case "strong":
            fn = etag1;
            break;
        case "weak":
            fn = wetag;
            break;
        default:
            throw new TypeError(`unknown value for etag function: ${value7}`);
    }
    return fn;
};
function newObject() {
    return {
    };
}
function parseExtendedQueryString(str3) {
    return export_default1.parse(str3, {
        allowPrototypes: true
    });
}
function compileQueryParser(value7) {
    if (typeof value7 === "function") {
        return value7;
    }
    switch(value7){
        case true:
            return parse3;
        case false:
            return newObject;
        case "extended":
            return parseExtendedQueryString;
        case "simple":
            return parse3;
        default:
            throw new TypeError(`unknown value for query parser function: ${value7}`);
    }
}
function forwarded(req) {
    if (!req) {
        throw new TypeError("argument req is required");
    }
    const proxyAddrs = parse16(req.headers.get("x-forwarded-for") ?? "");
    const { hostname: socketAddr  } = req.conn.remoteAddr;
    const addrs = [
        socketAddr
    ].concat(proxyAddrs);
    return addrs;
}
function parse16(header2) {
    const list = [];
    let start = header2.length;
    let end = header2.length;
    for(let i8 = header2.length - 1; i8 >= 0; i8--){
        switch(header2.charCodeAt(i8)){
            case 32:
                if (start === end) {
                    start = end = i8;
                }
                break;
            case 44:
                if (start !== end) {
                    list.push(header2.substring(start, end));
                }
                start = end = i8;
                break;
            default:
                start = i8;
                break;
        }
    }
    if (start !== end) {
        list.push(header2.substring(start, end));
    }
    return list;
}
const DIGIT_REGEXP = /^[0-9]+$/;
const isip = export_default2.isValid;
const parseip = export_default2.parse;
const IP_RANGES = {
    linklocal: [
        "169.254.0.0/16",
        "fe80::/10"
    ],
    loopback: [
        "127.0.0.1/8",
        "::1/128"
    ],
    uniquelocal: [
        "10.0.0.0/8",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "fc00::/7"
    ]
};
function all1(req, trust) {
    const addrs = forwarded(req);
    if (!trust) {
        return addrs;
    }
    if (typeof trust !== "function") {
        trust = compile(trust);
    }
    for(var i8 = 0; i8 < addrs.length - 1; i8++){
        if (trust(addrs[i8], i8)) continue;
        addrs.length = i8 + 1;
    }
    return addrs;
}
function compile(value7) {
    if (!value7) {
        throw new TypeError("argument is required");
    }
    let trust;
    if (typeof value7 === "string") {
        trust = [
            value7
        ];
    } else if (Array.isArray(value7)) {
        trust = value7.slice();
    } else {
        throw new TypeError("unsupported trust argument");
    }
    for(var i8 = 0; i8 < trust.length; i8++){
        value7 = trust[i8];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, value7)) {
            continue;
        }
        value7 = IP_RANGES[value7];
        trust.splice.apply(trust, [
            i8,
            1,
            ...value7
        ]);
        i8 += value7.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
    const rangeSubnets = new Array(arr.length);
    for(let i8 = 0; i8 < arr.length; i8++){
        rangeSubnets[i8] = parseipNotation(arr[i8]);
    }
    return rangeSubnets;
}
function compileTrust(rangeSubnets) {
    const len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
    const pos = note.lastIndexOf("/");
    const str3 = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str3)) {
        throw new TypeError("invalid IP address: " + str3);
    }
    let ip = parseip(str3);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
    }
    const max1 = ip.kind() === "ipv6" ? 128 : 32;
    let range1 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range1 === null) {
        range1 = max1;
    } else if (DIGIT_REGEXP.test(range1)) {
        range1 = parseInt(range1, 10);
    } else if (ip.kind() === "ipv4" && isip(range1)) {
        range1 = parseNetmask(range1);
    } else {
        range1 = null;
    }
    if (range1 <= 0 || range1 > max1) {
        throw new TypeError("invalid range on address: " + note);
    }
    return [
        ip,
        range1
    ];
}
function parseNetmask(netmask) {
    const ip = parseip(netmask);
    const kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
}
function proxyaddr(req, trust) {
    if (!req) {
        throw new TypeError("req argument is required");
    }
    if (!trust) {
        throw new TypeError("trust argument is required");
    }
    const addrs = all1(req, trust);
    const addr = addrs[addrs.length - 1];
    return addr;
}
function trustNone() {
    return false;
}
function trustMulti(subnets) {
    return function trust(addr) {
        if (!isip(addr)) return false;
        const ip = parseip(addr);
        let ipconv;
        const kind = ip.kind();
        for(let i8 = 0; i8 < subnets.length; i8++){
            const subnet = subnets[i8];
            const subnetip = subnet[0];
            const subnetkind = subnetip.kind();
            const subnetrange = subnet[1];
            let trusted = ip;
            if (kind !== subnetkind) {
                if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
                    continue;
                }
                if (!ipconv) {
                    ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                trusted = ipconv;
            }
            if (trusted.match(subnetip, subnetrange)) {
                return true;
            }
        }
        return false;
    };
}
function trustSingle(subnet) {
    const subnetip = subnet[0];
    const subnetkind = subnetip.kind();
    const subnetisipv4 = subnetkind === "ipv4";
    const subnetrange = subnet[1];
    return function trust(addr) {
        if (!isip(addr)) return false;
        let ip = parseip(addr);
        const kind = ip.kind();
        if (kind !== subnetkind) {
            if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
                return false;
            }
            ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
    };
}
function compileTrust1(value7) {
    if (typeof value7 === "function") return value7;
    if (value7 === true) {
        return function() {
            return true;
        };
    }
    if (typeof value7 === "number") {
        return function(_, i8) {
            return i8 < value7;
        };
    }
    if (typeof value7 === "string") {
        value7 = value7.split(/ *, */);
    }
    return compile(value7 || []);
}
function tryStat(path7) {
    try {
        return Deno.statSync(path7);
    } catch (e) {
        return undefined;
    }
}
function toPath(pathLike) {
    return pathLike.startsWith("file:") ? fromFileUrl2(pathLike) : pathLike;
}
class View {
    defaultEngine;
    ext;
    name;
    root;
    engine;
    path;
    constructor(fileName, options5 = {
    }){
        this.defaultEngine = options5.defaultEngine;
        this.ext = extname2(fileName);
        this.name = fileName;
        if (Array.isArray(options5.root)) {
            this.root = options5.root.map(toPath);
        } else {
            this.root = toPath(options5.root);
        }
        if (!this.ext && !this.defaultEngine) {
            throw new Error("No default engine was specified and no extension was provided.");
        }
        if (!this.ext) {
            this.ext = this.defaultEngine[0] !== "." ? `.${this.defaultEngine}` : this.defaultEngine;
            fileName += this.ext;
        }
        if (!options5.engines[this.ext]) {
            throw new Error(`Could not find a view engine for extension "${this.ext}"`);
        }
        this.engine = options5.engines[this.ext];
        this.path = this.lookup(fileName);
    }
    resolve(dir, file) {
        let path7 = join2(dir, file);
        let stat = tryStat(path7);
        if (stat && stat.isFile) {
            return path7;
        }
        const ext = this.ext;
        path7 = join2(dir, basename2(file, ext), `index${ext}`);
        stat = tryStat(path7);
        if (stat && stat.isFile) {
            return path7;
        }
    }
    lookup(name) {
        const roots = [].concat(this.root);
        let path7;
        for(let i8 = 0; i8 < roots.length && !path7; i8++){
            const root = roots[i8];
            const loc = resolve2(root, name);
            const dir = dirname2(loc);
            const file = basename2(loc);
            path7 = this.resolve(dir, file);
        }
        return path7;
    }
    async render(options, callback) {
        const out = await this.engine(this.path, options);
        callback(undefined, out);
    }
}
const create1 = Object.create;
const setPrototypeOf2 = Object.setPrototypeOf;
const slice = Array.prototype.slice;
const trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
const app1 = {
};
app1.init = function init1() {
    this.cache = {
    };
    this.engines = {
    };
    this.settings = {
    };
    this.defaultConfiguration();
};
app1.defaultConfiguration = function defaultConfiguration() {
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
    });
    const self = this;
    this.on("mount", function onmount(parent) {
        if (self.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
            delete self.settings["trust proxy"];
            delete self.settings["trust proxy fn"];
        }
        setPrototypeOf2(self.request, parent.request);
        setPrototypeOf2(self.response, parent.response);
        setPrototypeOf2(self.engines, parent.engines);
        setPrototypeOf2(self.settings, parent.settings);
    });
    this.locals = create1(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View);
    this.set("views", resolve2("views"));
    this.set("jsonp callback name", "callback");
    this.enable("view cache");
};
app1.lazyrouter = function lazyrouter() {
    if (!this._router) {
        this._router = new Router({
            caseSensitive: this.enabled("case sensitive routing"),
            strict: this.enabled("strict routing")
        });
        this._router.use(query(this.get("query parser fn")));
        this._router.use(init(this));
    }
};
app1.handle = function handle2(req, res, next) {
    const router = this._router;
    req = requestProxy(req);
    next = next || finalHandler(req, res);
    if (!router) {
        return next();
    }
    router.handle(req, res, next);
};
const isPath = (thing)=>typeof thing === "string" || thing instanceof RegExp
;
app1.use = function use1(...args2) {
    const firstArg = args2[0];
    const [path7, ...nonPathArgs] = (Array.isArray(firstArg) ? isPath(firstArg[0]) : isPath(firstArg)) ? args2 : [
        "/",
        ...args2
    ];
    const fns = nonPathArgs.flat(Infinity);
    if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    const router = this._router;
    fns.forEach(function(fn) {
        if (!fn || !fn.handle || !fn.set) {
            return router.use(path7, fn);
        }
        fn.mountpath = path7;
        fn.parent = this;
        router.use(path7, function mounted_app(req, res, next) {
            const orig = req.app;
            fn.handle(req, res, (err2)=>{
                setPrototypeOf2(req, orig.request);
                setPrototypeOf2(res, orig.response);
                next(err2);
            });
        });
        fn.emit("mount", this);
    }, this);
    return this;
};
app1.route = function route1(prefix) {
    this.lazyrouter();
    return this._router.route(prefix);
};
app1.engine = function engine(ext, fn) {
    const extension = ext[0] !== "." ? `.${ext}` : ext;
    this.engines[extension] = fn;
    return this;
};
app1.param = function param1(name13, fn) {
    this.lazyrouter();
    if (Array.isArray(name13)) {
        for(var i8 = 0; i8 < name13.length; i8++){
            this.param(name13[i8], fn);
        }
        return this;
    }
    this._router.param(name13, fn);
    return this;
};
app1.set = function set(setting, value7) {
    if (arguments.length === 1) {
        return this.settings[setting];
    }
    this.settings[setting] = value7;
    switch(setting){
        case "etag":
            this.set("etag fn", compileETag(value7));
            break;
        case "query parser":
            this.set("query parser fn", compileQueryParser(value7));
            break;
        case "trust proxy":
            this.set("trust proxy fn", compileTrust1(value7));
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: false
            });
            break;
    }
    return this;
};
app1.path = function path7() {
    return this.parent ? this.parent.path() + this.mountpath : "";
};
app1.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
};
app1.disabled = function disabled(setting) {
    return !this.set(setting);
};
app1.enable = function enable(setting) {
    return this.set(setting, true);
};
app1.disable = function disable(setting) {
    return this.set(setting, false);
};
methods.forEach((method)=>{
    app1[method] = function(path8) {
        if (method === "get" && arguments.length === 1) {
            return this.set(path8);
        }
        this.lazyrouter();
        const route2 = this._router.route(path8);
        route2[method].apply(route2, slice.call(arguments, 1));
        return this;
    };
});
app1.all = function all2(path8) {
    this.lazyrouter();
    const route2 = this._router.route(path8);
    const args2 = slice.call(arguments, 1);
    for(let i9 = 0; i9 < methods.length; i9++){
        route2[methods[i9]].apply(route2, args2);
    }
    return this;
};
async function tryRender(view, options6, callback) {
    try {
        await view.render(options6, callback);
    } catch (err2) {
        callback(err2);
    }
}
app1.render = function render(name13, options6, callback = ()=>{
}) {
    const cache = this.cache;
    const engines = this.engines;
    const renderOptions = {
    };
    let done = callback;
    let view;
    name13 = name13.startsWith("file:") ? fromFileUrl2(name13) : name13;
    if (typeof options6 === "function") {
        done = options6;
        options6 = {
        };
    }
    merge(renderOptions, this.locals);
    if (options6._locals) {
        merge(renderOptions, options6._locals);
    }
    merge(renderOptions, options6);
    if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
        view = cache[name13];
    }
    if (!view) {
        const View1 = this.get("view");
        view = new View1(name13, {
            defaultEngine: this.get("view engine"),
            engines,
            root: this.get("views")
        });
        if (!view.path) {
            const dirs = Array.isArray(view.root) && view.root.length > 1 ? `directories "${view.root.slice(0, -1).join('", "')}" or "${view.root[view.root.length - 1]}"` : `directory "${view.root}"`;
            const err2 = new Error(`Failed to lookup view "${name13}" in views ${dirs}`);
            err2.view = view;
            return done(err2);
        }
        if (renderOptions.cache) {
            cache[name13] = view;
        }
    }
    tryRender(view, renderOptions, done);
};
app1.listen = function listen(options6, callback) {
    if (typeof options6 === "undefined") {
        options6 = {
            port: 0
        };
    } else if (typeof options6 === "number") {
        options6 = `:${options6}`;
    }
    const isTlsOptions = typeof options6 !== "string" && typeof options6.certFile !== "undefined";
    const server = isTlsOptions ? serveTLS(options6) : serve(options6);
    const start = async ()=>{
        try {
            for await (const request of server){
                this(request);
            }
        } catch (serverError) {
            if (server) {
                try {
                    server.close();
                } catch (err2) {
                    if (!(err2 instanceof Deno.errors.BadResource)) {
                        throw err2;
                    }
                }
            }
            throw serverError;
        }
    };
    start();
    if (callback && typeof callback === "function") callback();
    return server;
};
function defineGetter(obj, name13, getter) {
    Object.defineProperty(obj, name13, {
        configurable: true,
        enumerable: true,
        get: getter
    });
}
const CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
function fresh1(reqHeaders, resHeaders) {
    const modifiedSince = reqHeaders["if-modified-since"];
    const noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
        return false;
    }
    const cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
    }
    if (noneMatch && noneMatch !== "*") {
        const etag2 = resHeaders["etag"];
        if (!etag2) {
            return false;
        }
        let etagStale = true;
        const matches = parseTokenList(noneMatch);
        for(let i9 = 0; i9 < matches.length; i9++){
            const match1 = matches[i9];
            if (match1 === etag2 || match1 === "W/" + etag2 || "W/" + match1 === etag2) {
                etagStale = false;
                break;
            }
        }
        if (etagStale) {
            return false;
        }
    }
    if (modifiedSince) {
        const lastModified = resHeaders["last-modified"];
        const modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
            return false;
        }
    }
    return true;
}
function parseHttpDate(date) {
    const timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList(str3) {
    const list = [];
    let start = 0;
    let end = 0;
    for(let i9 = 0, len = str3.length; i9 < len; i9++){
        switch(str3.charCodeAt(i9)){
            case 32:
                if (start === end) {
                    start = end = i9 + 1;
                }
                break;
            case 44:
                list.push(str3.substring(start, end));
                start = end = i9 + 1;
                break;
            default:
                end = i9 + 1;
                break;
        }
    }
    list.push(str3.substring(start, end));
    return list;
}
const request = Object.create(ServerRequest.prototype);
request.accepts = function(...args2) {
    const accept = new Accepts(this.headers);
    return accept.types.call(accept, args2.flat(1));
};
request.acceptsCharsets = function(...args2) {
    const accept = new Accepts(this.headers);
    return accept.charsets.call(accept, args2.flat(1));
};
request.acceptsEncodings = function(...args2) {
    const accept = new Accepts(this.headers);
    return accept.encodings.call(accept, args2.flat(1));
};
request.acceptsLanguages = function(...args2) {
    const accept = new Accepts(this.headers);
    return accept.languages.call(accept, args2.flat(1));
};
request.get = function get(name13) {
    const lc = name13.toLowerCase();
    switch(lc){
        case "referer":
        case "referrer":
            return this.headers.get("referrer") || this.headers.get("referer") || undefined;
        default:
            return this.headers.get(lc) || undefined;
    }
};
request.range = function range1(size10, options6) {
    const range1 = this.get("Range");
    if (!range1) return;
    return export_default(size10, range1, options6);
};
request.is = function is1(types5) {
    let arr = types5;
    if (!Array.isArray(types5)) {
        arr = new Array(arguments.length);
        for(let i9 = 0; i9 < arr.length; i9++){
            arr[i9] = arguments[i9];
        }
    }
    return typeofrequest(this.headers, arr);
};
defineGetter(request, "protocol", function protocol2() {
    const proto = this.proto.includes("https") ? "https" : "http";
    const trust = this.app.get("trust proxy fn");
    const { hostname: remoteAddress  } = this.conn.remoteAddr;
    if (!trust(remoteAddress, 0)) {
        return proto;
    }
    const header2 = this.get("X-Forwarded-Proto") ?? proto;
    const index = header2.indexOf(",");
    return index !== -1 ? header2.substring(0, index).trim() : header2.trim();
});
defineGetter(request, "secure", function secure() {
    return this.protocol === "https";
});
defineGetter(request, "ip", function ip() {
    const trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
});
defineGetter(request, "ips", function ips() {
    const trust = this.app.get("trust proxy fn");
    const addrs = all1(this, trust);
    addrs.reverse().pop();
    return addrs;
});
defineGetter(request, "subdomains", function subdomains() {
    const hostname = this.hostname;
    if (!hostname) return [];
    const offset = this.app.get("subdomain offset");
    const subdomains = !isIP(hostname) ? hostname.split(".").reverse() : [
        hostname
    ];
    return subdomains.slice(offset);
});
defineGetter(request, "path", function path8() {
    return (parseUrl(this) || {
    }).pathname;
});
defineGetter(request, "hostname", function hostname() {
    const trust = this.app.get("trust proxy fn");
    let host1 = this.get("X-Forwarded-Host");
    const { hostname: remoteAddress  } = this.conn.remoteAddr;
    if (!host1 || !trust(remoteAddress, 0)) {
        host1 = this.get("Host");
    } else if (host1.indexOf(",") !== -1) {
        host1 = host1.substring(0, host1.indexOf(",")).trimRight();
    }
    if (!host1) return;
    const offset = host1[0] === "[" ? host1.indexOf("]") + 1 : 0;
    const index = host1.indexOf(":", offset);
    return index !== -1 ? host1.substring(0, index) : host1;
});
defineGetter(request, "fresh", function() {
    const method = this.method;
    const res = this.res;
    const status2 = res.status;
    if ("GET" !== method && "HEAD" !== method) {
        return false;
    }
    if (status2 >= 200 && status2 < 300 || 304 === status2) {
        return fresh1(Object.fromEntries(this.headers), {
            "etag": res.get("ETag"),
            "last-modified": res.get("Last-Modified")
        });
    }
    return false;
});
defineGetter(request, "stale", function stale() {
    return !this.fresh;
});
defineGetter(request, "xhr", function xhr() {
    const val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
});
const ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
const HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
const NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
const QUOTE_REGEXP = /([\\"])/g;
const TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
const TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
function getLatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function createParams(filename) {
    if (filename === undefined) {
        return;
    }
    const params = {
    };
    if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
    }
    const name13 = basename2(filename);
    const isQuotedString = TEXT_REGEXP.test(name13);
    const fallbackName = getLatin1(name13);
    const hasFallback = typeof fallbackName === "string" && fallbackName !== name13;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name13)) {
        params["filename*"] = name13;
    }
    if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name13;
    }
    return params;
}
function qString(val) {
    const str3 = String(val);
    return '"' + str3.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function pencode(__char1) {
    return "%" + String(__char1).charCodeAt(0).toString(16).toUpperCase();
}
function uString(val) {
    const str3 = String(val);
    const encoded = encodeURIComponent(str3).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
}
function format12({ type: type4 , parameters  }) {
    if (!type4 || typeof type4 !== "string" || !TOKEN_REGEXP.test(type4)) {
        throw new TypeError("invalid type");
    }
    let string = String(type4).toLowerCase();
    if (parameters && typeof parameters === "object") {
        let param2;
        const params = Object.keys(parameters).sort();
        for(let i9 = 0; i9 < params.length; i9++){
            param2 = params[i9];
            const val = param2.substr(-1) === "*" ? uString(parameters[param2]) : qString(parameters[param2]);
            string += "; " + param2 + "=" + val;
        }
    }
    return string;
}
const contentDisposition = (type4, filename)=>{
    const parameters = createParams(filename);
    return format12({
        type: type4,
        parameters
    });
};
function stringify(value7, replacer, spaces, escape) {
    let json = replacer || spaces ? JSON.stringify(value7, replacer, spaces) : JSON.stringify(value7);
    if (escape) {
        json = json.replace(/[<>&]/g, function(c5) {
            switch(c5.charCodeAt(0)){
                case 60:
                    return "\\u003c";
                case 62:
                    return "\\u003e";
                case 38:
                    return "\\u0026";
                default:
                    return c5;
            }
        });
    }
    return json;
}
function acceptParams(str3) {
    const parts = str3.split(/ *; */);
    const ret1 = {
        value: parts[0],
        quality: 1,
        params: {
        }
    };
    for(let i9 = 1; i9 < parts.length; ++i9){
        const pms = parts[i9].split(/ *= */);
        if ("q" === pms[0]) {
            ret1.quality = parseFloat(pms[1]);
        } else {
            ret1.params[pms[0]] = pms[1];
        }
    }
    return ret1;
}
const normalizeType1 = function(type4) {
    return ~type4.indexOf("/") ? acceptParams(type4) : {
        value: lookup(type4),
        params: {
        }
    };
};
const normalizeTypes = function(types5) {
    const ret1 = [];
    for(let i9 = 0; i9 < types5.length; ++i9){
        ret1.push(normalizeType1(types5[i9]));
    }
    return ret1;
};
function hasCookieNameProperty(value7) {
    return value7 && typeof value7 === "object" && typeof value7.name === "string";
}
function hasCookieRequiredProperties(value7) {
    return hasCookieNameProperty(value7) && typeof value7.value === "string";
}
const BYTES_RANGE_REGEXP = /^ *bytes=/;
const MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000;
const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
const ENOENT_REGEXP = /\(os error 2\)$/;
const ENAMETOOLONG_REGEXP = /\(os error 63\)$/;
function normalizeList(value7, name13) {
    const list = value7 === false ? [] : Array.isArray(value7) ? value7 : [
        value7
    ];
    for(let i9 = 0; i9 < list.length; i9++){
        if (typeof list[i9] !== "string") {
            throw new TypeError(name13 + " must be array of strings or false");
        }
    }
    return list;
}
function containsDotFile(parts) {
    for(let i9 = 0; i9 < parts.length; i9++){
        const part = parts[i9];
        if (part.length > 1 && part[0] === ".") {
            return true;
        }
    }
    return false;
}
function hasTrailingSlash(path9) {
    return path9[path9.length - 1] === "/";
}
function isConditionalGET(req) {
    return Boolean(req.headers.get("if-match") || req.headers.get("if-unmodified-since") || req.headers.get("if-none-match") || req.headers.get("if-modified-since"));
}
function isPreconditionFailure(req, res) {
    const match1 = req.headers.get("if-match");
    if (match1) {
        const etag2 = res.get("ETag");
        return !etag2 || match1 !== "*" && parseTokenList(match1).every(function(match2) {
            return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
        });
    }
    const unmodifiedSince = parseHttpDate(req.get("if-unmodified-since"));
    if (!isNaN(unmodifiedSince)) {
        const lastModified = parseHttpDate(res.get("Last-Modified"));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
}
function contentRange(type4, size10, range2) {
    return type4 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size10;
}
function removeContentHeaderFields(res) {
    const headers3 = Array.from(res.headers?.keys() ?? []);
    for (const header2 of headers3){
        if (header2.substr(0, 8) === "content-" && header2 !== "content-location") {
            res.unset(header2);
        }
    }
}
function isCachable(statusCode) {
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
}
function isRangeFresh(req, res) {
    const ifRange = req.get("if-range");
    if (!ifRange) {
        return true;
    }
    if (ifRange.indexOf('"') !== -1) {
        const etag2 = res.get("ETag");
        return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    const lastModified = res.get("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
}
function collapseLeadingSlashes(str3) {
    for(var i9 = 0; i9 < str3.length; i9++){
        if (str3[i9] !== "/") {
            break;
        }
    }
    return i9 > 1 ? "/" + str3.substr(i9) : str3;
}
function clearHeaders(res) {
    const headers3 = Array.from(res.headers?.keys() ?? []);
    for (const header2 of headers3){
        res.unset(header2);
    }
}
function create404Error() {
    const error1 = new Deno.errors.NotFound();
    error1.status = 404;
    error1.statusCode = 404;
    return error1;
}
function sendError(res, error1) {
    clearHeaders(res);
    if (error1?.headers) {
        res.set(error1.headers);
    }
    if (!error1) {
        throw createError(create404Error(), {
            code: "ENOENT"
        });
    } else if (ENOENT_REGEXP.test(error1.message)) {
        throw createError(create404Error(), {
            code: "ENOENT"
        });
    } else if (ENAMETOOLONG_REGEXP.test(error1.message)) {
        throw createError(create404Error(), {
            code: "ENAMETOOLONG"
        });
    } else if (error1.status === 404 || error1.statusCode === 404) {
        throw createError(create404Error(), {
            code: error1.code
        });
    }
    throw createError((error1.status ?? error1.statusCode) ?? 500, error1.message, {
        code: error1.code
    });
}
async function offsetFileReader(file, offset, contentLength) {
    let totalRead = 0;
    let finished = false;
    await file.seek(offset, Deno.SeekMode.Start);
    async function read(buf) {
        if (finished) return null;
        let result;
        const remaining = contentLength - totalRead;
        if (remaining >= buf.byteLength) {
            result = await file.read(buf);
        } else {
            const readBuf = buf.subarray(0, remaining);
            result = await file.read(readBuf);
        }
        if (result !== null) {
            totalRead += result;
        }
        finished = totalRead === contentLength;
        return result;
    }
    return {
        read
    };
}
async function _send(req, res, path9, options6, stat) {
    if (res.written) {
        return sendError(res, createError(500, "Response already written"));
    }
    if (options6.before) {
        options6.before(res, path9, stat);
    }
    const cacheControl = Boolean(options6.cacheControl ?? true);
    if (cacheControl && !res.get("Cache-Control")) {
        let maxage = options6.maxAge ?? options6.maxage;
        maxage = typeof maxage === "string" ? export_default3(maxage) : Number(maxage);
        maxage = !isNaN(maxage) ? Math.min(Math.max(0, maxage), MAX_MAXAGE) : 0;
        let cacheControlHeader = "public, max-age=" + Math.floor(maxage / 1000);
        const immutable = Boolean(options6.immutable ?? false);
        if (immutable) {
            cacheControlHeader += ", immutable";
        }
        res.set("Cache-Control", cacheControlHeader);
    }
    const lastModified = Boolean(options6.lastModified ?? true);
    if (lastModified && !res.get("Last-Modified") && stat.mtime) {
        res.set("Last-Modified", stat.mtime.toUTCString());
    }
    const etag2 = Boolean(options6.etag ?? true);
    if (etag2 && !res.get("ETag")) {
        res.etag(stat);
    }
    if (!res.get("Content-Type")) {
        res.type(extname2(path9));
    }
    const acceptRanges = Boolean(options6.acceptRanges ?? true);
    if (acceptRanges && !res.get("Accept-Ranges")) {
        res.set("Accept-Ranges", "bytes");
    }
    if (isConditionalGET(req)) {
        if (isPreconditionFailure(req, res)) {
            return sendError(res, createError(412));
        }
        if (isCachable(res.status) && req.fresh) {
            removeContentHeaderFields(res);
            res.status = 304;
            return await res.end();
        }
    }
    let offset = options6.start ?? 0;
    let len = stat.size;
    len = Math.max(0, len - offset);
    if (options6.end !== undefined) {
        const bytes = options6.end - offset + 1;
        if (len > bytes) {
            len = bytes;
        }
    }
    const rangeHeader = req.headers.get("range");
    if (acceptRanges && BYTES_RANGE_REGEXP.test(rangeHeader)) {
        let range2 = req.range(len, {
            combine: true
        });
        if (!isRangeFresh(req, res)) {
            range2 = -2;
        }
        if (range2 === -1) {
            res.set("Content-Range", contentRange("bytes", len));
            return sendError(res, createError(416, undefined, {
                headers: {
                    "Content-Range": res.get("Content-Range")
                }
            }));
        }
        if (range2 !== -2 && range2?.length === 1) {
            res.setStatus(206);
            res.set("Content-Range", contentRange("bytes", len, range2[0]));
            offset += range2[0].start;
            len = range2[0].end - range2[0].start + 1;
        }
    }
    const file = await Deno.open(path9, {
        read: true
    });
    res.addResource(file.rid);
    res.set("Content-Length", len + "");
    return await res.send(await offsetFileReader(file, offset, len));
}
async function sendIndex(req, res, path9, options6, index) {
    let error1;
    for (const i9 of index){
        const pathUsingIndex = join2(path9, i9);
        try {
            const stat = await Deno.stat(pathUsingIndex);
            if (!stat.isDirectory) {
                return await _send(req, res, pathUsingIndex, options6, stat);
            } else if (options6.onDirectory) {
                return options6.onDirectory();
            }
        } catch (err2) {
            error1 = err2;
        }
    }
    return sendError(res, error1);
}
async function sendExtension(req, res, path9, options6) {
    let error1;
    const extensions3 = options6.extensions !== undefined ? normalizeList(options6.extensions, "extensions option") : [];
    for (const extension of extensions3){
        const pathUsingExtension = `${path9}.${extension}`;
        try {
            const stat = await Deno.stat(pathUsingExtension);
            if (!stat.isDirectory) {
                return await _send(req, res, pathUsingExtension, options6, stat);
            } else if (options6.onDirectory) {
                return options6.onDirectory();
            }
        } catch (err2) {
            error1 = err2;
        }
    }
    return sendError(res, error1);
}
async function sendFile(req, res, path9, options6) {
    try {
        const stat = await Deno.stat(path9);
        if (!stat.isDirectory) {
            return await _send(req, res, path9, options6, stat);
        } else if (options6.onDirectory) {
            return options6.onDirectory();
        }
        if (hasTrailingSlash(path9)) {
            return sendError(res, createError(403));
        }
        res.set("Content-Type", "text/html; charset=UTF-8");
        res.set("Content-Security-Policy", "default-src 'none'");
        res.set("X-Content-Type-Options", "nosniff");
        return res.redirect(301, collapseLeadingSlashes(path9 + "/"));
    } catch (err2) {
        if (ENOENT_REGEXP.test(err2.message) && !extname2(path9) && path9[path9.length - 1] !== sep2) {
            return await sendExtension(req, res, path9, options6);
        }
        return sendError(res, err2);
    }
}
function decode1(path9) {
    try {
        return decodeURIComponent(path9);
    } catch (_err) {
        return -1;
    }
}
async function send1(req, res, path9, options6) {
    const decodedPath = decode1(path9);
    if (decodedPath === -1) {
        return sendError(res, createError(400));
    }
    path9 = decodedPath;
    if (~path9.indexOf("\0")) {
        return sendError(res, createError(400));
    }
    const root = options6.root ? resolve2(options6.root) : null;
    let parts;
    if (root !== null) {
        if (path9) {
            path9 = normalize2("." + sep2 + path9);
        }
        if (UP_PATH_REGEXP.test(path9)) {
            return sendError(res, createError(403));
        }
        parts = path9.split(sep2);
        path9 = normalize2(join2(root, path9));
    } else {
        if (UP_PATH_REGEXP.test(path9)) {
            return sendError(res, createError(403));
        }
        parts = normalize2(path9).split(sep2);
        path9 = normalize2(path9);
    }
    if (containsDotFile(parts)) {
        const dotfiles = options6.dotfiles ?? "ignore";
        if (dotfiles !== "ignore" && dotfiles !== "allow" && dotfiles !== "deny") {
            return sendError(res, new TypeError('dotfiles option must be "allow", "deny", or "ignore"'));
        }
        switch(dotfiles){
            case "allow": break;
            case "deny":
                return sendError(res, createError(403));
            case "ignore":
            default:
                return sendError(res, createError(404));
        }
    }
    const index = options6.index !== undefined ? normalizeList(options6.index, "index option") : [
        "index.html"
    ];
    if (index.length && hasTrailingSlash(path9)) {
        return await sendIndex(req, res, path9, options6, index);
    }
    return await sendFile(req, res, path9, options6);
}
class Response1 {
    status = 200;
    headers = new Headers();
    written = false;
    body;
    app;
    req;
    locals;
    #resources = [];
    addResource(rid) {
        this.#resources.push(rid);
    }
    append(field, value) {
        if (Array.isArray(value)) {
            for(let i9 = 0, len = value.length; i9 < len; i9++){
                this.headers.append(field, value[i9]);
            }
        } else {
            this.headers.append(field, value);
        }
        return this;
    }
    attachment(filename) {
        if (filename) {
            this.type(extname2(filename));
        }
        this.set("Content-Disposition", contentDisposition("attachment", filename));
        return this;
    }
    cookie(nameOrCookie) {
        let cookie;
        if (typeof nameOrCookie === "string") {
            cookie = {
                ...arguments[2],
                name: nameOrCookie,
                value: arguments[1] ?? ""
            };
        } else if (hasCookieRequiredProperties(nameOrCookie)) {
            cookie = nameOrCookie;
        } else {
            throw new TypeError("response.cookie, args provided do not match one of the supported signatures: " + Array.prototype.join.call(arguments, ", "));
        }
        if (cookie.path == null) {
            cookie.path = "/";
        }
        setCookie(this, cookie);
        return this;
    }
    clearCookie(nameOrCookie) {
        if (typeof nameOrCookie === "string") {
            setCookie(this, {
                path: "/",
                ...arguments[1],
                value: "",
                expires: new Date(0),
                name: nameOrCookie
            });
        } else if (hasCookieNameProperty(nameOrCookie)) {
            setCookie(this, {
                path: "/",
                ...nameOrCookie,
                value: "",
                expires: new Date(0)
            });
        } else {
            throw new TypeError("res.clearCookie, args provided do not match one of the supported signatures: " + Array.prototype.join.call(arguments, ", "));
        }
        return this;
    }
    async download(path, filename, options) {
        const headers3 = {
            "Content-Disposition": contentDisposition("attachment", filename || path)
        };
        if (options?.headers) {
            const keys = Object.keys(options.headers);
            for(let i9 = 0; i9 < keys.length; i9++){
                const key1 = keys[i9];
                if (key1.toLowerCase() !== "content-disposition") {
                    headers3[key1] = options.headers[key1];
                }
            }
        }
        options = {
            ...options,
            headers: headers3
        };
        const fullPath = resolve2(path.startsWith("file:") ? fromFileUrl2(path) : path);
        return await this.sendFile(fullPath, options);
    }
    async end(body) {
        if (body) {
            this.body = body;
        }
        this.written = true;
        try {
            await this.req.respond(this);
        } catch (e) {
            if (!(e instanceof Deno.errors.BadResource)) {
                throw e;
            }
        }
        for (const rid of this.#resources){
            try {
                Deno.close(rid);
            } catch (e) {
                if (!(e instanceof Deno.errors.BadResource)) {
                    throw e;
                }
            }
        }
        this.#resources = [];
    }
    etag(chunk) {
        const etagFn = this.app.get("etag fn");
        if (typeof etagFn === "function" && typeof chunk.length) {
            const etag2 = etagFn(chunk);
            if (etag2) {
                this.set("ETag", etag2);
            }
        }
        return this;
    }
    format(obj) {
        const req = this.req;
        const next = req.next;
        const { default: fn , ...rest } = obj;
        const keys = Object.keys(rest);
        const accepts = keys.length > 0 ? req.accepts(keys) : false;
        this.vary("Accept");
        if (accepts) {
            const key1 = Array.isArray(accepts) ? accepts[0] : accepts;
            this.set("Content-Type", normalizeType1(key1).value);
            obj[key1](req, this, next);
        } else if (fn) {
            fn();
        } else {
            const err2 = new Error("Not Acceptable");
            err2.status = err2.statusCode = 406;
            err2.types = normalizeTypes(keys).map(function(o1) {
                return o1.value;
            });
            next(err2);
        }
        return this;
    }
    get(field) {
        return this.headers.get(field.toLowerCase()) || "";
    }
    json(body) {
        const app2 = this.app;
        const replacer = app2.get("json replacer");
        const spaces = app2.get("json spaces");
        const escape = app2.get("json escape");
        body = stringify(body, replacer, spaces, escape);
        if (!this.get("Content-Type")) {
            this.type("application/json");
        }
        return this.send(body);
    }
    jsonp(body) {
        const app2 = this.app;
        const replacer = app2.get("json replacer");
        const spaces = app2.get("json spaces");
        const escape = app2.get("json escape");
        body = stringify(body, replacer, spaces, escape);
        let callback = this.req.query[app2.get("jsonp callback name")];
        if (Array.isArray(callback)) {
            callback = callback[0];
        }
        if (typeof callback === "string" && callback.length !== 0) {
            this.set("X-Content-Type-Options", "nosniff");
            this.type("text/javascript");
            callback = callback.replace(/[^\[\]\w$.]/g, "");
            body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
            body = `/**/ typeof ${callback} === 'function' && ${callback}(${body});`;
        } else if (!this.get("Content-Type")) {
            this.set("X-Content-Type-Options", "nosniff");
            this.set("Content-Type", "application/json");
        }
        return this.send(body);
    }
    links(links) {
        let currentLink = this.get("Link");
        if (currentLink) {
            currentLink += ", ";
        }
        const link = currentLink + Object.entries(links).map(([rel, field2])=>`<${field2}>; rel="${rel}"`
        ).join(", ");
        return this.set("Link", link);
    }
    location(url) {
        const loc = url === "back" ? this.req.get("Referrer") || "/" : url;
        return this.set("Location", encodeUrl(loc));
    }
    redirect() {
        let address;
        let body = "";
        let status3;
        if (arguments.length === 0) {
            throw new TypeError("res.redirect: requires a location url");
        } else if (arguments.length === 1) {
            address = arguments[0] + "";
            status3 = 302;
        } else {
            if (typeof arguments[0] !== "number" || Number.isNaN(arguments[0])) {
                throw new TypeError("res.redirect: expected status code to be a valid number");
            }
            address = arguments[1] + "";
            status3 = arguments[0];
        }
        address = this.location(address).get("Location");
        this.format({
            text: function _renderRedirectBody() {
                body = `${STATUS_TEXT.get(status3)}. Redirecting to ${address}`;
            },
            html: function _renderRedirectHtmlBoby() {
                const u = escapeHtml(address);
                body = `<p>${STATUS_TEXT.get(status3)}. Redirecting to <a href="${u}">${u}</a></p>`;
            },
            default: function _renderDefaultRedirectBody() {
                body = "";
            }
        });
        this.status = status3;
        if (this.req.method === "HEAD") {
            this.end();
        } else {
            this.end(body);
        }
    }
    render(view, options = {
    }, callback) {
        const app2 = this.req.app;
        const req = this.req;
        const self = this;
        let done = callback;
        if (typeof options === "function") {
            done = options;
            options = {
            };
        }
        options._locals = self.locals;
        done = done || function(err2, str3) {
            if (err2) {
                return req.next(err2);
            }
            self.send(str3);
        };
        app2.render(view, options, done);
    }
    send(body) {
        let chunk;
        const isUndefined = body === undefined;
        if (isUndefined || body === null) {
            body = "";
        }
        switch(typeof body){
            case "string":
                chunk = body;
                break;
            case "boolean":
            case "number":
                return this.json(body);
            case "object":
            default:
                if (body instanceof Uint8Array || typeof body.read === "function") {
                    chunk = body;
                    if (!this.get("Content-Type")) {
                        this.type("bin");
                    }
                } else {
                    return this.json(body);
                }
        }
        if (typeof chunk === "string" && !this.get("Content-Type")) {
            this.type("html");
        }
        if (!this.get("ETag") && (typeof chunk === "string" || chunk instanceof Uint8Array) && !isUndefined) {
            this.etag(chunk);
        }
        if (this.req.fresh) {
            this.status = 304;
        }
        if (this.status === 204 || this.status === 304) {
            this.unset("Content-Type");
            this.unset("Content-Length");
            this.unset("Transfer-Encoding");
            chunk = "";
        }
        if (this.req.method === "HEAD") {
            this.end();
        } else {
            this.end(chunk);
        }
        return this;
    }
    async sendFile(path, options = {
    }) {
        if (!path) {
            throw new TypeError("path argument is required to res.sendFile");
        } else if (typeof path !== "string") {
            throw new TypeError("path must be a string to res.sendFile");
        }
        path = path.startsWith("file:") ? fromFileUrl2(path) : path;
        if (!options.root && !isAbsolute2(path)) {
            throw new TypeError("path must be absolute or specify root to res.sendFile");
        }
        const onDirectory = async ()=>{
            let stat;
            try {
                stat = await Deno.stat(path);
            } catch (err2) {
                return sendError(this, err2);
            }
            if (stat.isDirectory) {
                return sendError(this);
            }
        };
        options.onDirectory = onDirectory;
        if (options.headers) {
            const obj = options.headers;
            const keys = Object.keys(obj);
            for(let i9 = 0; i9 < keys.length; i9++){
                const k = keys[i9];
                this.set(k, obj[k]);
            }
        }
        return await send1(this.req, this, path, options);
    }
    sendStatus(code) {
        const body = STATUS_TEXT.get(code) || String(code);
        this.setStatus(code);
        this.type("txt");
        return this.send(body);
    }
    set(field, value) {
        if (arguments.length === 2) {
            const lowerCaseField = (field + "").toLowerCase();
            const coercedVal = value + "";
            if (lowerCaseField === "content-type") {
                this.type(coercedVal);
            } else {
                this.headers.set(lowerCaseField, coercedVal);
            }
        } else if (typeof field === "object" && field) {
            const entries = Object.entries(field);
            for (const [key1, val] of entries){
                this.set(key1, val);
            }
        }
        return this;
    }
    setStatus(code) {
        this.status = code;
        return this;
    }
    type(type) {
        const ct = contentType(type) || "application/octet-stream";
        this.headers.set("content-type", ct);
        return this;
    }
    unset(field) {
        this.headers.delete(field);
        return this;
    }
    vary(field) {
        vary(this.headers, field);
        return this;
    }
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function mergeDescriptors(dest, src, redefine = true) {
    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name13) {
        if (!redefine && hasOwnProperty.call(dest, name13)) {
            return;
        }
        const descriptor = Object.getOwnPropertyDescriptor(src, name13);
        Object.defineProperty(dest, name13, descriptor);
    });
    return dest;
}
const response = Object.create(Response1.prototype);
function opine() {
    const app2 = function(req, res = new Response1(), next) {
        app2.handle(req, res, next);
    };
    const eventEmitter = new __default();
    app2.emit = (event, ...args2)=>eventEmitter.emit(event, ...args2)
    ;
    app2.on = (event, arg)=>eventEmitter.on(event, arg)
    ;
    mergeDescriptors(app2, app1, false);
    app2.request = Object.create(request, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app2
        }
    });
    app2.response = Object.create(response, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app2
        }
    });
    app2.init();
    return app2;
}
async function makeRequest(endpoint) {
    const res = await fetch(endpoint);
    return await res.json();
}
const endpoint = 'https://api.ipify.org';
async function getIP() {
    return (await makeRequest(`${endpoint}?format=json`)).ip;
}
async function getIPLocation(ip1) {
    const currentIP = ip1 ? ip1 : await getIP();
    return await makeRequest(`https://ipapi.co/${currentIP}/json/`);
}
const importMeta = {
    url: "file:///Users/wookiee/sources/asyncapi-schema-store/index.ts",
    main: import.meta.main
};
const app2 = opine();
const __dirname = dirname2(importMeta.url);
app2.get("/", function(_req, res) {
    res.send("<ul>" + '<li>Download <a href="/files/2.0.0.json">AsyncAPI 2.0.0 JSON Schema</a>.</li>' + "</ul>");
});
app2.get("/files/:file(*)", async function(req, res, next) {
    const filePath1 = join2(__dirname, req.params.file);
    console.log("Object", req.headers);
    console.log("IP", await getIPLocation(req.ip));
    try {
        await res.download(filePath1);
        console.log("Spec got downloaded by another user :rocket:");
    } catch (err2) {
        if (err2 instanceof Deno.errors.NotFound) {
            res.status = 404;
            res.send("Cant find that file, sorry!");
            return;
        }
        return next(err2);
    }
});
if (importMeta.main) {
    app2.listen({
        port: 3000
    });
    console.log("Opine started on port 3000");
}
export { app2 as app };
